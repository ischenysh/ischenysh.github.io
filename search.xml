<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start<span id="more"></span></h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.25</title>
    <url>/2021/10/25/leetcode10-25/</url>
    <content><![CDATA[<p>题目:</p>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。<br><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii">链接</a></li>
</ul>
<h2 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路<span id="more"></span></h2><p>一开始我的思路就是通过两次二分找到答案,然后发现不行,因为二分不能直接找到答案所在的行;</p>
<p>所以我换了一个思路,先找到答案所在的行的区间再二分:</p>
<ol>
<li><strong>通过二分来找到行的上边界和下边界</strong></li>
<li><strong>对每一行进行二分搜索</strong></li>
</ol>
<p>具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;<span class="comment">// 开始寻找下边界</span></span><br><span class="line">        <span class="keyword">int</span> end = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;<span class="comment">// 找到左边界小于target的行</span></span><br><span class="line">                end = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> begin = -<span class="number">1</span>;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = end;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][m - <span class="number">1</span>] &gt;= target) &#123;<span class="comment">// 找到右边界打于target的行</span></span><br><span class="line">                begin = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;<span class="comment">// 对每一行二分</span></span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][mid] &lt; target) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][mid] &gt; target) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可是看了题解之后发现这个方法也不太行</p>
<h2 id="题解的思路"><a href="#题解的思路" class="headerlink" title="题解的思路:"></a>题解的思路:</h2><ol>
<li><p>从矩阵的右上角matrix[x] [y] (x = 0,  y = m - 1)开始查找, 答案就<strong>限定在matrix[x] [y]和matrix[n - 1] [0]之间</strong></p>
</li>
<li><p>如果matrix[x] [y] &gt; target, 说明 y 列都大于 target, 故<strong>应将y减一进行移动</strong></p>
</li>
<li><p>同理, 如果matrix[x] [y] &lt; target, 说明 x 行都大于 target, 故<strong>应将x加一进行移动</strong></p>
</li>
<li><p>如果 x, y 越界, 则找不到target, 应返回false</p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; n &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] &gt; target) &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Markdown学习</title>
    <url>/2021/10/25/Markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习<span id="more"></span></h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>hello, world!</p>
<p><strong>hello, world!</strong>(ctrl + b)</p>
<p><em>hello, world!</em>( ctrl + i)</p>
<p><em><strong>hello, world!</strong></em></p>
<p><del>hello, world!</del></p>
<p> <u>hello, world!</u> (ctrl + u)</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p><strong>学习要持之以恒                                                                                                                            -范佳兴</strong></p>
</blockquote>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
<hr>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="C:\Users\yoga\Pictures\asoul\珈乐\b025eb04fd5d728925d31da409ab25c764d3e815.jpg@1320w_1600h.webp" alt="截图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ischenysh/images@master/%E5%A4%B4%E5%83%8F.5afo5fhm0nc0.webp" alt="头像"></p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a class="link"   href="https://ischenysh.github.io/" >点击跳转到个人博客<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol>
<li>A</li>
<li>B</li>
<li>C</li>
</ol>
<ul>
<li>A</li>
<li>B</li>
<li>C</li>
</ul>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>姓名</th>
<th>性别</th>
<th>生日</th>
</tr>
</thead>
</table>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">psvm</span><br></pre></td></tr></table></figure>

<p><code>psvm</code></p>
]]></content>
  </entry>
  <entry>
    <title>多线程与并发</title>
    <url>/2021/10/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发<span id="more"></span></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="普通方法调用与多线程的区别"><a href="#普通方法调用与多线程的区别" class="headerlink" title="普通方法调用与多线程的区别:"></a>普通方法调用与多线程的区别:</h3><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B1.4ztxbzdar4w0.png" alt="多线程1"></p>
<h3 id="进程-Process-与线程-Thread-的区别"><a href="#进程-Process-与线程-Thread-的区别" class="headerlink" title="进程(Process)与线程(Thread)的区别"></a>进程(Process)与线程(Thread)的区别</h3><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E9%A1%B9%E7%A8%8B2.5xsngvti8vo0.png" alt="多项程2"></p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B4.2bfyewdz96f4.png" alt="多线程4"></p>
<ul>
<li><strong>NEW</strong> (新建)</li>
<li><strong>RUNNABLE</strong>(可运行)</li>
<li><strong>BLOCKED</strong>(阻塞)</li>
<li><strong>WAITING</strong>(等待)</li>
<li><strong>TIMED_WAITING</strong>(计时等待)</li>
<li><strong>TERMINATED</strong>(终止)</li>
</ul>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B3.2sjqzrq4id40.png" alt="多线程3"></p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">// 创建子线程对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> ThreadTest().start();<span class="comment">// 创建匿名对象并开启线程</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子类继承Thread类具有多线程能力</li>
<li>启动线程:子类对象.start()</li>
<li><strong>不建议使用:避免OOP单继承局限性</strong></li>
</ul>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadTest2()).start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现接口Runnable具有多线程能力</li>
<li>启动线程:传入目标对象+Thread对象.start()</li>
<li><strong>推荐使用:避免单继承局限性,灵活方便,方便同一个对象被多个线程使用</strong></li>
</ul>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;<span class="comment">// 实现Callable接口</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 重写call()方法, 有返回值且类型与Callable&lt;&gt;的尖括号中一样</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">		ThreadTest3 task1 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ThreadTest3 task2 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ThreadTest3 task3 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ExecutorService service = Executors.newCachedThreadPool();<span class="comment">// 创建服务</span></span><br><span class="line">        <span class="comment">// Future用于接受结果或结束任务, submit方法用于提交任务, 服务会将其并入线程池</span></span><br><span class="line">		Future&lt;Boolean&gt; ans1 = service.submit(task1);</span><br><span class="line">		Future&lt;Boolean&gt; ans2 = service.submit(task2);</span><br><span class="line">		Future&lt;Boolean&gt; ans3 = service.submit(task3);</span><br><span class="line">		System.out.println(ans1.get());<span class="comment">// 输出得到的结果</span></span><br><span class="line">		System.out.println(ans2.get());</span><br><span class="line">		System.out.println(ans3.get());</span><br><span class="line">		service.shutdown();<span class="comment">// 关闭服务</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>实现Callable接口, 需要返回值类型</p>
</li>
<li><p>重写call方法, 需要抛出异常</p>
</li>
<li><p>创建目标对象</p>
</li>
<li><p>创建执行服务:<code>ExecutorService service = Executors.newCachedThreadPool();</code></p>
</li>
<li><p>提交执行:<code>Future&lt;Boolean&gt; ans1 = service.submit(task1);</code></p>
</li>
<li><p>获取结果:<code>ans1.get()</code></p>
</li>
<li><p>关闭服务:<code>service.shutdown();</code></p>
<h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenyusheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Marry you = <span class="keyword">new</span> You();</span><br><span class="line">		<span class="keyword">new</span> WeddingCompany(you).HappyMarry();</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;我好开心!&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要结婚啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	Marry person;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry person)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.person = person;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;准备婚礼&quot;</span>);</span><br><span class="line">		person.HappyMarry();</span><br><span class="line">		System.out.println(<span class="string">&quot;收拾现场&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>真实对象和代理对象都要<strong>实现一个接口</strong></p>
</li>
<li><p>代理对象要<strong>代理</strong>真实角色</p>
</li>
</ul>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>代理对象可以做很多真实对象做不了的事情</li>
<li>真实对象<strong>专注做自己的事情</strong></li>
</ul>
<h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>setPriority(int newPriority)</code></td>
<td align="center">更改线程的优先级</td>
</tr>
<tr>
<td align="center"><code>static void sleep(long millis)</code></td>
<td align="center">在指定的毫秒数内让当前正在执行的线程休眠</td>
</tr>
<tr>
<td align="center"><code>void join()</code></td>
<td align="center">等待该线程终止</td>
</tr>
<tr>
<td align="center"><code>static void yield()</code></td>
<td align="center">暂停当前正在执行的线程对象, 并执行其他线程</td>
</tr>
<tr>
<td align="center"><code>void interrupt()</code></td>
<td align="center">设置线程中断标志为true</td>
</tr>
<tr>
<td align="center"><code>boolean isAlive</code></td>
<td align="center">测试线程是否处于活动状态</td>
</tr>
<tr>
<td align="center"><code>Thread.State getState()</code></td>
<td align="center">获取当前线程状态</td>
</tr>
<tr>
<td align="center"><code>static boolean Thread.Interrpted()</code></td>
<td align="center">获取当前线程的中断标志并清除标志</td>
</tr>
<tr>
<td align="center"><code>boolean isInterrupted()</code></td>
<td align="center">获取线程的中断标志但不会清除标志</td>
</tr>
</tbody></table>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><h3 id="使用标志位退出-正常退出"><a href="#使用标志位退出-正常退出" class="headerlink" title="使用标志位退出,正常退出"></a>使用标志位退出,正常退出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopTest1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">// 设置标志位</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadStopTest1 task = <span class="keyword">new</span> ThreadStopTest1();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">		task.flag = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用interrupt方法打断线程"><a href="#使用interrupt方法打断线程" class="headerlink" title="使用interrupt方法打断线程"></a>使用interrupt方法打断线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">// 判断线程的中断标志</span></span><br><span class="line">			<span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程被打断了, 拜拜!&quot;</span> </span><br><span class="line">                                   + <span class="string">&quot;中断标志 &quot;</span> </span><br><span class="line">                                   + Thread.currentThread().isInterrupted());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程被打断了, 拜拜!&quot;</span> </span><br><span class="line">                                   + <span class="string">&quot;中断标志 &quot;</span> </span><br><span class="line">                                   + Thread.currentThread().isInterrupted());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				sleep(<span class="number">200</span>);<span class="comment">// 如果在睡眠中被打断, 将会抛出InterruptedException异常</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				System.out.println(<span class="string">&quot;线程在睡眠中被打断了, 拜拜!&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStopTest2());</span><br><span class="line">		thread.start();</span><br><span class="line">		sleep(<span class="number">2000</span>);</span><br><span class="line">		thread.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一般写法"><a href="#一般写法" class="headerlink" title="一般写法"></a>一般写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = ()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep or wait</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clean up, <span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果每次工作迭代后都使用sleep()方法(或其他可中断方法), 则无需进行中断状态的检查, 因为在休眠中被打断,它会清除中断状态并抛出 <strong>InterruptedException</strong> 异常.代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = ()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">            Thread.sleep(delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clean up, <span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h2><p><code>static void yield</code></p>
<p><strong>静态方法</strong>, 使当前线程从运行状态变为<strong>就绪状态</strong>,让 cpu <strong>重新调度</strong>.</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p><code>thread.setDaemon(true)</code></p>
<p>将一个线程转换为守护线程, <strong>用户线程默认为 false</strong>, 用途是<strong>为其他线程提供服务</strong>, 如计时器, <strong>当只剩下守护线程时, 程序将会结束</strong></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="使用-Lock-Condition-结构"><a href="#使用-Lock-Condition-结构" class="headerlink" title="使用 Lock/Condition 结构"></a>使用 Lock/Condition 结构</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构:"></a>基本结构:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myLock.lock();<span class="comment">// 一个锁对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    myLock.unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>这个结构能够保证任何时刻只有一个线程能够进入临界区, 一旦一个线程锁定了锁对象, 其他任何线程都无法通过lock语句, 当其他线程调用lock时, 他们会暂停, 直到第一个线程释放这个锁对象.</p>
</li>
<li><p><strong>一个对象定义一个锁对象,</strong> 当两个线程操作两个对象时, 两个线程都不会阻塞</p>
</li>
</ul>
<h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><ul>
<li><p>当线程进入临界区后发现只有满足某个条件后它才能执行, 此时可以使用一个<strong>条件对象</strong>来管理这些线程</p>
</li>
<li><p>通过锁对象调用Condition方法<code>lock.newCondition()</code>来创建一个条件对象, 当线程不满足运行条件就通过条件对象来调用await方法<code>condition.await()</code><strong>将该线程暂停并放弃锁</strong><strong>, 该线程将进入这个条件的等待集(wait set), 当锁可用时, 该线程并不会变成可运行状态, 直到另一个线程在</strong>同一条件**下调用<code>signAll</code>方法<code>condition.signAll()</code>.</p>
</li>
<li><p><code>signAll()</code>方法会重新激活等待这个条件的所有线程, 将他们从等待集中移出, 它们再次变成可运行的线程, 当锁再次可用时, 他们中的某个线程将<strong>从<code>await()</code>调用中返回</strong>, 从<strong>暂停的地方继续执行</strong>.</p>
</li>
<li><p>此时, 线程应再次测试条件, <strong>不能保证现在一定满足条件-</strong>—-<code>signAll()</code>方法仅仅是通知等待的线程:</p>
<p><strong>现在有可能满足条件, 值得再次检查</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!OK to proceed) &#123;</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>死锁(deadlock)现象</strong>:所有线程都阻塞, 程序永远无法继续运行</li>
</ul>
<p>程序实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span>[] account;<span class="comment">// 银行账户</span></span><br><span class="line">	<span class="keyword">private</span> Lock lock;<span class="comment">// 锁对象</span></span><br><span class="line">	<span class="keyword">private</span> Condition sufficientFunds;<span class="comment">// 条件对象</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">double</span> initAmount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.account = <span class="keyword">new</span> <span class="keyword">double</span>[size];</span><br><span class="line">		Arrays.fill(<span class="keyword">this</span>.account, initAmount);</span><br><span class="line">		lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">		sufficientFunds = lock.newCondition();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从一个账户向另一个账户转账</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> from 转帐的一方</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> to 收钱的一方</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> amount 转账数额</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (account[from] &lt; amount) &#123;</span><br><span class="line">				sufficientFunds.await();<span class="comment">// 当余额不足时, 线程挂起</span></span><br><span class="line">			&#125;</span><br><span class="line">			account[from] -= amount;</span><br><span class="line">			account[to] += amount;</span><br><span class="line">			System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">					<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">			sufficientFunds.signalAll();<span class="comment">// 账户余额变更后应通知所有该条件的等待线程</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获得银行总资产</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 银行总资产</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalAsset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">double</span> e : account) &#123;</span><br><span class="line">				total += e;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> total;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USERSIZE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADSIZE = <span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAY = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> INITAMOUNT = <span class="number">10000.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bank bank = <span class="keyword">new</span> Bank(USERSIZE, INITAMOUNT);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADSIZE; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">						<span class="keyword">int</span> from = (<span class="keyword">int</span>) (Math.random() * USERSIZE);</span><br><span class="line">						<span class="keyword">int</span> to = (<span class="keyword">int</span>) (Math.random() * USERSIZE);</span><br><span class="line">						<span class="keyword">if</span> (from == to) &#123;</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">double</span> amount = Math.random() * INITAMOUNT;</span><br><span class="line">						bank.transfer(from, to, amount);</span><br><span class="line">						Thread.sleep(DELAY);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用-synchronized-关键字"><a href="#使用-synchronized-关键字" class="headerlink" title="使用 synchronized 关键字"></a>使用 synchronized 关键字</h3><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>Java中每一个对象都有一个对象内部锁, 当一个方法被声明为同步方法时, 对象内部锁将会保护整个方法</p>
<p>即:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		method body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		method body</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部对象锁只有一个关联对象, <code>wait()</code>方法将线程添加到等待集中, <code>notifyAll()</code>/<code>notify()</code>方法可以解除等待线程的阻塞,调用<code>wait()</code>方法和<code>notifyAll()</code>等价于调用:<br><code>intrinsicContition.await();</code><br><code>intrinsicContition.signalAll();</code></p>
<p>使用 synchronized 关键字的 transfer 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (account[from] &lt; amount) &#123;</span><br><span class="line">		wait();</span><br><span class="line">	&#125;</span><br><span class="line">	account[from] -= amount;</span><br><span class="line">	account[to] += amount;</span><br><span class="line">	System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">			<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">	notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul>
<li>最好不使用上面两种方法, 在大部分的情况下使用java.util.concurrent包中的某种机制就可以解决所有的锁定问题(<strong>不会用</strong>, <strong>笑嘻了</strong>)</li>
<li>如果使用 synchronized 关键字就可以满足你的需求, 就使用它, 因为可以让代码变得简洁</li>
<li>如果实在需要Lock/Condition 结构的额外能力才使用它</li>
</ul>
<h3 id="使用同步块"><a href="#使用同步块" class="headerlink" title="使用同步块"></a>使用同步块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;<span class="comment">// 获得该对象的锁</span></span><br><span class="line">	critical section<span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 同步块的 transfer 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Vector&lt;Double&gt; accounts, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (accounts) &#123;</span><br><span class="line">       	accounts.set(from, accounts.get(from) - amount);</span><br><span class="line">		accounts.set(to  , accounts.get(to  ) + amount);</span><br><span class="line">       &#125;</span><br><span class="line">	System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">			<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-volatile-关键字"><a href="#使用-volatile-关键字" class="headerlink" title="使用 volatile 关键字"></a>使用 volatile 关键字</h3><p>将一个实例字段声明为为 volatile , 可以保证该字段的修改对所有线程可见, 但由于不能保证其原子性, 故不能对其进行非原子的操作, 最好只进行赋值和读取.</p>
<p>具体可以查询<a class="link"   href="https://blog.csdn.net/u012723673/article/details/80682208?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163531427216780271545094%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163531427216780271545094&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80682208.first_rank_v2_pc_rank_v29&utm_term=volatile&spm=1018.2226.3001.4187" >Java volatile关键字最全总结<i class="fas fa-external-link-alt"></i></a>)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.26_496.下一个更大元素I</title>
    <url>/2021/10/27/leetcode10-26-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</url>
    <content><![CDATA[<p>题目如下<span id="more"></span></p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/leetcode10.26.nbf6kkpd9y8.png" alt="leetcode10"></p>
<h1 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h1><p>暴力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">boolean</span> isFound = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nums2[j] == nums1[i]) &#123;</span><br><span class="line">					index = j;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (nums2[j] &gt; nums1[i] &amp;&amp; index &lt; j) &#123;</span><br><span class="line">					ans[i] = nums2[j];</span><br><span class="line">					isFound = <span class="keyword">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!isFound) &#123;</span><br><span class="line">				ans[i] = -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题解真的牛逼, 麻了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> n = nums2.length;</span><br><span class="line">		stack.push(nums2[n - <span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 逆序遍历</span></span><br><span class="line">			<span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[i]) &#123;</span><br><span class="line">				stack.pop();<span class="comment">// pop栈中所有小于当前元素的值</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">				map.put(nums2[i], stack.peek());<span class="comment">// 如果栈不为空则右边存在比该元素大的值</span></span><br><span class="line">			&#125;</span><br><span class="line">			stack.push(nums2[i]);<span class="comment">// 存入当前元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">			num1[i] = map.getOrDefault(nums1[i], -<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逆序遍历 nums2 数组, 栈中只允许存在比当前元素大的元素, 则栈顶元素就为当前元素右边大于该元素的第一个元素, 如果栈为空则右边不存在比该元素大的元素, 用哈希表存储该答案,最后将当前元素push进去;</li>
<li>获取结果:遍历 nums1 数组, 将哈希表存储的答案写入</li>
<li>stack永远单调</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.28.869.重新排序得到 2 的幂</title>
    <url>/2021/10/28/leetcode10-28-869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0-2-%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述<span id="more"></span></h1><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/leedcode10.28.6hb3dzhwkeo0.png" alt="leedcode10"></p>
<h1 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路:"></a>个人思路:</h1><ul>
<li><p>利用递归加回溯进行全排列, </p>
</li>
<li><p>判断是否合法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归加回溯</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2_1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] nums = String.valueOf(n).toCharArray();</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">		<span class="keyword">return</span> dfs(nums, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((current &amp; (current - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vis.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[i] || (index == <span class="number">0</span> &amp;&amp; nums[i] == <span class="string">&#x27;0&#x27;</span>) || (i != <span class="number">0</span> &amp;&amp; !vis[i - <span class="number">1</span>] &amp;&amp; nums[i - <span class="number">1</span>] == nums[i])) &#123;<span class="comment">// 如果本次已经选中过相同的数字,就continue(!vis[i - 1] &amp;&amp; nums[i - 1] == nums[i])</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[i] = <span class="keyword">true</span>;</span><br><span class="line">			ans |= dfs(nums, index + <span class="number">1</span>, current * <span class="number">10</span> + nums[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			vis[i] = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路:"></a>题解思路:</h1><p>预处理加哈希表</p>
<ul>
<li><p>如果 a 和 b 重新排列后,都是同一个 2 的幂, 那么他们每个数字出现的次数应该相同,</p>
</li>
<li><p>利用这个结论我们可以将 1 到1e9 之间的 2 的幂的每个数字出现的次数转化成字符串全部存到set中.</p>
</li>
<li><p>查询即可</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_2</span> </span>&#123;</span><br><span class="line">	Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		init();<span class="comment">// 初始化</span></span><br><span class="line">		<span class="keyword">return</span> set.contains(numsCount(n));<span class="comment">// 查询</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">// 将 1 到1e9 之间的 2 的幂的每个数字出现的次数转化成字符串全部存到set中.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e9</span>; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			set.add(numsCount(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">numsCount</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;<span class="comment">// 每个数字出现的次数转化成字符串</span></span><br><span class="line">		<span class="keyword">int</span>[] numsCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			numsCount[num % <span class="number">10</span>]++;</span><br><span class="line">			num /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(numsCount);</span><br><span class="line">		<span class="keyword">return</span> String.valueOf(numsCount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Java 流</title>
    <url>/2021/10/28/Java-%E6%B5%81/</url>
    <content><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="从迭代到流的操作"><a href="#从迭代到流的操作" class="headerlink" title="从迭代到流的操作"></a>从迭代到流的操作</h2><p>当处理集合时, 我们通常会迭代它的元素, 并在每个元素上执行某项操作. </p>
<p>例如, 假设我们想要对某本书的所有长单词进行计数.首先, 将所有单词放到一个列表里:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String contents = <span class="keyword">new</span> String(</span><br><span class="line">				Files.readAllBytes(path), StandardCharsets.UTF_8);</span><br><span class="line">List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));<span class="comment">// 以非字母的字符为分隔符</span></span><br></pre></td></tr></table></figure>

<p>如果使用迭代:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String e : words) &#123;</span><br><span class="line">	<span class="keyword">if</span> (e.length() &gt; <span class="number">12</span>) &#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用流:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.Stream().filter(e -&gt; e.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>

<p>仅将<code>Stream</code>改为<code>parallelStream</code>就可以让流库以并行方式执行过滤和计数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.parallelStream().filter(e -&gt; e.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>

<h3 id="流与集合的差距"><a href="#流与集合的差距" class="headerlink" title="流与集合的差距"></a>流与集合的差距</h3><ul>
<li>流不存储元素, 这些元素可能存储在底层的集合中, 或者按需生成.</li>
<li>流的操作不会改变其数据源. 例如, <code>filter</code>方法不会从流中移除元素, 而是产生一个新的流, 其中不包含被过滤掉的元素</li>
<li>流的操作时尽可能惰性执行的, 这意味着直至需要结果时,操作才会执行,</li>
</ul>
<p>示例解释:</p>
<p><code>Stream</code>和<code>parallelStream</code>方法会产生一个用于 words 列表的 stream . <code>filter</code>方法会返回另一个流, 其中只包含长度大于12的单词. count 方法会将这个流化简为一个结果.</p>
<h3 id="操作流时的典型流程"><a href="#操作流时的典型流程" class="headerlink" title="操作流时的典型流程"></a>操作流时的典型流程</h3><ol>
<li>创建一个流.</li>
<li>指定将初始流转换成其他流的中间操作, 可能包含多个步骤.</li>
<li>引用停止操作, 从而产生结果, 这个操作会强制执行之前的惰性操作, 从此之后, 这个流就不能用了</li>
</ol>
<p>实例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wordCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountLongWord</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String contents = <span class="keyword">new</span> String(</span><br><span class="line">				Files.readAllBytes(path), StandardCharsets.UTF_8);</span><br><span class="line">		List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));<span class="comment">// 以非字母的字符为分隔符</span></span><br><span class="line">		<span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (String e : words) &#123;</span><br><span class="line">			<span class="keyword">if</span> (e.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		count = words.stream().filter(e -&gt; e.length() &gt; <span class="number">5</span>).count();</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		count = words.parallelStream().filter(e -&gt; e.length() &gt; <span class="number">5</span>).count();</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		CountLongWord(Paths.get(<span class="string">&quot;D:\\Documents\\blog\\themes\\hexo-theme-keep\\languages\\en.yml&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>java io流</title>
    <url>/2021/10/28/java-io%E6%B5%81-0/</url>
    <content><![CDATA[<h1 id="IO概念"><a href="#IO概念" class="headerlink" title="IO概念"></a>IO概念</h1><ul>
<li>I/O 即输入Input/Output的缩写, 其实就是计算机调度吧吧各个存储中(包括内存和外存)的数据写入写出的过程;<span id="more"></span></li>
<li>java中用”流(stream)”来抽象表示这么一个写入写出的功能,封装成一个”类”, 都放在java.io这个包里面.</li>
</ul>
<h1 id="“流”是什么"><a href="#“流”是什么" class="headerlink" title="“流”是什么"></a>“流”是什么</h1><p>通过”流”的形式允许java程序通过使用相同的方式来访问不同的输入/输出源. stream是从起源(source)到接收的(sink)的有序数据. 如果把输入/输出源对比成’水桶’, 那么流就是”管道”, 这个”管道”的粗细, 单向性等属性也就是区分了不同”流”的特性.</p>
<h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ol>
<li><p>按照流的方向(输入输出都是站在程序所在内存的角度划分的)</p>
<ul>
<li>输入流:只能从中读取数据[主要由InputStream和Reader作为基类]</li>
<li>输出流:只能先其写入数据[主要由outputStream和Writer作为基类]</li>
</ul>
</li>
<li><p>按照流的操作颗粒度划分</p>
<ul>
<li>字节流: 以字节为单元, 可操作任何数据[主要由InputStream和OutputStream作为基类]</li>
<li>字符流: 以字符为单元, 只能操作纯字符数据, 比较方便[主要由Reader和Writer作为基类]</li>
</ul>
</li>
<li><p>按照六点角色划分</p>
<ul>
<li>节点流: 可以从/向一个特定的IO设备(如磁盘, 网络) 读/写 数据的流, 也叫[低级流, 主要流]</li>
<li>处理流: 用于对一个已存在的流进行封装, 通过封装后的流来实现数据的 读/写 功能, 也叫[高级流]</li>
</ul>
</li>
</ol>
<h1 id="流的原理以及一共有多少IO流"><a href="#流的原理以及一共有多少IO流" class="headerlink" title="流的原理以及一共有多少IO流"></a>流的原理以及一共有多少IO流</h1><h2 id="流的原理解析"><a href="#流的原理解析" class="headerlink" title="流的原理解析"></a>流的原理解析</h2><blockquote>
<p>流想象成”水管”, 源端和目的端就是两个’水桶’, 数据是通过这个”水管”进行流动传输的, 以”InputStream”和Reader为例, 水管的每个”水滴”就是具体的数据, 如果是字节流, 那么一个”水滴”就是一个字节, 如果是字符流, 那么一个”水滴”就是一个字符</p>
</blockquote>
<p>当创建一个流对象的时候, 如<code>fis = new FileInputstream(&quot;...\xx\xx.txt&quot;)</code>, 记录指针表示当前正准备从哪个”水滴”开始读取, 每当程序从InputStream或者Reader里面取出一个或多个”水滴”后, 记录指针自定向后移动; 除此之外, InputStream和Reader里面都提供了一些方法来控制记录指针的移动.如果是处理流的话, 就相当于在这个”水管”上面装了一些”控制阀门”, 最终用户只要关心”阀门”具备的能力就行.</p>
<h2 id="java中所有流汇总"><a href="#java中所有流汇总" class="headerlink" title="java中所有流汇总"></a>java中所有流汇总</h2><p>java.io种子类中有40个”流”类, 表格如下</p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/IO1.1645xmt3farg.png" alt="IO1"></p>
<h1 id="常见IO流的实战"><a href="#常见IO流的实战" class="headerlink" title="常见IO流的实战"></a>常见IO流的实战</h1><h2 id="访问操作文件-FileInputStream-FileReader-FileOutStream-FileWriter"><a href="#访问操作文件-FileInputStream-FileReader-FileOutStream-FileWriter" class="headerlink" title="访问操作文件(FileInputStream/FileReader, FileOutStream/FileWriter)"></a>访问操作文件(FileInputStream/FileReader, FileOutStream/FileWriter)</h2><ol>
<li><p>使用FileInputStream, 从文件中读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileInputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">null</span>;<span class="comment">// 使用FileInputStream</span></span><br><span class="line"><span class="comment">//      FileReader in = null;// 使用FileReader</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);<span class="comment">// 使用FileInputStream</span></span><br><span class="line"><span class="comment">//			in = new FileReader(&quot;D:\\Documents\\logs\\java0.log&quot;);// 使用FileReader</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;文件未找到, 程序退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line">			in.close();</span><br><span class="line">			System.out.println(<span class="string">&quot;共读取了&quot;</span> + len + <span class="string">&quot;个字节&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常, 程序退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用输出流, 往文件中写数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileOutputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//		FileInputStream in = null;</span></span><br><span class="line">		FileReader in = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//		FileOutputStream out = null;</span></span><br><span class="line">		FileWriter out = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//			in = new FileInputStream(&quot;D:\\Documents\\logs\\java0.log&quot;);</span></span><br><span class="line">			in = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);</span><br><span class="line"><span class="comment">//			out = new FileOutputStream(&quot;D:\\Documents\\logs\\java1.log&quot;);</span></span><br><span class="line">			out = <span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\Documents\\logs\\java1.log&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;不存在该文件,程序即将退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				out.write(b);</span><br><span class="line">			&#125;</span><br><span class="line">			in.close();</span><br><span class="line">			out.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常, 程序即将退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;文件复制完成!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="缓存流的使用-BufferedInputStream-BuffereOutputStream-BufferedReader-BufferedWriter"><a href="#缓存流的使用-BufferedInputStream-BuffereOutputStream-BufferedReader-BufferedWriter" class="headerlink" title="缓存流的使用(BufferedInputStream/BuffereOutputStream, BufferedReader/BufferedWriter)"></a>缓存流的使用(BufferedInputStream/BuffereOutputStream, BufferedReader/BufferedWriter)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">		FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">		BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">		BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);</span><br><span class="line">			fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\Documents\\logs\\java1.log&quot;</span>);</span><br><span class="line">			bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">			bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((off = bis.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				bos.write(buffer, <span class="number">0</span>, off);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;文件复制完成&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			bis.close();</span><br><span class="line">			bos.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换流的使用-InputStreamReader-OutputStreamReader"><a href="#转换流的使用-InputStreamReader-OutputStreamReader" class="headerlink" title="转换流的使用(InputStreamReader/OutputStreamReader)"></a>转换流的使用(InputStreamReader/OutputStreamReader)</h2><p>将字节流转化成字符流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\Documents\\logs\\java2.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (line.equals(<span class="string">&quot;over&quot;</span>))&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			bw.write(line);</span><br><span class="line">			bw.newLine();</span><br><span class="line">			bw.flush();<span class="comment">// 刷新字符输出流</span></span><br><span class="line">		&#125;</span><br><span class="line">		br.close();</span><br><span class="line">		bw.close();<span class="comment">// 关闭前必须刷新</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>对象流就是一种特殊的处理流, 也是在基础的字节流上封装.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectOutputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Person ming = <span class="keyword">new</span> Person(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">15</span>);</span><br><span class="line">			FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\Documents\\logs\\java3.txt&quot;</span>);</span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">			oos.writeObject(ming);</span><br><span class="line">			FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java3.txt&quot;</span>);</span><br><span class="line">			ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">			Person p2 = (Person) ois.readObject();</span><br><span class="line">			System.out.println(p2);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			oos.flush();</span><br><span class="line">			oos.close();</span><br><span class="line">			ois.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;<span class="comment">// 对象必须实现序列化接口</span></span><br><span class="line">	<span class="keyword">private</span> String name = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节数据流的使用（ByteArrayInputStream-ByteArrayOutputStream）【通常结合数据流DataInputStream-DataOutputStream】"><a href="#字节数据流的使用（ByteArrayInputStream-ByteArrayOutputStream）【通常结合数据流DataInputStream-DataOutputStream】" class="headerlink" title="字节数据流的使用（ByteArrayInputStream/ByteArrayOutputStream）【通常结合数据流DataInputStream/DataOutputStream】"></a>字节数据流的使用（ByteArrayInputStream/ByteArrayOutputStream）【通常结合数据流DataInputStream/DataOutputStream】</h2><ul>
<li>为了提高效率, 避免频繁的读写文件, 于是出现了字节数组流, 因为存放在内存中, 所以也被称为”内存流”; 字节数组流也是一种节点流;</li>
<li>数据处理流是一种处理流, 用于针对数据类型传输处理的, 一般用于序列化与反序列化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDateStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">// 创建字节数组, 同时会在内存中创建数组</span></span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);<span class="comment">// 将字节数组流封装成数据处理流</span></span><br><span class="line">		DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			dos.writeDouble(Math.random());</span><br><span class="line">			dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">			ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">			System.out.println(bais.available());</span><br><span class="line"></span><br><span class="line">			dis = <span class="keyword">new</span> DataInputStream(bais);</span><br><span class="line">			System.out.println(dis.readDouble());</span><br><span class="line">			System.out.println(dis.readBoolean());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			dos.close();</span><br><span class="line">			dis.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>junit入门</title>
    <url>/2021/10/31/junit%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="junit单元测试"><a href="#junit单元测试" class="headerlink" title="junit单元测试"></a>junit单元测试<span id="more"></span></h1><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><ul>
<li>黑盒测试 : 不关注具体的代码实现, 只需要关注能否得到正确结果</li>
<li>白盒测试 : 不只要关注能否得到正确结果, 还要关注具体的代码实现</li>
</ul>
<h2 id="junit使用"><a href="#junit使用" class="headerlink" title="junit使用"></a>junit使用</h2><ul>
<li><p>步骤</p>
<ol>
<li><p>定义一个测试类(测试用例)</p>
<p>建议:</p>
<ul>
<li>测试类名 : 被测试的类 + Test</li>
<li>包名 : 与被测试的类所在的包同级, 且取名为test <img src="https://raw.githubusercontent.com/ischenysh/images/master/junit.2wcf1jwyhj60.png" alt="junit"></li>
</ul>
</li>
<li><p>定义测试方法 : <strong>可以独立运行</strong></p>
<p>建议:</p>
<ul>
<li>方法名 : test + 被测试的方法名</li>
<li>返回值 : void</li>
<li>参数列表 : 空参</li>
</ul>
</li>
</ol>
<ol start="3">
<li>给方法前加 <em>@test</em> 注解</li>
<li>导入junit 依赖环境</li>
</ol>
</li>
<li><p>判定结果</p>
<ul>
<li>红色 : 失败</li>
<li>绿色 : 成功</li>
<li>一般会使用断言操作</li>
</ul>
</li>
<li><p>补充</p>
<ul>
<li><p><em>@Before</em> :</p>
<p>被注解的方法总是在测试方法之前执行</p>
</li>
<li><p><em>@After</em> :</p>
<p>被注解的方法总是在测试方法之后执行</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.junit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a - b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chenysh.junit.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Calculator calculator;</span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		一般用于申请资源, 总是在test方法执行之前执行</span></span><br><span class="line">		calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">		System.out.println(<span class="string">&quot;我被初始化啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/**test使用规范:</span></span><br><span class="line"><span class="comment">   *总是返回null</span></span><br><span class="line"><span class="comment">   *无参数传入</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = calculator.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		Assert.assertEquals(result, <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = calculator.sub(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		Assert.assertEquals(result, -<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@After</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		一般用于清理资源, 总是在test方法执行之后执行, 不管test方法有没有正常执行完成</span></span><br><span class="line">		System.out.println(<span class="string">&quot;我被清理啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>反射入门</title>
    <url>/2021/10/31/%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="反射-框架设计的灵魂"><a href="#反射-框架设计的灵魂" class="headerlink" title="反射 : 框架设计的灵魂"></a>反射 : 框架设计的灵魂<span id="more"></span></h1><ul>
<li><p>框架 : 半成品软件, 可以在框架的基础上进行软件开发, 简化编码</p>
</li>
<li><p>反射 : 将类的各个组成部分封装为其他对象</p>
<p>​    好处:</p>
<ul>
<li><p>可以在程序运行过程中操作这些对象</p>
</li>
<li><p>可以解耦, 增强程序的拓展性</p>
</li>
</ul>
</li>
</ul>
<h2 id="获取class-对象的方式"><a href="#获取class-对象的方式" class="headerlink" title="获取class 对象的方式"></a>获取class 对象的方式</h2><ol>
<li><p><code>Class.forName(&quot;全类名&quot;)</code> : 将字节码加载进内存, 返回 class 对象</p>
<p>多用于配置文件, 使类名定义在配置文件中; 通过读取文件来加载类</p>
</li>
<li><p><code>类名.class</code> : 通过类名的属性 class 获取</p>
<p>用于参数的传递</p>
</li>
<li><p><code>对象.getClass()</code> : getClass() 方法定义在 Object 类中</p>
<p>多用于对象的获取字节码的方式</p>
</li>
<li><p>结论 : </p>
<p>同一个字节码文件(*.class)在一次程序运行过程中只会被加载一次, 所有方式获取的Class对象都是同一个</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class class1 = Class.forName(<span class="string">&quot;com.chenysh.reflect.Person&quot;</span>);</span><br><span class="line">		Class class2 = Person.class;</span><br><span class="line">		Class class3 = <span class="keyword">new</span> Person().getClass();</span><br><span class="line">		System.out.println(class1.equals(class2));</span><br><span class="line">		System.out.println(class2.equals(class3));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="class对象的功能"><a href="#class对象的功能" class="headerlink" title="class对象的功能"></a>class对象的功能</h2><ul>
<li><p>获取功能</p>
<ol>
<li><p>获取成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] getFields()</span><br><span class="line"><span class="function">Field <span class="title">getFields</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>获取成员构造方法</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>获取成员方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure></li>
<li><p>获取类名</p>
<p><code>String getName()</code></p>
</li>
</ol>
</li>
<li><p>成员变量</p>
<ol>
<li><p>设置值</p>
<p><code>void set(Object obj, Object value)</code></p>
</li>
<li><p>获取值</p>
<p><code>get (Object obj)</code></p>
</li>
<li><p>忽略访问权限修饰符的安全检查</p>
<p><code>setAccessible(true)</code>// 暴力反射</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Field[] getFields()</span></span><br><span class="line"><span class="comment">Field getField(String name)</span></span><br><span class="line"><span class="comment">Field getDeclaredField(String name)</span></span><br><span class="line"><span class="comment">Field[] getDeclaredFields()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Constructor&lt;?&gt;[] getConstructors()</span></span><br><span class="line"><span class="comment">Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Constructor&lt;?&gt;[] getDeclaredConstructors()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Method[] getMethods()</span></span><br><span class="line"><span class="comment">Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Method[] getDeclaredMethods()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="number">20</span>, <span class="string">&quot;man&quot;</span>, <span class="string">&quot;chenysh&quot;</span>);</span><br><span class="line">		Class class1 = Person.class;</span><br><span class="line">		Field field2 = class1.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">		Field[] fields = class1.getFields();</span><br><span class="line">		System.out.println(field2.get(person));</span><br><span class="line">		field2.set(person, <span class="number">2</span>);<span class="comment">// 修改字段的值</span></span><br><span class="line">		System.out.println(field2.get(person));<span class="comment">// 设置字段的值</span></span><br><span class="line">		<span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">			System.out.println(field);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">		Field field = class1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		fields = class1.getDeclaredFields();</span><br><span class="line">		<span class="keyword">for</span> (Field field1 : fields) &#123;</span><br><span class="line">			System.out.println(field1);</span><br><span class="line">		&#125;</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>);<span class="comment">// 暴力反射</span></span><br><span class="line">		System.out.println(field.get(person));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Constructor[] constructors = class1.getConstructors();</span><br><span class="line">		Constructor constructor = class1.getConstructor(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, String.class, String.class);</span><br><span class="line">		System.out.println(constructor);</span><br><span class="line">		<span class="keyword">for</span> (Constructor constructor1 : constructors) &#123;</span><br><span class="line">			System.out.println(constructor1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Person person1 = (Person) constructor.newInstance(<span class="number">2</span>, <span class="number">21</span>, <span class="string">&quot;yuan&quot;</span>, <span class="string">&quot;woman&quot;</span>);<span class="comment">//      全参构造</span></span><br><span class="line">		System.out.println(person1);</span><br><span class="line">		Object obj = constructors[<span class="number">1</span>].newInstance();<span class="comment">// 空参构造1</span></span><br><span class="line">		System.out.println(obj);</span><br><span class="line">		System.out.println((Person) class1.newInstance());<span class="comment">// 空参构造2</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Method method = class1.getMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">		method.invoke(person, <span class="string">&quot;yuanqinakai&quot;</span>);<span class="comment">// 调用方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li><p>需求 : 写一个”框架”, 可以帮我们创建任意类对象, 并且执行其中任意方法 </p>
</li>
<li><p>实现 :</p>
<ol>
<li>配置文件</li>
<li>反射</li>
</ol>
</li>
<li><p>步骤 : </p>
<ol>
<li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中(配置文件放在src目录下)</li>
<li>在程序中加载读取配置文件</li>
<li>使用反射技术来加载类文件进内存</li>
<li>创建对象</li>
<li>执行方法</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo03</span> </span>&#123;</span><br><span class="line"><span class="comment">//	可以帮我们创建任意类对象, 并且执行其中任意方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		1. 加载配置文件</span></span><br><span class="line"><span class="comment">//		1.1 创建 Properties 对象</span></span><br><span class="line">		Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//		1.2 加载配置文件, 转换为一个集合</span></span><br><span class="line"><span class="comment">//      1.2.1 获取class目录下的配置文件</span></span><br><span class="line">		ClassLoader classLoader = demo03.class.getClassLoader();</span><br><span class="line">		InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;demo.properties&quot;</span>);</span><br><span class="line">		properties.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		2. 获取配置文件中定义的数据</span></span><br><span class="line">		String className = properties.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">		String methodName = properties.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		3. 加载该类进内存</span></span><br><span class="line">		Class aClass = Class.forName(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		4. 创建对象</span></span><br><span class="line">		Object obj = aClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//		5.获取方法对象</span></span><br><span class="line">		Method method = aClass.getMethod(methodName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		6. 执行方法</span></span><br><span class="line">		method.invoke(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>注解的介绍</title>
    <url>/2021/10/31/%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解<span id="more"></span></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>概念 : 说明程序的, 给计算机看</p>
</li>
<li><p>与注释的区别 : 注释是给人看的</p>
</li>
<li><p>定义 : <strong>Java注解</strong>又称<strong>Java标注</strong>，是<a class="link"   href="https://zh.wikipedia.org/wiki/Java" >Java<i class="fas fa-external-link-alt"></i></a>语言<strong>5.0版本</strong>开始支持加入<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81" >源代码<i class="fas fa-external-link-alt"></i></a>的特殊语法<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%85%83%E6%95%B0%E6%8D%AE" >元数据<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3#cite_note-1" >1]<i class="fas fa-external-link-alt"></i></a>。</p>
<p>Java语言中的类、方法、变量、参数和包等都可以被标注。和<a class="link"   href="https://zh.wikipedia.org/wiki/Javadoc" >Javadoc<i class="fas fa-external-link-alt"></i></a>不同，Java标注可以通过反射获取标注内容。在<a class="link"   href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8" >编译器<i class="fas fa-external-link-alt"></i></a>生成<a class="link"   href="https://zh.wikipedia.org/w/index.php?title=%E7%B1%BB%E6%96%87%E4%BB%B6&action=edit&redlink=1" >类文件<i class="fas fa-external-link-alt"></i></a>时，标注可以被嵌入到<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81" >字节码<i class="fas fa-external-link-alt"></i></a>中。<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" >Java虚拟机<i class="fas fa-external-link-alt"></i></a>可以保留标注内容，在运行时可以获取到标注内容[<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3#cite_note-2" >2]<i class="fas fa-external-link-alt"></i></a>。 当然它也支持自定义Java标注[<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3#cite_note-3" >3]<i class="fas fa-external-link-alt"></i></a>。</p>
</li>
<li><p>使用方法 : @ + 注解名称</p>
</li>
<li><p>作用分类 :</p>
<ol>
<li><p>编写文档 : 通过代码里表识的注解生成文档 [生成文档 doc文档] 命令行 javadoc + Java源文件名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解javadoc演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chnysh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算两数之和</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a 整数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> b 整数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 两数之和</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<em>javadoc demo01.java</em></p>
</li>
<li><p>代码分析 : 通过代码里的标识的注解对代码进行分析[使用反射]</p>
</li>
<li><p>编译检查 : 通过代码里标识的注解让编译器能够实现基本的编译检查[<em>@Override</em>]</p>
</li>
</ol>
</li>
</ul>
<h2 id="java中预定义的注解"><a href="#java中预定义的注解" class="headerlink" title="java中预定义的注解"></a>java中预定义的注解</h2><ul>
<li><code>@Override</code> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li><code>@Deprecated</code> - 标记过时方法。如果使用该方法，会报编译警告。</li>
<li><code>@SuppressWarnings</code> - 指示编译器去忽略注解中声明的警告。[@SuppressWarnings(“all”)]</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul>
<li><p>格式 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称()&#123;</span><br><span class="line">    属性列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>本质 : 注解的本质就是一个接口, 该接口默认继承Annotation接口</p>
</li>
<li><p>属性 : 接口中定义的成员方法</p>
<ul>
<li><p>要求:</p>
<ol>
<li><p>属性的返回值类型限制 : </p>
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
<li><p>定义了属性, 在使用注解时需要给其赋值</p>
<ul>
<li>可以使用default关键字给属性默认的初始化值, 这样在使用注解时可以选择不赋值</li>
<li>如果只有一个属性, 且名为 value, 则 value 可以省略, 直接定义值</li>
<li>数组赋值时要使用 {}, 如果数组中只有一个值, 则可以省略 {}</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>元注解 : 用于描述注解的注解</p>
<ul>
<li><p>@Target : 描述注解能够作用的位置</p>
<p>ElementType取值: </p>
<ul>
<li>TYPE : 类</li>
<li>METHOD : 方法</li>
<li>FIELD : 成员变量</li>
</ul>
</li>
<li><p>@Retention : 描述注解被保留的阶段</p>
<p>RetentionPolicy取值</p>
<ul>
<li>SOURCE : 保留在源文件中</li>
<li>CLASS : 保留到字节码中</li>
<li>RUNTIME : 保留到字节码中, 且可以被JVM读取到 </li>
</ul>
</li>
<li><p>@Documented : 描述注解是否被抽取到 api 文档中</p>
</li>
<li><p>@Inherited : 描述注解是否被子类继承</p>
</li>
</ul>
</li>
</ul>
<h2 id="在程序中使用注解-获取注解中定义的属性值"><a href="#在程序中使用注解-获取注解中定义的属性值" class="headerlink" title="在程序中使用注解 : 获取注解中定义的属性值"></a>在程序中使用注解 : 获取注解中定义的属性值</h2><ol>
<li><p>获取注解定义的位置类的字节码文件对象 (Class, Method, Field)</p>
</li>
<li><p>获取需要的注解</p>
<p><code>getAnnotation(Class)</code></p>
</li>
<li><p>调用注解中的抽象方法获取配置的属性值 : <strong>本质是一个实现类实现了抽象方法</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@properties(className = &quot;com.chenysh.domain.Person&quot;, methodName = &quot;eat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">personTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		获取该类的字节码文件对象</span></span><br><span class="line">		Class personTestClass = personTest.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//		获取注解对象</span></span><br><span class="line">		properties anno = (properties) personTestClass.getAnnotation(properties.class);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		使用注解对象的属性</span></span><br><span class="line">		Class aClass = Class.forName(anno.className());</span><br><span class="line">		Object obj = aClass.newInstance();</span><br><span class="line">		Method method = aClass.getMethod(anno.methodName());</span><br><span class="line">		method.invoke(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>大多数只要会使用注解即可</li>
<li>注解不是程序的一部分, 可以理解为一个标签</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MySQL学习</title>
    <url>/2021/10/31/MySQL%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="数据库-DateBase-简介"><a href="#数据库-DateBase-简介" class="headerlink" title="数据库(DateBase)简介"></a>数据库(DateBase)简介<span id="more"></span></h1><ul>
<li><p>数据库的英文单词 : DateBase  简称(DB)</p>
</li>
<li><p>什么是数据库 :</p>
<p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p>
</li>
<li><p>数据库的特点 :</p>
<ol>
<li>持久化存储数据.</li>
<li>方便存储和管理</li>
<li>使用了统一的方式操作数据库 –<strong>SQL</strong></li>
</ol>
</li>
<li><p>MySQL数据库</p>
<ul>
<li><p>MySQL 是一个关系型数据库管理系统, 开源且强大</p>
</li>
<li><p>使用 : </p>
<p>打开与关闭MySQL服务:</p>
<p>​    net start mysql;</p>
<p>​    net stop mysql;</p>
<p>登录与登出 :</p>
<p>​    mysql -u +  用户名 -p + 密码(p与密码中间不能有空格)    </p>
<p>​    exit 或 quit</p>
</li>
</ul>
</li>
</ul>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>简介 : <strong>SQL</strong>，<strong>Structured Query Language:结构化查询语言</strong>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-6" >6]<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-7" >7]<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-8" >8]<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-9" >9]<i class="fas fa-external-link-alt"></i></a>）是一种<a class="link"   href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%AE%9A%E7%9B%AE%E7%9A%84%E7%A8%8B%E5%BC%8F%E8%AF%AD%E8%A8%80" >特定目的编程语言<i class="fas fa-external-link-alt"></i></a>，用于管理<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" >关系数据库管理系统<i class="fas fa-external-link-alt"></i></a>（RDBMS），或在<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" >关系流数据管理系统<i class="fas fa-external-link-alt"></i></a>（RDSMS）中进行流处理。</p>
<ul>
<li><p>通用语法:</p>
<ol>
<li>SQL语句可以单行或多行书写, 以分号结尾.</li>
<li>可使用空格或缩进来提高可读性</li>
<li>SQL语句不区分大小写, 但推荐关键字大写</li>
<li>单行注释 – 或 #</li>
<li>多行注释/* 注释 */</li>
</ol>
</li>
<li><p>SQL分类</p>
<ol>
<li><p><strong>DDL</strong>(DateBase Definition Language) : 数据定义语言</p>
<p>用来定义数据库对象 : 数据库, 表, 列等, 关键字 : create, drop, alter等</p>
</li>
<li><p>DML(DateBase Manipulation Language) : 数据操作语言</p>
<p>用于对数据库中表的数据进行增删改. 关键字 : insert, delete, update等</p>
</li>
<li><p>DQL(DateBase Query Language) : 数据查询语言</p>
<p>用于查询数据库中表的记录(数据). 关键字 : select, where 等</p>
</li>
<li><p>DCL(DateBase Control Language) : 数据控制语言</p>
<p>用于定义数据库中的访问权限和安全级别以及创建用户. 关键字 : GRANT, REVOKE 等 </p>
</li>
</ol>
</li>
</ul>
<h2 id="DDL-操作数据库-表"><a href="#DDL-操作数据库-表" class="headerlink" title="DDL : 操作数据库, 表"></a>DDL : 操作数据库, 表</h2><h3 id="操作数据库-CRUD"><a href="#操作数据库-CRUD" class="headerlink" title="操作数据库 : CRUD"></a>操作数据库 : <strong>CRUD</strong></h3><ul>
<li><p>C(Create) : 创建</p>
<ul>
<li><p>创建数据库</p>
<p><code>create datebase 数据库名称; </code></p>
</li>
<li><p>当数据库不存在时创建数据库</p>
<p><code>create datebase if not exists 数据库名称; </code></p>
</li>
<li><p>当数据库并设定字符集</p>
<p><code>create datebase 数据库名称 character set 字符集名;</code></p>
</li>
</ul>
<p> <code>create datebase if not exists 数据库名称 character set 字符集名;</code></p>
</li>
<li><p>R(Retrieve) : 查询</p>
<ul>
<li><p>查询所有数据库的名称</p>
<p><code>show databases;</code></p>
</li>
<li><p>查询某个数据库的创建语句</p>
<p><code>show create database 数据名称;</code></p>
</li>
</ul>
</li>
<li><p>U(Update) : 修改</p>
<ul>
<li><p>修改字符串的字符集</p>
<p><code>alter database 数据库名称 character set 字符集名称;</code></p>
</li>
</ul>
</li>
<li><p>D(Delete) : 删除</p>
<ul>
<li><p>删除数据库</p>
<p><code>drop datebase 数据库名称; </code></p>
</li>
<li><p>当数据库存在时删除数据库</p>
<p><code>drop datebase if exists 数据库名称; </code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用数据库</p>
<ul>
<li><p>使用数据库</p>
<p><code>use 数据库名称;</code></p>
</li>
<li><p>查询当前正在使用的数据库名称</p>
<p><code>select database();</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="操作表-CRUD"><a href="#操作表-CRUD" class="headerlink" title="操作表 : CRUD"></a>操作表 : <strong>CRUD</strong></h3><ul>
<li><p>C(Create) : 创建</p>
<ol>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    列名<span class="number">1</span> 数据类型,</span><br><span class="line">    列名<span class="number">2</span> 数据类型,</span><br><span class="line">    ...</span><br><span class="line">    列名n 数据类型</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">like</span> 要复制的表名;</span><br></pre></td></tr></table></figure></li>
<li><p>数据类型</p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/sql1.43288dgb5j80.png" alt="sql1"></p>
<p><img src="C:\Users\yoga\AppData\Roaming\Typora\typora-user-images\image-20211031192630420.png" alt="image-20211031192630420"></p>
<p><img src="C:\Users\yoga\AppData\Roaming\Typora\typora-user-images\image-20211031192640110.png" alt="image-20211031192640110"></p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>R(Retrieve) : 查询</p>
<ul>
<li><p>查询某个数据库的所有表的名称</p>
<p><code>show tables;</code></p>
</li>
<li><p>查询表结构</p>
<p><code>desc 表名;</code></p>
</li>
</ul>
</li>
<li><p>U(Update) : 修改</p>
<ul>
<li><p>修改表名</p>
<p><code>alter table 表名 rename to 新表名;</code></p>
</li>
<li><p>修改表的字符集</p>
<p><code>alter table 表名 character set 字符集名;</code></p>
</li>
<li><p>添加一列</p>
<p><code>alter table 表名 add 列名 数据类型;</code></p>
</li>
<li><p>修改列的名称和类型</p>
<ul>
<li><code>alter table 表名 change 列名 新列名 新数据类型;</code></li>
<li><code>alter table 表名 modify 列名 新数据类型;</code></li>
</ul>
</li>
<li><p>删除列</p>
<p><code>alter table 表名 drop 列名;</code></p>
</li>
</ul>
</li>
<li><p>D(Delete) : 删除</p>
<ul>
<li><code>drop table 表名;</code></li>
<li><code>drop table if exists 表名;</code></li>
</ul>
</li>
</ul>
<h2 id="DML-增删改表中数据"><a href="#DML-增删改表中数据" class="headerlink" title="DML : 增删改表中数据"></a>DML : 增删改表中数据</h2><ol>
<li><p>添加数据</p>
<ul>
<li><p>语法 :</p>
<ul>
<li><code>insert into 表名(列名1, 列名2....列名n) vaules(值1, 值2...值n);</code></li>
</ul>
</li>
<li><p>注意事项 :</p>
<ul>
<li><p>列名和值要一一对应</p>
</li>
<li><p>如果表名后不定义列名, 默认给所有列复制</p>
<p><code>insert into 表名 vaules(值1, 值2...值n);</code></p>
</li>
<li><p>除了数字类型, 其他类型需要引号(单双都可以)引起来</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>删除数据</p>
<ul>
<li><p>语法</p>
<p>​    <code>delete from 表名 [where 条件];</code></p>
</li>
<li><p>注意:</p>
<ul>
<li>如果不加条件, 则会删除表中所有记录</li>
<li>删除所有记录的方式<ul>
<li><code>delete from 表名;;</code>  只删除数据不删除表的结构, 且可以回滚</li>
<li><code>truncate 表名;</code> :  只删除数据不删除表的结构, 不可以回滚</li>
<li><code>drop table 表名;</code>: 删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于 该表的存储过程/函数将保留,但是变为 invalid 状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改数据</p>
<ul>
<li><p>语法:</p>
<p><code>update 表名 set 列名1 = 值1, 列名2 = 值2,  ... [where 条件];</code></p>
</li>
<li><p>注意 :</p>
<p>如果不加条件会把所有记录都修改.</p>
</li>
</ul>
</li>
</ol>
<h2 id="DQL-查询表中数据"><a href="#DQL-查询表中数据" class="headerlink" title="DQL : 查询表中数据"></a>DQL : 查询表中数据</h2><ul>
<li><p>语法 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">	分组列表</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">	分组之后的条件</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">	排序</span><br><span class="line">limit</span><br><span class="line">	分页限定</span><br></pre></td></tr></table></figure></li>
<li><p>基础查询</p>
<ul>
<li><p>多个字段的查询</p>
<p><code>select 字段名1, 字段名2, .... from 表名;</code></p>
<p>注意 :  如果要查询所有字段可以用 * 来替代字段列表</p>
</li>
<li><p>去除重复</p>
<p><code>select distinct 字段名1, 字段名2, .... from 表名;</code></p>
</li>
<li><p>计算列</p>
<ul>
<li><p><code>select 字段名1, ifnull(字段名2, 0) + 字段名3, .... from 表名;</code></p>
</li>
<li><p>一般可以使用四则运算计算一些列的值.(一般只进行数值型的运算)</p>
</li>
<li><p><code>ifnull(表达式1, 表达式2);</code>如果表达式1为null, 将返回表达式2, 不然返回表达式</p>
</li>
</ul>
</li>
<li><p>起别名</p>
<p><code>select 字段名1 (as) 别名1, 字段名2 (as) 别名1, .... from 表名;</code>– <strong>as可省略</strong></p>
</li>
</ul>
</li>
<li><p>条件查询</p>
<ul>
<li><code>where 条件;</code></li>
<li>运算符<ul>
<li>‘&gt;’, &lt;, &lt;=. &lt;=, =, &lt;&gt;, !=</li>
<li>between…and…</li>
<li>in(集合)</li>
<li>like<ul>
<li>占位符 :<ul>
<li>_ : 单个任意字符</li>
<li>%: 任意多个字符</li>
</ul>
</li>
</ul>
</li>
<li>is null, is not null</li>
<li>ans / &amp;&amp;</li>
<li>or / ||</li>
<li>not / !</li>
</ul>
</li>
</ul>
</li>
<li><p>排序查询</p>
<ul>
<li><p>语法 : </p>
<p><code>order by 排序字段1 排序方式1, 排序字段2 排序方式2, .... </code></p>
</li>
<li><p>排序方式 : </p>
<ul>
<li>ASC : 升序(default)</li>
<li>DESC : 降序. </li>
</ul>
</li>
<li><p>注意 : </p>
<p>排序优先级有先后之分, 只有前面的一样时才会比较后面的</p>
</li>
</ul>
</li>
<li><p>聚合函数 : 将一列数据进行计算</p>
<ul>
<li><p>语法 : </p>
<p><code>select 函数名(列名) from 表名;</code></p>
</li>
<li><p>count : 计算个数</p>
<ul>
<li>一般选择非空的列 : 主键</li>
</ul>
</li>
<li><p>max : 计算最大值</p>
</li>
<li><p>min : 计算最小值</p>
</li>
<li><p>sum : 计算和</p>
</li>
<li><p>avg : 计算平均值</p>
</li>
<li><p>聚合函数默认排除null值</p>
<ul>
<li>解决方案 : <ol>
<li>选择非空的列</li>
<li>ifnull函数 </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分组查询 : </p>
<ul>
<li><p>语法 :</p>
<p><code>group by 分组字段;</code></p>
</li>
<li><p>注意 : </p>
<ol>
<li>分组之后查询字段 : 分组字段, 聚合函数1,  聚合函数2, …</li>
<li>where 与 having 的区别<ul>
<li>where 在分组之前进行限定, 如果不满足条件, 则不会参与分组</li>
<li>having 在分组之后进行限定, 如果不满足条件, 则不会被查询出来<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	sex, <span class="built_in">count</span>(id) num, <span class="built_in">avg</span>(math) </span><br><span class="line">	<span class="keyword">from</span> student </span><br><span class="line">	<span class="keyword">where</span> english <span class="operator">&gt;</span> <span class="number">70</span> </span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span> sex </span><br><span class="line">	<span class="keyword">having</span> num <span class="operator">&gt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>分页查询</p>
<ul>
<li><p>语法 : </p>
<p><code>limit 开始的索引, 每页显示的条数;</code></p>
</li>
<li><p>开始的索引 = (要查询的页码 - 1) * 每页显示的条数;</p>
</li>
<li><p>只在MySQL中可用</p>
</li>
</ul>
</li>
</ul>
<h2 id="DCL-管理用户-授权"><a href="#DCL-管理用户-授权" class="headerlink" title="DCL : 管理用户, 授权"></a>DCL : 管理用户, 授权</h2><ol>
<li><p>管理用户</p>
<ol>
<li><p>添加用户 : </p>
<ul>
<li>语法 :<code> CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></li>
</ul>
</li>
<li><p>删除用户 :</p>
<ul>
<li>语法 : <code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
<li><p>修改用户密码 :</p>
<ul>
<li><code>UPDATE USER SET PASSWORD = PASSWORD(新密码) WHERE USER = &#39;用户名&#39;;</code></li>
<li><code>SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD = PASSWORD(新密码);</code></li>
</ul>
</li>
<li><p>查询用户 :</p>
<ol>
<li><p>切换到mysql数据库</p>
</li>
<li><p>查询 user 表</p>
</li>
</ol>
<ul>
<li>通配符 : % 表示可以在任意主机上使用用户登录数据库</li>
</ul>
</li>
</ol>
</li>
<li><p>授权</p>
<ol>
<li><p>查询权限 :</p>
<p><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
<li><p>授予权限</p>
<p><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
<p>ALL 代表所有权限或所有库</p>
</li>
<li><p>撤销权限</p>
<p><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
</ol>
</li>
</ol>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul>
<li><p>概念 :  对表中数据进行限定, 保证数据的准确性, 有效性和完整性.</p>
</li>
<li><p>分类 : </p>
<ol>
<li><p>主键约束 : primary key</p>
<ul>
<li><p>注意 :</p>
<ol>
<li>含义 : 非空且唯一.</li>
<li>一张表只能有一个主键</li>
<li>主键就是表中记录的唯一标识</li>
</ol>
</li>
<li><p>创建时添加约束</p>
<p><code>列名1 数据类型 PRIMARY KEY</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 PRIMARY KEY;</code></p>
</li>
<li><p>删除约束</p>
<p><code>ALTER TABLE 表名 DROP PRIMARY KEY;</code></p>
</li>
<li><p>自动增长</p>
<ul>
<li><p>概念 : 如果一列是数据类型的, 使用 auto_increment可以完成值的自dongle增长(从上一行的值增加)</p>
</li>
<li><p>创建时添加自动增长</p>
<p><code>列名1 数据类型 AUTO_INCREMENT</code></p>
</li>
<li><p>创建后添加自动增长</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 AUTO_INCREMENT;</code></p>
</li>
<li><p>删除自动增长</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型;</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>非空约束 : not null</p>
<ul>
<li><p>创建时添加约束</p>
<p><code>列名1 数据类型 NOT NULL</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 NOT NULL;</code></p>
</li>
<li><p>删除约束</p>
<p>  <code>ALTER TABLE 表名 MODIFY 列名 新数据类型;</code></p>
</li>
</ul>
</li>
<li><p>唯一约束 : unique</p>
<ul>
<li><p>创建时添加约束</p>
<p><code>列名1 数据类型 UNIQUE</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 UNIQUE;</code></p>
</li>
<li><p>删除约束</p>
<p><code>ALTER TABLE 表名 DROP INDEX 列名;</code></p>
</li>
</ul>
</li>
<li><p>外键约束 : foreign key</p>
<ul>
<li><p>创建时添加约束</p>
<p><code>constraint 外键名称 foreign key (外键列名称) reference 主表名称(主表列名称)</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名称 ADD constraint 外键名称 foreign key (外键列名称) reference 主表名称(主表列名称);</code></p>
</li>
<li><p>删除约束</p>
<p><code>ALTER TABLE 表名称 DROP FOREIGN KEY 外键名称;</code></p>
</li>
<li><p>级联操作</p>
<ul>
<li>语法 : <code>constraint 外键名称 foreign key (外键列名称) reference 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE</code></li>
<li>分类 :<ol>
<li>级联更新 : ON UPDATE CASCADE</li>
<li>级联删除 : ON DELETE CASCADE`</li>
</ol>
</li>
<li>注意 : 要谨慎使用</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><ol>
<li><p>多表之间的关系</p>
<ol>
<li><p>分类</p>
<ol>
<li>一对一 : e.g : 人和身份证</li>
<li>一对多 (多对一) : e.g : 部门和员工</li>
<li>多对多 :  e.g : 学生和课程</li>
</ol>
</li>
<li><p>实现方式 :</p>
<ol>
<li><p>一对一 : </p>
<p>在任意一方添加<strong>唯一</strong>外键指向另一方的主键.</p>
</li>
<li><p>一对多(多对一) :</p>
<p>在多的一方建立外键指向一的一方.</p>
</li>
<li><p>多对多 :</p>
<p>借助第三张中间表, 中间表至少包含两个字段, 分别指向两张表的主键</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据库的设计范式 :</p>
<ul>
<li><p>概念 :设计关系<a class="link"   href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728" >数据库<i class="fas fa-external-link-alt"></i></a>时，遵从不同的规范<a class="link"   href="https://baike.baidu.com/item/%E8%A6%81%E6%B1%82/3598753" >要求<i class="fas fa-external-link-alt"></i></a>，设计出合理的<a class="link"   href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/8999831" >关系型数据库<i class="fas fa-external-link-alt"></i></a>，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>
<p><a class="link"   href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/1237340" >关系数据库<i class="fas fa-external-link-alt"></i></a>有六种范式：第一范式（1NF）、第二范式（2NF）、<a class="link"   href="https://baike.baidu.com/item/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F/3193798" >第三范式<i class="fas fa-external-link-alt"></i></a>（3NF）、巴斯-科德范式（BCNF）、<a class="link"   href="https://baike.baidu.com/item/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F/3193985" >第四范式<i class="fas fa-external-link-alt"></i></a>(4NF）和<a class="link"   href="https://baike.baidu.com/item/%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F/5025271" >第五范式<i class="fas fa-external-link-alt"></i></a>（5NF，又称完美范式）。</p>
</li>
<li><p>前置知识 :</p>
<ol>
<li>函数依赖 : A –&gt; B, 如果通过A属性(属性组)的值, 可以唯一确定唯一B属性的值, 则称B依赖于A</li>
<li>完全函数依赖 : A –&gt; B, 如果要唯一确定B属性的值, 要借助A属性组的<strong>所有值</strong>, 则称B依赖于A</li>
<li>部分函数依赖 : A –&gt; B, 如果要唯一确定B属性的值, <strong>只</strong>要借助A属性组的<strong>部分值</strong>, 则称B依赖于A</li>
<li>传递函数依赖 : A–&gt; B, B –&gt; C, 如果B依赖于A, C依赖于B, 则称C依赖于A.</li>
<li>码 : 如果在一张表中, 一个属性(属性组)被<strong>其他所有</strong>属性完全依赖, 则称这个属性(属性组)为该表的码</li>
</ol>
</li>
<li><p>分类 :</p>
<ol>
<li><p>第一范式 (1NF) : </p>
<p>数据库表的每一列都是不可分割的原子数据项</p>
</li>
<li><p>第二范式 (2NF) : </p>
<p>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上<strong>消除</strong>非主属性对主码的<strong>部分函数依赖</strong>.</p>
</li>
<li><p>第三范式 (3NF) : </p>
<p>在2NF基础上，任何非主<a class="link"   href="https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7" >属性<i class="fas fa-external-link-alt"></i></a>不依赖于其它非主属性（在2NF基础上<strong>消除传递依赖</strong>）</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="数据库的备份与还原"><a href="#数据库的备份与还原" class="headerlink" title="数据库的备份与还原"></a>数据库的备份与还原</h2><ol>
<li><p>命令行 :</p>
<ul>
<li>语法 :<ol>
<li>备份 : mysqldump -u用户名 -p密码 要备份的数据库名 &gt; 保存的路径</li>
<li>还原 :<ol>
<li>登录数据库</li>
<li>创建数据库</li>
<li>使用数据库</li>
<li>执行文件<code>source 文件路径;</code><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>查询语法 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	表名列表;</span><br></pre></td></tr></table></figure></li>
<li><p>笛卡尔积 : </p>
<p>笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尔积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员 </p>
</li>
<li><p>分类 :</p>
<ul>
<li><p>内连接查询</p>
<ol>
<li>隐式内连接 : 使用 where 条件 来清除无用的数据</li>
<li>显示内连接 : <ul>
<li>语法 : <code>select 字段列表 from 表名1 [inner] join 表名2 on 条件;</code></li>
<li>查询两表的交集部分</li>
</ul>
</li>
<li>明确要求 :<ol>
<li>要从那些表中查询数据</li>
<li>条件是什么</li>
<li>要查询哪些字段</li>
</ol>
</li>
</ol>
</li>
<li><p>外连接查询</p>
<ol>
<li>左外连接 : <ul>
<li>语法 : <code>select 字段列表 from 表名1 left [outer] join 表名2 on 条件;</code></li>
<li>查询的是左表的所有数据以及其交集部分</li>
</ul>
</li>
<li>右外连接<ul>
<li>语法 : <code>select 字段列表 from 表名1 right [outer] join 表名2 on 条件;</code></li>
<li>查询的是右表的所有数据以及其交集部分</li>
</ul>
</li>
</ol>
</li>
<li><p>子查询</p>
<ul>
<li><p>概念 : 在查询中嵌套查询, 则称嵌套查询为子查询.</p>
</li>
<li><p>子查询的不同种情况 :</p>
<ol>
<li><p>子查询的结果是单行单列的 :</p>
<p>子查询可以作为条件, 使用运算符(&gt;, &lt;, =…)进行判断</p>
</li>
<li><p>子查询的结果是单行多列的 :</p>
<p>子查询可以作为条件, 使用运算符 <em>in</em> 进行判断</p>
</li>
<li><p>子查询的结果是多行多列的 :</p>
<p>子查询可以作为一张虚拟表参与查询</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ol>
<li><p>事务的基本介绍</p>
<ol>
<li><p>概念 :</p>
<ul>
<li>如果一个包含多个步骤的业务操作, 被事务管理, 那么这些操作要么同时成功, 要么同时失败.</li>
</ul>
</li>
<li><p>操作 :</p>
<ol>
<li><p>开启事务 : <code>start transaction;</code></p>
</li>
<li><p>回滚 :<code>roll back;</code></p>
</li>
<li><p>提交 : <code>commit;</code></p>
</li>
<li><p>MySQL数据库中事务默认自动提交</p>
<ul>
<li>事务提交的两种方式<ol>
<li>自动提交 : 一条DML(增删改)语句会自动提交一次事务</li>
<li>手动提交 : 需要先开启事务再提交, Oracle数据库默认手动提交</li>
</ol>
</li>
<li>修改事务的默认提交方式 :<ul>
<li>查看事务的默认提交方式 : <code>SELECT @@autocommit;</code>– 0为手动, 1为自动</li>
<li>修改事务的默认提交方式 : <code>SET @@autocommit = 0;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>事务的四大特征 :</p>
<ol>
<li>原子性 : 是不可分割的最小操作单位, 要么同时成功, 要么同时失败</li>
<li>持久性 : 当事务提交或回滚后, 数据库会持久化的保留数据.</li>
<li>隔离性 : 多个事务之间相互独立</li>
<li>一致性 : 事务操作前后, 数据总量不变</li>
</ol>
</li>
<li><p>事务的隔离级别</p>
<ul>
<li><p>概念 : 如果多个事务同时操作同一批数据,, 则会引发一些问题, 需要设置不同的隔离级别来解决这些问题</p>
</li>
<li><p>存在问题种类 :</p>
<ol>
<li>脏读 : 一个事务读取到另一个事务没有提交的数据</li>
<li>不可重复读(虚读) : 在同一个事务中, 两次读取到的数据不一样 </li>
<li>幻读 : 一个事务操作(DML)数据表中所有数据, 另一个事务添加了一条数据, 则第一个事务查询不到自己的修改.</li>
</ol>
</li>
<li><p>隔离级别</p>
<ol>
<li>read uncommitted : 读未提交<ul>
<li>产生的问题 : 脏读, 虚读,幻读</li>
</ul>
</li>
<li>read commited : 读已提交(Oracle默认级别)<ul>
<li>产生的问题 : 虚读,幻读</li>
</ul>
</li>
<li>repeatable read : 可重复读(MySQL默认级别)<ul>
<li>产生的问题 :幻读</li>
</ul>
</li>
<li>serializable : 串行化<ul>
<li>可以解决所有问题</li>
</ul>
</li>
</ol>
<ul>
<li><p>注意 : 隔离级别安全性越高, 效率越低</p>
</li>
<li><p>数据库查询隔离级别</p>
<p><code>select @@tx_isolation;</code></p>
</li>
<li><p>数据库设置隔离级别</p>
<p><code>select global transaction isolation level 级别字符串;</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>JDBC学习</title>
    <url>/2021/11/01/JDBC%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ol>
<li><p>概念 : JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API<span id="more"></span>，可以为多种关系数据库提供统一访问，它由一组用<a class="link"   href="https://link.jianshu.com/?t=https://baike.baidu.com/item/Java%E8%AF%AD%E8%A8%80" >Java语言<i class="fas fa-external-link-alt"></i></a>编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。</p>
</li>
<li><p>快速入门:</p>
<ul>
<li><p>步骤 :</p>
<ol>
<li>导入驱动 jar 包</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql</li>
<li>获取执行 sql 语句的对象 Statement</li>
<li>执行sql, 接受返回结果</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
</li>
<li><p>代码实现 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		1. 导入驱动 jar 包</span></span><br><span class="line"><span class="comment">//		2. 注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//		3. 获取数据库连接对象 Connection</span></span><br><span class="line">		Connection condition = DriverManager.getConnection(</span><br><span class="line">				<span class="string">&quot;jdbc:mysql://localhost:3306/school&quot;</span>,</span><br><span class="line">				<span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//		4. 定义sql</span></span><br><span class="line">		String sql = <span class="string">&quot;update teacher set name = &#x27;chen&#x27; where id = 2&quot;</span>;</span><br><span class="line"><span class="comment">//		5. 获取执行 sql 语句的对象 Statement</span></span><br><span class="line">		Statement statement = condition.createStatement();</span><br><span class="line"><span class="comment">//		6. 执行sql, 接受返回结果</span></span><br><span class="line">		<span class="keyword">int</span> count = statement.executeUpdate(sql);</span><br><span class="line"><span class="comment">//		7. 处理结果</span></span><br><span class="line">		System.out.println(count);</span><br><span class="line"><span class="comment">//		8. 释放资源</span></span><br><span class="line">		statement.close();</span><br><span class="line">		condition.close();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>详解各个对象 :</p>
<ol>
<li><p>DriverManager : 驱动管理对象</p>
<ul>
<li><p>功能 :</p>
<ol>
<li><p>注册驱动</p>
<p><code>static void registerDriver(Driver driver)</code>// 注册驱动</p>
<p>写代码 : <code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code></p>
<p>源码 : 由静态代码块在加载类时执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        DriverManager.registerDriver(new Driver());</span><br><span class="line">    &#125; catch (SQLException var1) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>现在可省略</strong>(mysql5之后)</p>
</li>
<li><p>获取数据库连接</p>
<ul>
<li><p>方法 : <code>static Connection getConnection(String url, String user,  String password)</code></p>
</li>
<li><p>参数 :</p>
<ul>
<li><p>url : 指定连接路径</p>
<p>语法 : jdbc:mysql://ip地址或域名:端口号/数据库名</p>
<p>注意 : 如果连接的是本地的mysql服务器, 且端口默认为3306, 则可以省略两者    </p>
<pre><code>        jdbc:mysql:///数据库名
</code></pre>
</li>
<li><p>user : 用户名</p>
</li>
<li><p>password : 密码</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Connection : 数据库连接对象</p>
<ul>
<li>功能 :<ol>
<li>获取执行 sql 的对象<ul>
<li><code>Statement CreateStatement()</code></li>
<li><code>PrepareStatement prepareStatement(String sql)</code></li>
</ul>
</li>
<li>管理事务 :<ul>
<li>开启事务 : <code>void setAutoCommit(boolean autoCommit) </code>: 调用方法设置参数为false即开启事务</li>
<li>提交事务 : <code>void commit()</code></li>
<li>回滚事务 : <code>void rollback()</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Statement : 执行sql的对象</p>
<ul>
<li><p>执行sql :</p>
<ol>
<li><p><code>boolean execute(String sql)</code> : 可以执行任意的sql</p>
</li>
<li><p><code>int executeUpdate(String sql)</code> : 执行DML和DDL语句</p>
<p>返回值为改变的行数, 可以通过与 0 比较来判断语句执行是否成功</p>
</li>
<li><p><code>ResultSet executeQuery(String sql)</code> : 执行DQL语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Statement statement = <span class="keyword">null</span>;</span><br><span class="line">		Connection connection = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//			定义sql语句</span></span><br><span class="line">			String sql = <span class="string">&quot;insert into teacher values(5, &#x27;zou&#x27;, 21, 1000.50, &#x27;2001-03-05&#x27;)&quot;</span>;</span><br><span class="line"><span class="comment">//			获取Connection对象</span></span><br><span class="line">			connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///school&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//			获取sql语句的执行对象</span></span><br><span class="line">			statement = connection.createStatement();</span><br><span class="line"><span class="comment">//			执行sql</span></span><br><span class="line">			<span class="keyword">int</span> count = statement.executeUpdate(sql);</span><br><span class="line"><span class="comment">//			处理结果</span></span><br><span class="line">			System.out.println(count);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">			throwables.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//			关闭资源</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">					statement.close();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">					connection.close();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">				throwables.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>ResultSet : 结果集对象, 封装查询结果</p>
<p>方法 :</p>
<ul>
<li><p><code>boolean next()</code> : 游标向下移动一行</p>
</li>
<li><p><code>xxx getXxx(参数)</code> : 获取数据</p>
<ul>
<li><p>Xxx代表数据类型 如 : <code>int getInt()</code>, <code>String getString()</code></p>
</li>
<li><p>参数 : </p>
<ol>
<li>int : 传的是列的编号 (从 1 计数) 如 <code>getInt(1)</code></li>
<li>String : 传的是列的名称 如 <code>getInt(&quot;id&quot;)</code></li>
</ol>
</li>
<li><p>使用步骤 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    String name = resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> id = resultSet.getInt(<span class="string">&quot;id &quot;</span>);</span><br><span class="line">    System.out.println(id + <span class="string">&quot; &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>PreparedStatement : 执行sql的对象</p>
<ol>
<li>SQL注入问题 : 在拼接字符串时, 有一些sql的特殊关键字参与字符串的拼接, 会造成安全性问题</li>
<li>SQL注入问题 : 使用PreparedStatement对象解决</li>
<li>预编译的SQL : 使用 ? 来做占位符</li>
<li>步骤 :<ol>
<li>导入驱动</li>
<li>注册驱动</li>
<li>获取数据库连接对象</li>
<li>定义SQL<ul>
<li>注意 : sql 的参数要使用 ? 作为占位符. 如<code>select * from user = ? and password = ?;</code></li>
</ul>
</li>
<li>获取执行sql语句的对象 <code>PreparedStatement preparedStatement(String sql);</code> </li>
<li>给 ? 赋值 :<ul>
<li>方法: setXxx(参数1, 参数2 …)</li>
</ul>
</li>
<li>执行sql, 接受返回结果, 不需要传递sql语句</li>
<li>处理结果</li>
<li>关闭资源</li>
</ol>
</li>
<li>注意 :<ul>
<li><strong>要使用PreparedStatement而不是Statement</strong>原因:<ul>
<li>可以防止SQL注入</li>
<li>效率更高</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="抽取JDBC工具类"><a href="#抽取JDBC工具类" class="headerlink" title="抽取JDBC工具类"></a>抽取JDBC工具类</h2><ul>
<li><p>目的 : 简化书写</p>
</li>
<li><p>分析 :</p>
<ol>
<li><p>抽取注册驱动</p>
</li>
<li><p>抽取一个方法连接对象</p>
<ul>
<li><p>需求 : 不想传递参数</p>
</li>
<li><p>解决 : 使用配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/school</span><br><span class="line">user=root</span><br><span class="line">password=123456</span><br><span class="line">driver=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>抽取一个方法释放资源</p>
</li>
<li><p>代码实现 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">utils</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ClassLoader classLoader = utils.class.getClassLoader();</span><br><span class="line">			URL resource = classLoader.getResource(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">			String path = resource.getPath();</span><br><span class="line">			Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">			properties.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">			url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">			user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">			password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">			driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet resultSet, Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				resultSet.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(statement, connection);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				statement.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				connection.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h2><ol>
<li><p>事务 : 一个包含多个步骤的业务操作, 如果这个业务操作被事务管理, 那么这些操作要么同时成功, 要么同时失败.</p>
</li>
<li><p>操作 :</p>
<ol>
<li>开启事务</li>
<li>回滚 </li>
<li>提交</li>
</ol>
</li>
<li><p>使用Connection对象管理事务 :</p>
<ul>
<li><p>开启事务 : <code>void setAutoCommit(boolean autoCommit) </code>: 调用方法设置参数为false即开启事务</p>
<p>在执行sql之前开启事务</p>
</li>
<li><p>提交事务 : <code>void commit()</code></p>
<p>在所有sql都执行完后提交事务</p>
</li>
<li><p>回滚事务 : <code>void rollback()</code></p>
<p>在catch中回滚事务</p>
</li>
</ul>
</li>
</ol>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><ol>
<li><p>概念 : 存放数据库连接的容器.</p>
<p>当系统初始化好后, 容器被创建, 容器中会申请一些连接对象, 当用户来访问数据库时, 从容器中获取连接对象, 用户访问完之后, 会将连接对象归还给容器.</p>
</li>
<li><p>主流数据库连接池实现</p>
<ol>
<li>C3P0 : 数据连接池实现技术</li>
<li>Druid : 数据库连接池实现技术, 由阿里巴巴提供的</li>
</ol>
</li>
<li><p>实现 :</p>
<ul>
<li>标准接口 : java.sql.DataSource<ul>
<li>方法 :<ul>
<li>获取连接 : <code>getConnection()</code></li>
<li>归还连接: <code>Connection.close()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>C3P0 : 数据库连接池技术</p>
<ul>
<li><p>步骤 : </p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>定义配置文件 :</p>
<ul>
<li>名称 : c3p0.properties 或 c3p0-config.xml</li>
<li>路径 : 放在src目录下即可</li>
</ul>
</li>
<li><p>创建数据库连接池对象 ComboPooledDataSource;</p>
</li>
<li><p>获取连接 : getConnection </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.dataSource.c3p0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">//		1. 创建数据库连接池对象</span></span><br><span class="line">		DataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"><span class="comment">//		2. 获取连接对象</span></span><br><span class="line">		Connection connection = dataSource.getConnection();</span><br><span class="line"><span class="comment">//		3. 打印对象</span></span><br><span class="line">		System.out.println(connection);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>Druid : 数据库连接池实现技术, 由阿里巴巴提供</p>
<ul>
<li><p>步骤</p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>定义配置文件</p>
<ul>
<li>properties文件</li>
<li>名称位置任意</li>
</ul>
</li>
<li><p>加载配置文件</p>
</li>
<li><p>获取数据库连接池对象 : 通过对象工厂来获取 DruidDataSourceFactory</p>
</li>
<li><p>获取连接 : getConnection </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.dataSource.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		1. 导入jar包</span></span><br><span class="line"><span class="comment">//		2. 定义配置文件</span></span><br><span class="line"><span class="comment">//				- properties文件</span></span><br><span class="line"><span class="comment">//				- 名称位置任意</span></span><br><span class="line"><span class="comment">//		3. 加载配置文件</span></span><br><span class="line">		Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">		InputStream is = demo01.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">		properties.load(is);</span><br><span class="line"><span class="comment">//		4. 获取数据库连接池对象 : 通过对象工厂来获取 DruidDataSourceFactory</span></span><br><span class="line">		DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">		Connection connection = dataSource.getConnection();</span><br><span class="line">		System.out.println(connection);</span><br><span class="line"><span class="comment">//		4. 获取连接 : getConnection</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>定义工具类</p>
<ol>
<li>定义一个类 JDBCUtils</li>
<li>提供静态代码块加载配置文件, 初始化连接池对象</li>
<li>提供方法 :<ol>
<li>获取连接</li>
<li>释放资源</li>
<li>获取连接池</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.dataSource.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Druid的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">			InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">			properties.load(is);</span><br><span class="line">			dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet resultSet, Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				resultSet.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(statement, connection);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				statement.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				connection.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><ul>
<li><p>Spring框架对JDBC的简单封装. 依赖于数据源DataSource</p>
</li>
<li><p>步骤 :</p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>创建JDBCTemplate对象, 依赖于数据源DataSource</p>
<p><code>JdbcTemplate template = new JdbcTemplate(dataSource);</code></p>
</li>
<li><p>调用JdbcTemplate对象的方法来完成CRUD的操作</p>
<ul>
<li><p>update() : 执行DML语句</p>
</li>
<li><p>queryForMap() : 查询后将结果封装为map集合, </p>
<ul>
<li><p>将列名作为key, 将值作为value, 将这条记录封装为一个Map集合</p>
</li>
<li><p>注意 : 这个方法查询的结果集长度只能为1;</p>
</li>
</ul>
</li>
<li><p>queryForList() : 查询后将结果封装为list集合</p>
<ul>
<li>将每条记录封装为一条Map集合, 再装载到List集合中</li>
</ul>
</li>
<li><p>query() : 查询后将结果封装为JavaBean对象</p>
<ul>
<li>RowMapper参数<ul>
<li>一般使用BeanPropertyRowMapper实现类. 可以完成数据到JavaBean的自动封装</li>
<li><code>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>queryForObject() : 查询后将结果封装为对象</p>
<ul>
<li><p>参数中要传返回值的类对象 eg: Long.class</p>
</li>
<li><p>一般用于聚合函数的查询</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chenysh.dataSource.utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JdbcTemplate入门学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		1. 导入jar包</span></span><br><span class="line"><span class="comment">//		2. 创建JDBCTemplate对象, 依赖于数据源DataSource</span></span><br><span class="line">		JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line"><span class="comment">//		3. 调用JdbcTemplate对象的方法来完成CRUD的操作</span></span><br><span class="line">		String sql = <span class="string">&quot;update teacher set age = 20 where id = ?&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> count = template.update(sql, <span class="number">2</span>);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02</span> </span>&#123;</span><br><span class="line">	JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;update emp set bonus = 10000.0 where id = ?&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> count = jdbcTemplate.update(sql, <span class="number">1001</span>);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;insert into emp(id, ename, dept_id) values(?, ?, ?)&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> count = jdbcTemplate.update(sql, <span class="number">1015</span>, <span class="string">&quot;chenysh&quot;</span>, <span class="number">10</span>);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;delete from emp where id = ?&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> count = jdbcTemplate.update(sql, <span class="number">1015</span>);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select * from emp where id = ?&quot;</span>;</span><br><span class="line">		Map&lt;String, Object&gt; result = jdbcTemplate.queryForMap(sql, <span class="number">100</span>);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select * from emp&quot;</span>;</span><br><span class="line">		List&lt;Map&lt;String, Object&gt;&gt; result = jdbcTemplate.queryForList(sql);</span><br><span class="line">		<span class="keyword">for</span> (Map&lt;String, Object&gt; e : result) &#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select * from emp&quot;</span>;</span><br><span class="line">		List&lt;Emp&gt; result = jdbcTemplate.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));</span><br><span class="line">		<span class="keyword">for</span> (Emp e : result) &#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select Count(id) from emp&quot;</span>;</span><br><span class="line">		Long result = jdbcTemplate.queryForObject(sql, Long.class);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>xml学习</title>
    <url>/2021/11/03/xml%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><ol>
<li><p>概念 : Extensible Markup Language 可扩展标记语言<span id="more"></span></p>
<ul>
<li><p>可拓展 : 标签都可以自定义</p>
</li>
<li><p>功能 :</p>
<ul>
<li><p>存储数据</p>
<ul>
<li><p>配置文件</p>
</li>
<li><p>在网路中传输</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>xml与html的区别</p>
<ul>
<li>xml标签都是自定义的, html标签都是预定义的.</li>
<li>xml语法严格, html语法松散</li>
<li>xml用来存储数据, html用来展示数据</li>
</ul>
</li>
</ul>
</li>
<li><p>语法 :</p>
<ul>
<li><p>基本语法 :</p>
<ol>
<li>xml的后缀名为.xml</li>
<li>xml第一行必须为文档声明</li>
<li>xml有且只有一个根标签</li>
<li>属性值必须由引号(单双都行)引起来</li>
<li>标签必须正确关闭</li>
<li>xml标签名称区分大小写</li>
</ol>
</li>
<li><p>快速入门 :</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span> = <span class="string">&#x27;1&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>chenysh<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span> = <span class="string">&#x27;2&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>lisi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>19<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>female<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>组成部分 :</p>
<ol>
<li>文档声明 :<ol>
<li>格式: <? xml 属性列表 ?></li>
<li>属性列表 :<ol>
<li>version : 版本号(必须的属性)</li>
<li>encoding : 编码方式 告知解析引擎当前文档使用的字符集.默认值ISO*-8859-1</li>
<li>standalong : 是否独立</li>
</ol>
</li>
</ol>
</li>
<li>指令(不需要了解)</li>
<li>标签 : 标签名称自定义</li>
</ol>
<ul>
<li>规则<ul>
<li>名称可以包含字母数字以及其他字符</li>
<li>名称不能以标点符号开始</li>
<li>名称不能以xml(大小写都不行)开始</li>
<li>名称中不能有空格</li>
</ul>
</li>
</ul>
<ol start="4">
<li>属性 :<ul>
<li>id属性唯一</li>
</ul>
</li>
<li>文本</li>
</ol>
<ul>
<li>CDATA区 : 在该区域中的数据会被原样展示</li>
<li>格式<![CDATA[ 数据 ]]></li>
</ul>
</li>
<li><p>约束</p>
<ul>
<li>规定框架的使用者(程序员) :<ol>
<li>能够在xml中引入约束文档</li>
<li>能够简单的读懂约束文档</li>
</ol>
</li>
<li>分类 :<ol>
<li>DTD : 一种简单的约束技术</li>
<li>Schema : 一种复杂的约束技术</li>
</ol>
</li>
<li>DTD :<ul>
<li>引入dtd文档到xml文档中<ul>
<li>内部DTD : 将约束规则定义在xml文档中(不常用)</li>
<li>外部DTD : 将约束规则定义在外部的DTD文件中<ul>
<li>本地 : <!DOCTYPE 根标签名 SYSYEM "DTD文件的位置"></li>
<li>网络 : <!DOCTYPE 根标签名 PUBLIC "DTD文件名"  "DTD文件的位置URL"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Schema : <ul>
<li>引入 :<ul>
<li>填写xml文档的根元素</li>
<li>引入xsi前缀 , xmlns:xsi=”<a class="link"   href="http://www.w3.org/2001/XMLSchema-instance&quot;" >http://www.w3.org/2001/XMLSchema-instance&quot;<i class="fas fa-external-link-alt"></i></a></li>
<li>引入命名空间和xsd文件. xsi:schemaLocation=”<a class="link"   href="http://www.itcast.cn/xml(%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4)" >http://www.itcast.cn/xml(命名空间)<i class="fas fa-external-link-alt"></i></a> student.xsd(xsd文件)”</li>
<li>为每一个xsd约束声明一个前缀, 作为标识 xmlns:前缀名(如果省略则无前缀) = “<a class="link"   href="http://www.itcast.cn/xml&quot;" >http://www.itcast.cn/xml&quot;<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="解析xml-操作xml文档-将文档中数据读取到内存中"><a href="#解析xml-操作xml文档-将文档中数据读取到内存中" class="headerlink" title="解析xml :操作xml文档, 将文档中数据读取到内存中"></a>解析xml :操作xml文档, 将文档中数据读取到内存中</h2><ul>
<li><p>操作xml文档</p>
<ol>
<li>解析(读取) : 将文档中的数据读取到内存中</li>
<li>写入 : 将内存中的数据保存到xml文件中, 持久化的存储(不常用)</li>
</ol>
</li>
<li><p>解析xml的方式</p>
<ol>
<li>DOM 将标记语言文档一次性加载进内存, 在内存中形成一颗DOM树<ul>
<li>优点 : 操作方便, 可以对文档进行CRUD的全部操作</li>
<li>缺点 : 占内存</li>
</ul>
</li>
<li>SAX 逐行读取, 基于事件驱动<ul>
<li>优点 : 不占内存</li>
<li>缺点 : 只能读取, 不能修改</li>
</ul>
</li>
</ol>
</li>
<li><p>xml常见的解析器</p>
<ol>
<li>JAXP : sun公司提供的解析器, 支持dom和sax(性能不行)</li>
<li>DOM4J : 一款非常优秀的解析器</li>
<li>Jsoup : 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</li>
<li>PULL:Android操作系统内置的解析器, 支持sax方式</li>
</ol>
</li>
<li><p>jsoup</p>
<ul>
<li>快速入门 :<ul>
<li>步骤 :<ol>
<li>导入jar包</li>
<li>获取Document对象</li>
<li>获取对应的标签Elemen对象</li>
<li>获取数据</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		1. 导入jar包</span></span><br><span class="line"><span class="comment">//		2. 获取Document对象</span></span><br><span class="line">		String path = demo01.class.getClassLoader().getResource(<span class="string">&quot;student.xml&quot;</span>).getPath();</span><br><span class="line">		Document document = Jsoup.parse(<span class="keyword">new</span> File(path), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//		3. 获取对应的标签Elemen对象</span></span><br><span class="line">		Elements elements = document.getElementsByTag(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		System.out.println(elements.size());</span><br><span class="line">		Element element = elements.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//		4. 获取数据</span></span><br><span class="line">		String name = element.text();</span><br><span class="line">		System.out.println(name);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象的使用</p>
<ol>
<li><p>Jsoup : 工具类, 可以解析html或xml文档, 返回Document对象</p>
<ul>
<li>parse方法 : 解析html或xml文档, 返回Document对象<ul>
<li>parse(File in, String charsetName) : 解析xml或html文件</li>
<li>parse(String html) : 解析xml或html字符串(不常用)</li>
<li>parse(URL url, int timeoutMillis) : 通过url来获取xml或html文件并解析</li>
</ul>
</li>
</ul>
</li>
<li><p>Document : 文档对象. 代表内存中DOM树</p>
<ul>
<li><p>获取Element对象</p>
<ul>
<li><p>getElementById(String id) : 根据id获取element对象</p>
</li>
<li><p>getElementsByTag(String tagName) : 根据标签名获取Element集合</p>
</li>
<li><p>getElementsByAttribute(String key) : 根据标签名获取Element集合</p>
</li>
<li><p>getElementsByAttributeValue(String key) : 根据属性名对应的属性值来获取Element集合</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Elements : 元素Element对象的集合, 可以当作ArrayList来使用</p>
</li>
<li><p>Element : 元素对象</p>
<ol>
<li><p>获取子元素对象</p>
<ul>
<li><p>getElementById(String id) : 根据id获取element对象</p>
</li>
<li><p>getElementsByTag(String tagName) : 根据标签名获取Element集合</p>
</li>
<li><p>getElementsByAttribute(String key) : 根据标签名获取Element集合</p>
</li>
<li><p>getElementsByAttributeValue(String key) : 根据属性名对应的属性值来获取Element集合</p>
</li>
</ul>
</li>
<li><p>获取属性值</p>
<ul>
<li>String attr(String key) : 根据属性名称获取属性值</li>
</ul>
</li>
<li><p>获取文本内容</p>
<ul>
<li>String text() : 获取所有子标签的文本内容</li>
<li>String html() : 获取标签体内的所有内容, 包括字标签</li>
</ul>
</li>
</ol>
</li>
<li><p>Node : 节点对象</p>
<ul>
<li>是Document和Element父类</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="快捷查询方式"><a href="#快捷查询方式" class="headerlink" title="快捷查询方式"></a>快捷查询方式</h2><ol>
<li>selector : 选择器<ul>
<li>使用的方法 : Elements select(String cssQuery)</li>
<li>语法参考Selector类中定义的语法</li>
</ul>
</li>
<li>Xpath : <strong>XPath</strong>即为<a class="link"   href="https://zh.wikipedia.org/wiki/XML" >XML<i class="fas fa-external-link-alt"></i></a>路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的<a class="link"   href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80" >计算机语言<i class="fas fa-external-link-alt"></i></a>。<ul>
<li>使用Jsoup的Xpath需要额外导入jar包</li>
<li>查询w3cschool参考手册来了解Xpath的语法进行查询</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Xpath学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo06</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, XpathSyntaxErrorException </span>&#123;</span><br><span class="line">		String path = demo01.class.getClassLoader().getResource(<span class="string">&quot;student.xml&quot;</span>).getPath();</span><br><span class="line">		Document document = Jsoup.parse(<span class="keyword">new</span> File(path), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">		JXDocument jxDocument = <span class="keyword">new</span> JXDocument(document);</span><br><span class="line">		List&lt;JXNode&gt; list = jxDocument.selN(<span class="string">&quot;//student&quot;</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		list = jxDocument.selN(<span class="string">&quot;//student/name&quot;</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		list = jxDocument.selN(<span class="string">&quot;//student/name[@size]&quot;</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		list = jxDocument.selN(<span class="string">&quot;//student/name[@size = &#x27;3&#x27;]&quot;</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>tomcat和servlet学习</title>
    <url>/2021/11/04/tomcat%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="web相关知识"><a href="#web相关知识" class="headerlink" title="web相关知识"></a>web相关知识</h1><ol>
<li>软件架构 :<ol>
<li>C/S : 客户端/服务器端</li>
<li>B/S : 浏览器/服务器端</li>
</ol>
</li>
<li>资源分类<ol>
<li>静态资源 : 所有用户访问后, 得到的结果都是一样的, 称为静态资源, 静态资源可以直接被浏览器解析<ul>
<li>如:html, css, JavaScript</li>
</ul>
</li>
<li>动态资源 : 每个用户访问后, 得到的结果可能不一样, 称为动态资源, 动态资源被访问后, 需要先转换为静态资源, 再返回给浏览器<ul>
<li>如: servlet/jsp, php, asp….</li>
</ul>
</li>
</ol>
</li>
<li>网络通信三要素<ol>
<li>IP : 电子设备(计算机)在网络中的唯一标识</li>
<li>端口 : 应用程序在计算机中的唯一标识 0~65535</li>
<li>传输协议 : 规定了数据传输的规则<ol>
<li>基础协议:<ol>
<li>tcp : 安全协议, 三次握手, 四次挥手. 速度较慢</li>
<li>udp : 不安全协议. 速度快</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="服务器软件介绍"><a href="#服务器软件介绍" class="headerlink" title="服务器软件介绍"></a>服务器软件介绍</h1><ul>
<li><p>服务器 : 安装了服务器软件的计算机</p>
</li>
<li><p>服务器软件 : 接受用户的请求, 处理请求, 做出响应</p>
</li>
<li><p>Web服务器软件 : 接受用户的请求, 处理请求, 做出响应</p>
<ul>
<li>在Web服务器软件中, 可以部署web项目, 让用户通过浏览器来访问这些项目</li>
<li>本质是一个web容器</li>
</ul>
</li>
<li><p>常见的java相关的web服务器软件</p>
<ul>
<li>webLogic : oracle公司, 大型的JavaEE服务器, 支持所有的JavaEE规范, 收费</li>
<li>webSphere : IBM公司, 大型的JavaEE服务器, 支持所有的JavaEE规范, 收费</li>
<li>JBoss : JBoss公司, 大型的JavaEE服务器, 支持所有的JavaEE规范, 收费</li>
<li>Tomcat : Apache基金组织, 中小型的JavaEE服务器, 支持少量的JavaEE规范servlet/jsp, 开源免费</li>
</ul>
</li>
<li><p>JavaEE : Java语言在企业级开发中使用的技术规范的总和, 一共规定了13项大的规范</p>
</li>
</ul>
<h1 id="Tomcat-web服务器软件"><a href="#Tomcat-web服务器软件" class="headerlink" title="Tomcat : web服务器软件"></a>Tomcat : web服务器软件</h1><ol>
<li><p>下载 : <a class="link"   href="https://dlcdn.apache.org/tomcat/tomcat-8/v8.5.72/bin/apache-tomcat-8.5.72-windows-x64.zip" >https://dlcdn.apache.org/tomcat/tomcat-8/v8.5.72/bin/apache-tomcat-8.5.72-windows-x64.zip<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>安装: 目录别有中文</p>
</li>
<li><p>目录结构 :<img src="https://raw.githubusercontent.com/ischenysh/images/master/tomcat%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.27swev6009s0.png" alt="tomcat目录结构"></p>
</li>
<li><p>卸载 : …</p>
</li>
<li><p>启动 : </p>
<ul>
<li>bin/startup.bat</li>
<li>访问 : <a class="link"   href="http://ip地址:8080/" >http://IP地址:8080<i class="fas fa-external-link-alt"></i></a> </li>
<li>一般将tomcat的默认端口号修改为80, 80端口号是http协议的默认端口号<ul>
<li>好处 : 在访问时, 可省略端口号</li>
</ul>
</li>
</ul>
</li>
<li><p>关闭</p>
<ol>
<li>正常关闭<ul>
<li>bin/shutdown.bat</li>
<li>ctrl + c</li>
</ul>
</li>
<li>强制关闭<ul>
<li>直接关</li>
</ul>
</li>
</ol>
</li>
<li><p>配置</p>
<ul>
<li><p>部署项目的方式 :</p>
<ol>
<li><p>直接将项目放在webapps目录下即可</p>
<ul>
<li>/hello : 项目的访问路径    即虚拟目录</li>
<li>简化部署 : 将项目打成war包放入webapps目录下即可</li>
</ul>
</li>
<li><p>配置conf/server.xml文件</p>
<p>在<code>&lt;Host&gt;</code>标签体中配置</p>
<ul>
<li><code>&lt;Context docBase=&quot;项目存放的路径&quot; path=&quot;虚拟目录&quot; /&gt;</code></li>
</ul>
</li>
<li><p>在conf/Catalina\localhost创建xml文件(常用)</p>
<ul>
<li>在文件中写入<code>&lt;Context docBase=&quot;项目存放的路径&quot; /&gt;</code></li>
<li>虚拟目录就是xml文件的名称</li>
</ul>
</li>
</ol>
</li>
<li><p>静态项目和动态项目</p>
<ul>
<li>java动态项目的目录结构<ul>
<li>/项目根目录/WEB-INF目录/下有<ol>
<li>web.xml: web项目的核心配置文件</li>
<li>classes目录 : 放置字节码文件的目录</li>
<li>lib目录 : 放置依赖的jar包</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>将Tomcat集成到IDEA中, 并且创建JavaEE的项目, 部署项目.</p>
</li>
</ul>
</li>
</ol>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><ul>
<li><p>概念 : 运行在服务器端的小程序</p>
<ul>
<li>servlet是一个接口, 定义了Java类被浏览器访问到(tomcat识别)的规则</li>
</ul>
</li>
<li><p>快速入门 :</p>
<ol>
<li><p>创建JavaEE项目</p>
</li>
<li><p>定义一个类, 实现servlet接口</p>
</li>
<li><p>实现接口中抽象方法</p>
</li>
<li><p>配置Servlet</p>
<p>在web.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>任意取名<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>要调用的类的全类名<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>与上文名字相同<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/映射路径<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>执行原理 : </p>
<ol>
<li>当服务器接收到客户端浏览器的请求后, 会解析请求URL路径, 获取访问的Servlet的资源路径</li>
<li>查找web.xml文件, 是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容</li>
<li>如果有, 则会找对应的<code>&lt;servlet-class&gt;</code>全类名</li>
<li>tomcat将字节码文件加载进内存, 并且创建其对象</li>
<li>调用方法</li>
</ol>
</li>
<li><p>Servlet中的生命周期方法</p>
<ol>
<li>被创建 : 执行init方法, 只执行一次<ul>
<li>默认情况下Servlet对象会在第一次访问时被创建</li>
<li>可以配置Servlet对象被创建的时间<ul>
<li>在<code>&lt;servlet&gt;</code>标签下配置<ol>
<li>希望第一次访问时创建<ul>
<li>将<code>&lt;load-on-startup&gt;</code>的值设为负数</li>
</ul>
</li>
<li>希望在服务器启动时创建<ul>
<li>将<code>&lt;load-on-startup&gt;</code>的值设为负数</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>提供服务 : 执行service方法. 可以执行多次<ul>
<li>每调用一次Servlet, service方法就会被执行一次</li>
</ul>
</li>
<li>被销毁 : 执行destroy方法, 只执行一次<ul>
<li>Servlet对象被销毁时执行</li>
<li>只有服务器正常关闭时, 才会执行destroy方法</li>
<li>destroy方法在Servlet对象被销毁前执行, 一般用于释放资源</li>
</ul>
</li>
</ol>
</li>
<li><p>Servlet3.0</p>
<ul>
<li>好处<ol>
<li>支持注解配置, 可以不需要web.xml</li>
</ol>
</li>
<li>步骤<ol>
<li>创建JavaEE项目, 选择Servlet的版本在3.0以上</li>
<li>创建一个类实现Servlet方法</li>
<li>重写方法</li>
<li>在类上使用@WebServlet注解, 进行自动配置<ul>
<li><strong>@WebServlet(“资源路径”)</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>IDEA和tomcat的相关配置</p>
<ol>
<li><p>IDEA会为每一个tomcat部署的项目建立一份配置文件</p>
<ul>
<li>查看控制台的log : <code>Using CATALINA_BASE</code>: </li>
</ul>
</li>
<li><p>工作空间项目   和   tomcat部署的web项目</p>
<ul>
<li>tomcat访问的是 “tomcat部署的web项目”, 在webapp的目录下</li>
<li>WEB-INF目录下的资源不能被浏览器直接访问</li>
</ul>
</li>
</ol>
</li>
<li><p>Servlet项目结构</p>
<pre><code>Servlet                               ---接口
   |
</code></pre>
<p>  GenericServlet                 ———抽象类</p>
<pre><code>   |
</code></pre>
<p>  HttpServlet                          —-抽象类</p>
<ul>
<li><p>GenericServlet  : 将Servlet接口中的其他方法都做了默认的空实现, 只将service方法作为抽象,将来定义Servlet类时, 可以继承它, 只实现service方法即可</p>
</li>
<li><p>HttpServlet  : 对http协议的一种封装, 简化操作</p>
<ul>
<li>使用步骤<ol>
<li>定义类继承HttpServlet</li>
<li>重写doGet/doPost方法</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Servlet相关配置</p>
<ol>
<li>urlpartten : Service访问路径<ol>
<li>一个Servlet可以定义多个路径 : @webServlet({“/a”, “/b”})</li>
<li>路径定义规则(“ * “可作为通配符)<ol>
<li>/xxx : 路径</li>
<li>/xxx/yyy : 多层路径, 目录路径</li>
<li>*.do<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>概念 : Hyper Text Transfer Protocol 超文本传输协议</p>
<ul>
<li>传输协议 : 定义了客户端和服务器端发送通信时, 发送数据的格式</li>
<li>特点 : <ol>
<li>基于TCP/IP的高级协议</li>
<li>默认的端口号 : 80</li>
<li>基于请求/响应模型 : 一次请求对应一次响应</li>
<li>无状态的 : 每次请求之间相互独立, 不能交互数据</li>
</ol>
</li>
<li>历史版本<ul>
<li>1.0 : 每次请求都会建立新的连接</li>
<li>1.1 : 能复用连接</li>
</ul>
</li>
</ul>
</li>
<li><p>请求消息数据格式</p>
<ol>
<li><p>请求行</p>
<p>请求方式 请求url 请求协议/版本号</p>
<p>POST /login.html HTTP/1.1</p>
<ul>
<li>请求方式 : <ul>
<li>HTTP协议中有其中请求方式, 常用的有两种<ol>
<li>GET : <ul>
<li>请求参数在请求行中,在url后</li>
<li>请求的url有长度限制</li>
<li>不太安全</li>
</ul>
</li>
<li>POST<ul>
<li>请求参数在请求体中</li>
<li>请求的url长度没有限制</li>
<li>相对安全</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求头 : 客户端浏览器告诉服务器一些信息</p>
<p>请求头名称 : 请求头值</p>
<ul>
<li>常见的请求头 : <ol>
<li>User-Agent : 浏览器告知服务器, 用户使用的浏览器版本信息<ul>
<li>可以在服务器端获取该头信息, 解决浏览器的兼容问题</li>
</ul>
</li>
<li>referer : <a class="link"   href="http://localhost/Tomcat/login.html" >http://localhost/Tomcat/login.html<i class="fas fa-external-link-alt"></i></a><ul>
<li>告诉服务器, 当前请求的来源<ul>
<li>作用:<ol>
<li>防盗链</li>
<li>统计工作</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>请求空行</p>
<ul>
<li>分隔请求头和请求体</li>
</ul>
</li>
<li><p>请求体(正文)</p>
<ul>
<li>封装POST请求消息的请求体的</li>
</ul>
</li>
<li><p>字符串格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /login.html HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36</span><br><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: JSESSIONID=77DF4662FE754A439CD0FB56C1BCAFF9; Idea-f4d8557b=20551331-9bc8-4e86-ab3d-0f04c9c2045d; Idea-f4d8557c=10d75bc0-2de0-4ee0-852c-d072dc3c44ca; Webstorm-4e75f43=061788ec-d849-4ad7-acc2-d8b44fefe312</span><br><span class="line"></span><br><span class="line">username = zhangsan</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>响应消息：服务器端发送给客户端的数据</p>
<ul>
<li>数据格式：<ol>
<li>响应行<ol>
<li>组成：协议/版本 响应状态码 状态码描述</li>
<li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。<ol>
<li>状态码都是3位数字 </li>
<li>分类：<ol>
<li>1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</li>
<li>2xx：成功。代表：200</li>
<li>3xx：重定向。代表：302(重定向)，304(访问缓存)</li>
<li>4xx：客户端错误。<ul>
<li>代表：<ul>
<li>404（请求路径没有对应的资源） </li>
<li>405：请求方式没有对应的doXxx方法</li>
</ul>
</li>
</ul>
</li>
<li>5xx：服务器端错误。代表：500(服务器内部出现异常)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>响应头：<ol>
<li>格式：头名称： 值</li>
<li>常见的响应头：<ol>
<li>Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式</li>
<li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据<ul>
<li>值：<ul>
<li>in-line:默认值,在当前页面内打开</li>
<li>attachment;filename=xxx：以附件形式打开响应体。文件下载</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>响应空行</li>
<li>响应体:传输的数据</li>
</ol>
</li>
<li>响应字符串格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Content-Length: 101</span><br><span class="line">Date: Wed, 06 Jun 2018 07:08:42 GMT</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  hello , response</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2></li>
</ul>
</li>
</ul>
<ol>
<li><p>request对象和response对象的原理</p>
<ol>
<li>request和response对象是由服务器创建的。我们来使用它们</li>
<li>request对象是来获取请求消息，response对象是来设置响应消息</li>
</ol>
</li>
<li><p>request对象继承体系结构：<br> ServletRequest        –    接口</p>
<pre><code> |    继承
</code></pre>
<p> HttpServletRequest    – 接口</p>
<pre><code> |    实现
</code></pre>
<p> org.apache.catalina.connector.RequestFacade 类(tomcat)</p>
</li>
<li><p>request功能：</p>
<ol>
<li><p>获取请求消息数据</p>
<ol>
<li><p>获取请求行数据</p>
<ul>
<li><p>GET /day14/demo1?name=zhangsan HTTP/1.1</p>
</li>
<li><p>方法：</p>
<ol>
<li><p>获取请求方式 ：GET</p>
<ul>
<li>String getMethod()  </li>
</ul>
</li>
<li><p><strong>获取虚拟目录</strong>：/day14</p>
<ul>
<li>String getContextPath()</li>
</ul>
</li>
<li><p>获取Servlet路径: /demo1</p>
<ul>
<li>String getServletPath()</li>
</ul>
</li>
<li><p>获取get方式请求参数：name=zhangsan</p>
<ul>
<li>String getQueryString()</li>
</ul>
</li>
<li><p><strong>获取请求URI</strong>：/day14/demo1</p>
<ul>
<li><p>String getRequestURI():        /day14/demo1</p>
</li>
<li><p>StringBuffer getRequestURL()  :<a class="link"   href="http://localhost/day14/demo1" >http://localhost/day14/demo1<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>URL:统一资源定位符 ： <a class="link"   href="http://localhost/day14/demo1" >http://localhost/day14/demo1<i class="fas fa-external-link-alt"></i></a>    中华人民共和国</p>
</li>
<li><p>URI：统一资源标识符 : /day14/demo1                    共和国</p>
</li>
</ul>
</li>
<li><p>获取协议及版本：HTTP/1.1</p>
<ul>
<li>String getProtocol()</li>
</ul>
</li>
<li><p>获取客户机的IP地址：</p>
<ul>
<li>String getRemoteAddr()</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>获取请求头数据</p>
<ul>
<li>方法：<ul>
<li><strong>String getHeader(String name)</strong>:通过请求头的名称获取请求头的值</li>
<li><code>Enumeration&lt;String&gt; getHeaderNames()</code>:获取所有的请求头名称</li>
</ul>
</li>
</ul>
</li>
<li><p>获取请求体数据:</p>
<ul>
<li><p>请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</p>
</li>
<li><p>步骤：</p>
<ol>
<li><p>获取流对象</p>
<ul>
<li> BufferedReader getReader()：获取字符输入流，只能操作字符数据</li>
<li>ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据<ul>
<li>在文件上传知识点后讲解</li>
</ul>
</li>
</ul>
</li>
<li><p>再从流对象中拿数据</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>其他功能：</p>
<ol>
<li><p>获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数</p>
<ol>
<li>String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123</li>
<li>String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game</li>
<li><code>Enumeration&lt;String&gt; getParameterNames()</code>:获取所有请求的参数名称</li>
<li><code>Map&lt;String,String[]&gt; getParameterMap()</code>:获取所有参数的map集合</li>
</ol>
<ul>
<li>中文乱码问题：<ul>
<li>get方式：tomcat 8 已经将get方式乱码问题解决了</li>
<li>post方式：会乱码<ul>
<li>解决：在获取参数前，设置request的编码<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求转发：一种在服务器内部的资源跳转方式</p>
<ol>
<li><p>步骤：</p>
<ol>
<li>通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)</li>
<li>使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) </li>
</ol>
</li>
<li><p>特点：</p>
<ol>
<li>浏览器地址栏路径不发生变化</li>
<li>只能转发到当前服务器内部资源中。</li>
<li>转发是一次请求</li>
</ol>
</li>
</ol>
</li>
<li><p>共享数据：</p>
<ul>
<li>域对象：一个有作用范围的对象，可以在范围内共享数据</li>
<li>request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</li>
<li>方法：<ol>
<li>void setAttribute(String name,Object obj):存储数据</li>
<li>Object getAttitude(String name):通过键获取值</li>
<li>void removeAttribute(String name):通过键移除键值对</li>
</ol>
</li>
</ul>
</li>
<li><p>获取ServletContext：</p>
<ul>
<li>ServletContext getServletContext()</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="BeanUtils工具类，简化数据封装"><a href="#BeanUtils工具类，简化数据封装" class="headerlink" title="BeanUtils工具类，简化数据封装"></a>BeanUtils工具类，简化数据封装</h2><ul>
<li>用于封装JavaBean的</li>
</ul>
<ol>
<li>JavaBean：标准的Java类<ol>
<li>要求：<ol>
<li>类必须被public修饰</li>
<li>必须提供空参的构造器</li>
<li>成员变量必须使用private修饰</li>
<li>提供公共setter和getter方法</li>
</ol>
</li>
<li>功能：封装数据</li>
</ol>
</li>
<li>概念：<br> 成员变量：<br> 属性：setter和getter方法截取后的产物<pre><code> 例如：getUsername() --&gt; Username--&gt; username
</code></pre>
</li>
<li>方法：<ol>
<li>setProperty()</li>
<li>getProperty()</li>
<li>populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</li>
</ol>
</li>
</ol>
<h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><pre><code>* 功能：设置响应消息
    1. 设置响应行
        1. 格式：HTTP/1.1 200 ok
        2. 设置状态码：setStatus(int sc) 
    2. 设置响应头：setHeader(String name, String value) 
        
    3. 设置响应体：
        * 使用步骤：
            1. 获取输出流
                * 字符输出流：PrintWriter getWriter()

                * 字节输出流：ServletOutputStream getOutputStream()

            2. 使用输出流，将数据输出到客户端浏览器


* 案例：
    1. 完成重定向
        * 重定向：资源跳转的方式
        * 代码实现：
            //1. 设置状态码为302
            response.setStatus(302);
            //2.设置响应头location
            response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);


            //简单的重定向方法
            response.sendRedirect(&quot;/day15/responseDemo2&quot;);

        * 重定向的特点:redirect
            1. 地址栏发生变化
            2. 重定向可以访问其他站点(服务器)的资源
            3. 重定向是两次请求。不能使用request对象来共享数据
        * 转发的特点：forward
            1. 转发地址栏路径不变
            2. 转发只能访问当前服务器下的资源
            3. 转发是一次请求，可以使用request对象来共享数据
        
        * forward 和  redirect 区别
            
        * 路径写法：
            1. 路径分类
                1. 相对路径：通过相对路径不可以确定唯一资源
                    * 如：./index.html
                    * 不以/开头，以.开头路径

                    * 规则：找到当前资源和目标资源之间的相对位置关系
                        * ./：当前目录
                        * ../:后退一级目录
                2. 绝对路径：通过绝对路径可以确定唯一资源
                    * 如：http://localhost/day15/responseDemo2        /day15/responseDemo2
                    * 以/开头的路径

                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出
                        * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)
                            * 建议虚拟目录动态获取：request.getContextPath()
                            * &lt;a&gt; , &lt;form&gt; 重定向...
                        * 给服务器使用：不需要加虚拟目录
                            * 转发路径
</code></pre>
<p>​<br>​                        </p>
<pre><code>    2. 服务器输出字符数据到浏览器
        * 步骤：
            1. 获取字符输出流
            2. 输出数据

        * 注意：
            * 乱码问题：
                1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1
                2. 设置该流的默认编码
                3. 告诉浏览器响应体使用的编码

                //简单的形式，设置编码，是在获取流之前设置
                response.setContentType(&quot;text/html;charset=utf-8&quot;);
    3. 服务器输出字节数据到浏览器
        * 步骤：
            1. 获取字节输出流
            2. 输出数据

    4. 验证码
        1. 本质：图片
        2. 目的：防止恶意表单注册
</code></pre>
<h2 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h2><pre><code>1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信
2. 获取：
    1. 通过request对象获取
        request.getServletContext();
    2. 通过HttpServlet获取
        this.getServletContext();
3. 功能：
    1. 获取MIME类型：
        * MIME类型:在互联网通信过程中定义的一种文件数据类型
            * 格式： 大类型/小类型   text/html        image/jpeg

        * 获取：String getMimeType(String file)  
    2. 域对象：共享数据
        1. setAttribute(String name,Object value)
        2. getAttribute(String name)
        3. removeAttribute(String name)

        * ServletContext对象范围：所有用户所有请求的数据
    3. 获取文件的真实(服务器)路径
        1. 方法：String getRealPath(String path)  
             String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问
             System.out.println(b);
    
            String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问
            System.out.println(c);
    
            String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问
            System.out.println(a);
</code></pre>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>* 文件下载需求：
    1. 页面显示超链接
    2. 点击超链接后弹出下载提示框
    3. 完成图片文件下载


* 分析：
    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
    2. 任何资源都必须弹出下载提示框
    3. 使用响应头设置资源的打开方式：
        * content-disposition:attachment;filename=xxx


* 步骤：
    1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename
    2. 定义Servlet
        1. 获取文件名称
        2. 使用字节输入流加载文件进内存
        3. 指定response的响应头： content-disposition:attachment;filename=xxx
        4. 将数据写出到response输出流


* 问题：
    * 中文文件问题
        * 解决思路：
            1. 获取客户端使用的浏览器版本信息
            2. 根据不同的版本信息，设置filename的编码方式不同
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>会话技术与JSP学习</title>
    <url>/2021/11/07/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%E4%B8%8EJSP%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h1><ol>
<li>会话 : 一次会话中包含多次请求和响应<ul>
<li>一次会话 : 浏览器在第一次给服务器资源发送请求, 会话建立, 直到有一方断开为止</li>
</ul>
</li>
<li>功能 : 在一次会话的范围内多次请求间, 共享数据</li>
<li>方式 : <ol>
<li>客户端会话技术 : Cookie</li>
<li>服务端会话技术 : Session</li>
</ol>
</li>
</ol>
<h2 id="客户端会话技术-Cookie"><a href="#客户端会话技术-Cookie" class="headerlink" title="客户端会话技术 : Cookie"></a>客户端会话技术 : Cookie</h2><ol>
<li><p>概念 : 客户端会话技术, 将数据保存在客户端</p>
</li>
<li><p>快速入门 : </p>
<ul>
<li><p>使用步骤 : </p>
<ol>
<li><p>创建Cookie对象, 绑定数据 </p>
<p><code>new Cookie(String name, String value)</code></p>
</li>
<li><p>发送Cookie对象</p>
<p><code>response.addCookie(Cookie cookie)</code></p>
</li>
<li><p>获取Cookie对象, 拿到数据</p>
<p><code>Cookie[] request.getCookies()</code></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>实现原理</p>
<ul>
<li><p>基于响应头set-cookie和请求头cookie实现</p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/cookie1.1y0w3g0h1k2o.png" alt="cookie1"></p>
</li>
</ul>
</li>
<li><p>cookie的细节</p>
<ol>
<li>一次可以发送多个cookie, 创建多个cookie即可</li>
<li>cookie的保存时间中<ol>
<li>默认情况下, 当浏览器关闭时, cookie被销毁</li>
<li>持久化保存 : <ul>
<li><code>setMaxAge(int seconds)</code><ol>
<li>正数 : 将cookie数据写到硬盘的文件中. 持久化存储. seconds代表存活的秒数</li>
<li>负数 : 默认情况</li>
<li>0 : 删除cookie信息</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li>在tomcat 8之前, cookie不支持存储中文, 需要转码(一般使用URL编码%E3), 在tomcat 8之后支持存储中文数据当不支持特殊字符需要编码与解码<ol>
<li>编码 : <code>String URLEncode.encode(String s, String enc)</code></li>
<li>解码 : <code>String URLDecode.decode(String s, String enc)</code></li>
</ol>
</li>
<li>在一个tomcat服务器下, 多个项目之间的cookie共享问题<ul>
<li>默认情况下不能共享</li>
<li><code>setPath(String path)</code> : 设置cookie的获取范围, 默认情况下为当前的虚拟目录</li>
<li>如果要共享, 则可以将path设置为 “/“ </li>
</ul>
</li>
<li>不同的tomcat服务器间cookie共享数据<ul>
<li><code>setDomain(String path)</code> : 如果设置一级域名相同, 那么多个服务器之间cookie可以共享<ul>
<li><code>setDomain(&quot;.baidu.com&quot;)</code>. 那么tieba.baidu.com和news.baidu.com中cookie可以共享</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Cookie的特点和作用</p>
<ol>
<li>cookie存储在客户端浏览器</li>
<li>浏览器对于单个cookie的大小有限制(4kb) 以及对同一个域名下的总cookie数量也有限制(20个)</li>
</ol>
<ul>
<li>作用 : <ol>
<li>cookie一般用于存储少量的不太敏感的数据</li>
<li>在不登录的情况下对客户端身份的识别</li>
</ol>
</li>
</ul>
</li>
<li><p>案例 : 记住上一次访问时间</p>
<ol>
<li>需求<ol>
<li>访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。</li>
<li>如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="JSP-入门学习"><a href="#JSP-入门学习" class="headerlink" title="JSP : 入门学习"></a>JSP : 入门学习</h2><ol>
<li>概念 : <ul>
<li>Java Server Pages : java服务器端页面<ul>
<li>可以理解为 : 一个特殊的页面, 其中既可以指定定义html标签, 又可以定义java代码</li>
<li>可以简化书写</li>
</ul>
</li>
</ul>
</li>
<li>原理<ul>
<li>JSP本质上就是一个Servlet</li>
</ul>
</li>
<li>JSP的脚本 : JSP定义java代码的方式<ol>
<li>&lt;% 代码 %&gt; : 定义的java代码, 在service方法中, 能写什么, 该脚本就可以写什么</li>
<li>&lt;%! 代码 %&gt; : 定义的java代码, 在JSP转换后的java类的成员位置, </li>
<li>&lt;%= 代码 %&gt; : 定义的java代码, 会输出到页面上, 输出语句中可以定义什么, 该脚本就可以定义什么</li>
</ol>
</li>
<li>JSP的内置对象 : <ul>
<li>在JSP页面中不需要获取和创建, 可以直接使用的对象</li>
<li>JSP一共有九个内置对象<ul>
<li>request</li>
<li>response</li>
<li>out : 可以将数据直接输出到页面上. 和response.getWriter()类似<ul>
<li>但服务器总会优先response.getWriter()对象输出, 所以尽量使用out对象进行输出</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>案例 : 记住上一次访问时间<ol>
<li>需求<ol>
<li>访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。</li>
<li>如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session :"></a>Session :</h2><ol>
<li><p>概念 : 服务器端会话技术, 再一次会话中的多次请求间共享数据, 将数据保存在服务器端的对象中, HttpSession</p>
</li>
<li><p>快速入门 : </p>
<ol>
<li><p>获取HttpSession对象 : </p>
<p><code>request.getSession()</code></p>
</li>
<li><p>使用HttpSession对象 : </p>
<ol>
<li><code>void setAttribute(String name,Object obj)</code>:存储数据</li>
<li><code>Object getAttitude(String name)</code>:通过键获取值</li>
<li><code>void removeAttribute(String name)</code>:通过键移除键值对</li>
</ol>
</li>
<li><p>原理</p>
<ul>
<li>Session的实现是依赖于Cookie的.</li>
</ul>
</li>
<li><p>细节 :  </p>
<ol>
<li><p>当客户端关闭后, 服务器不关闭, 两次得到的session是否相同</p>
<ul>
<li><p>默认情况下不同</p>
</li>
<li><p>如果需要相同, 则可以创建Cookie对象, 键为JSESSIONID, 设置最大存活时间, 让cookie持久化保存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> cookie(<span class="string">&quot;JSESSIONID&quot;</span>. session.getId());</span><br><span class="line">cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>客户端不关闭, 服务器关闭后,两次得到的session是否相同</p>
<ul>
<li>不是同一个, 但要确保数据不丢失<ul>
<li>session的钝化 : <ul>
<li>在服务器正常关闭之前, 将session对象序列化到硬盘上</li>
</ul>
</li>
<li>session的活化 : <ul>
<li>在服务器启动后, 将session文件转化为内存中的session对象即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>session的销毁时间</p>
<ol>
<li><p>服务器关闭</p>
</li>
<li><p>session对象调用invalidate()</p>
</li>
<li><p>session默认失效时间 30分钟</p>
<p>选择配置修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>session的特点</p>
<ol>
<li>session用于存储一次会话的多次请求数据, 存在服务器端</li>
<li>session可以存储任意数据类型, 任意大小数据</li>
</ol>
<ul>
<li>session与cookie的区别<ol>
<li>session存储在服务器端, cookie存储在客户端</li>
<li>session没有数据大小限制, cookie有</li>
<li>session数据安全, cookie相对不安全</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="案例-验证码"><a href="#案例-验证码" class="headerlink" title="案例 : 验证码"></a>案例 : 验证码</h2><p>案例需求：    </p>
<ol>
<li>访问带有验证码的登录页面login.jsp</li>
<li> 用户输入用户名，密码以及验证码。</li>
</ol>
<ul>
<li>如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误</li>
<li>如果验证码输入有误，跳转登录页面，提示：验证码错误</li>
<li>如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JSP学习</title>
    <url>/2021/11/08/JSP%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><pre><code>1. 指令
    * 作用 : 用于配置JSP页面, 导入资源文件
    * 格式 : 
        &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2... %&gt;
    * 分类 : 
        1. page    : 配置JSP页面
            * contentType : 等同于reponse.setContentType()
                1. 设置响应体的mime类型以及字符集
                2. 设置当前JSP页面的编码(只适用于高级的开发工具)
            * import         : 导包
            * errorPage     :当前页面发生异常后会自动跳转到的页面
            * isErrorPage     : 标识当前页面是否为错误页面(默认为false)
        2. include : 让页面包含指定的页面. 即导入页面的资源文件
            * &lt;%@include file=&quot;top.jsp&quot;%&gt;
        3. taglib  : 导入资源
            * &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
                * prefix : 自定义前缀
2. 注解
    1. html注释 :
        * &lt;!-- --&gt;     : 只能注释html代码片段
    2. JSP注释 : 推荐使用
        * &lt;%-- --%&gt; : 可以注释所有内容

3. 内置对象
    * 在JSP页面中不需要创建, 可以直接使用
    * 一共有九个 : 
            变量名                真实类型                        作用
        * pageContext            PageContext                    当前页面共享数据 还可以获得其他八个内部对象
        * request                HttpServletRequest            一次请求访问的多个资源间
        * session                HttpSession                    一个会话的多次请求间
        * application            ServletContext                所有用户间共享数据
        * response                HttpServletResponse            响应对象
        * page                    Object                        当前页面(Serclet)的对象 this
        * out                    JspWriter                    输出对象, 将数据输出到页面
        * config                ServletConfig                Servlet的配置对象
        * exception                Throwable                    异常对象
</code></pre>
<h2 id="MVC开发模式"><a href="#MVC开发模式" class="headerlink" title="MVC开发模式"></a>MVC开发模式</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/image.1tbmqz2yj7k0.png" alt="image"></p>
<pre><code>1. MVC : 
    1. M : Model, 模型. JavaBean
        * 完成具体的业务操作, 如 : 查询数据库, 封装对象
    2. V : View, 视图, JSP
        * 展示数据
    3. C : Controller : 控制器, Servlet
        * 获取用户输入
        * 调用模型
        * 将数据交给视图进行展示
    
    * 优缺点 : 
        1. 优点 : 
            1. 耦合度低, 方便维护, 可以利于分工协作
            2. 重用性高
        2. 缺点 : 
            1. 使得项目结构变得复杂, 对开发人员要求变高
</code></pre>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><pre><code>1. 概念 : Expression Language 表达式语言
2. 作用 : 替换和简化jsp页面中java代码的编写
3. 语法 : $&#123;表达式&#125;
4. 注意 : 
    * jsp默认支持el表达式, 如果要忽略el表达式
        1. 设置jsp的page指令中 : isELIgnored=&quot;true&quot; 忽略当前页面的所有el表达式
        2. \$&#123;表达式&#125; : 忽略当前这个el表达式

5. 使用 : 
    1. 运算 : 
        * 运算符 : 
            1. 算数运算符
            2. 比较运算符
            3. 逻辑运算符
            4. 空运算符 : empty
                * 功能 : 用于判断字符串, 集合, 数组对象是否为null或长度为0

    2. 获取值
        1. el表达式只能从域对象获取值
        2. 语法 :
            1. $&#123;域名称.键名&#125; : 从指定域中获取指定键的值
                * 域名称 : 
                    1. pageScope            ---&gt;        pageContext
                    2. requestScope            ---&gt;        request
                    3. sessionScope            ---&gt;        session
                    4. applicationScope        ---&gt;        application(ServletContext)

            2. $&#123;键名&#125; : 表示依次从最小的域开始查询是否有该键对应的值, 直到找到位置
            3. 获取对象, List集合, Map集合的值
                1. 对象 : $&#123;域名称.键名,属性名&#125;
                    * 本质会去调用对象的getter方法

                2. List集合 : $&#123;域名称.键名[索引]&#125;
                3. Map集合 : $&#123;域名称.键名[&quot;key名称&quot;]&#125;

    3. 隐式对象 : 
        * el表达式中有11个隐式对象
        * pageContext : 
            * 获取jsp其他的八个内置对象
                * $&#123;pageContext.request.contextPath&#125; : 动态获取虚拟目录
</code></pre>
<h2 id="JSPL标签"><a href="#JSPL标签" class="headerlink" title="JSPL标签"></a>JSPL标签</h2><pre><code>1. 概念 : JavaServer Page Tag Library JSP标准标签库
    * 是由Apache组织提供的开源的免费的jsp标签

2. 作用 : 用于简化和替换jsp页面上的java代码


3. 使用步骤 : 
    1. 导入jstl相关的jar包
    2. 导入标签库 &lt;%@ taglib %&gt;
    3. 使用标签

4. 常用的JSTL标签
    1. if : 相当与java代码中的if语句
        1. 属性 : 
            * test为必须属性, 接收boolean表达式
                * 如果表达式结果为true, 则显示if标签体的内容, 反之则不显示
                * 一般情况下与el表达式一起使用

        2. 注意 :
            * if标签没有else, 需要再定义一个c:if标签

    2. choose : 相当于java代码中的switch语句
        1. 使用choose标签声明                    相当于switch声明
        2. 使用when标签做判断                    相当于case
        3. 使用otherwise标签做其他情况的说明    相当于default


    3. foreach : 相当于java代码的for语句
        1. 完成重复性的操作
            * 属性 :
                * begin : 开始值
                * end     : 结束值
                * var     : 临时变量
                * steps : 步长
                * varStatus : 循环状态对象
                    * index : 容器中元素的索引, 从0开始
                    * count : 循环次数, 从1开始

        2. 遍历容器 : 
            * 属性 : 
                * items : 容器对象
                * var     : 容器中元素的临时变量
                * varStatus : 循环状态对象
                    * index : 容器中元素的索引, 从0开始
                    * count : 循环次数, 从1开始
</code></pre>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/image.4w8xrr0s34a0.png" alt="image"><br>    1. 界面层(表示层) : 用户看的页面, 用户可以通过界面上的组件与服务器进行交互<br>    2. 业务逻辑层 : 处理业务逻辑<br>    3. 数据访问层 : 操作数据存储文件</p>
<h2 id="案例-用户信息列表展示"><a href="#案例-用户信息列表展示" class="headerlink" title="案例 : 用户信息列表展示"></a>案例 : 用户信息列表展示</h2><pre><code>1. 需求 : 用户信息的CRUD
2. 设计 : 
    1. 技术选型 : servlet+JSP+MySQL+JDBCTemplet+Duird+BeanUtils+tomcat 
    2. 数据库的设计
        create table user(
          id int primary key auto_increment,
          name varchar(30) not null,
          gender varchar(5),
          age int,
          address varchar(50),
          qq varchar(20),
          email varchar(20)
        );


3. 开发 :
    1. 环境搭建 :
        1. 创建数据库环境
        2. 城创建项目, 导入需要的jar包

    2. 编码

4. 测试
5. 部署运维
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Filter学习</title>
    <url>/2021/11/10/Filter%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Fileter-过滤器"><a href="#Fileter-过滤器" class="headerlink" title="Fileter : 过滤器"></a>Fileter : 过滤器</h1><pre><code>1. 概念
    * 当访问服务器的资源时, 过滤器可以将请求拦截下来, 完成一些特殊的功能.
    * 过滤器的作用 : 
        * 一般用于完成通用的操作. 如: 登陆验证, 统一编码处理, 敏感字符过滤...
2. 快速入门 :     
    1. 步骤 : 
        1. 定义一个类, 实现Filter接口
        2. 复写方法
        3. 配置拦截路径
            1. web.xml
            2. 注解

    2. 代码 : 
        @WebFilter(&quot;/index.jsp&quot;)// 访问index.jsp之前, 会执行该过滤器
        public class FilterDemo01 implements Filter &#123;
            @Override
            public void init(FilterConfig filterConfig) throws ServletException &#123;
            &#125;
        
            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
                System.out.println(&quot;我被执行了!&quot;);
                // 放行
                filterChain.doFilter(servletRequest, servletResponse);
            &#125;
        
            @Override
            public void destroy() &#123;
            &#125;
        &#125;

3. 过滤器细节 :
    1. web.xml的配置    
            &lt;filter&gt;
            &lt;filter-name&gt;demo01&lt;/filter-name&gt;
            &lt;filter-class&gt;com.chenysh.web.filter.FilterDemo01&lt;/filter-class&gt;
        &lt;/filter&gt;
        &lt;filter-mapping&gt;
            &lt;filter-name&gt;demo01&lt;/filter-name&gt;
            &lt;!--拦截路径--&gt;
            &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt;
        &lt;/filter-mapping&gt;
    2. 过滤器的执行流程
        1. 执行过滤器
        2. 执行放行后的资源
        3. 继续执行下面的代码
    3. 过滤器的生命周期方法
        1. init:在服务器启动后, 会创建Filter对象, 然后调用init方法, 只执行一次, 用于加载资源
        2. doFilter:每次请求被拦截后, 都会执行
        3. destroy:在服务器正常关闭之前执行, 用于释放资源
    4. 过滤器配置详解
        * 拦截路径配置 :
            1. 具体资源路径: /index.jsp  只有访问index.jsp资源时, 过滤器才执行
            2. 目录拦截: /user/*         访问/user目录下的所有资源, 过滤器都会执行
            3. 后缀名拦截: *.jsp            访问后缀名为jsp的资源, 过滤器都会执行
            4. 拦截所有资源: /*             访问所有的资源, 过滤器都会执行
        * 拦截方式配置 : 
            * 注解配置 :
                * 设置dispatcherTypes属性
                    1. REQUEST : 默认值. 浏览器直接请求资源
                    2. FORWARD : 转发访问资源
                    3. INCLUDE : 包含访问资源
                    4. ERROR   : 错误跳转资源
                    5. ASYNC   : 异步访问资源
                * web.xml配置
                    * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可

    5. 过滤器链(配置多个过滤器)    
        * 执行顺序 : 如果有两个过滤器 : 过滤器1与过滤器2
            1. 过滤器1
            2. 过滤器2
            3. 资源执行
            4. 过滤器2
            5. 过滤器1
        
        * 过滤器执行先后问题 : 
            1. 注解配置: 按照**类名**的字符串比较规则, 小的先执行
                * FilterDemo01比FilterDemo02先执行
            2. web.xml配置 : &lt;filter-mapping&gt;的定义顺序决定, 谁在上面谁先执行
</code></pre>
<h1 id="Listener：监听器"><a href="#Listener：监听器" class="headerlink" title="Listener：监听器"></a>Listener：监听器</h1><pre><code>* 概念：web的三大组件之一。
    * 事件监听机制
        * 事件    ：一件事情
        * 事件源 ：事件发生的地方
        * 监听器 ：一个对象
        * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码


* ServletContextListener:监听ServletContext对象的创建和销毁
    * 方法：
        * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法
        * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法
    * 步骤：
        1. 定义一个类，实现ServletContextListener接口
        2. 复写方法
        3. 配置
            1. web.xml
                    &lt;listener&gt;
                      &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;
                    &lt;/listener&gt;

                    * 指定初始化参数&lt;context-param&gt;
            2. 注解：
                * @WebListener
</code></pre>
]]></content>
  </entry>
</search>
