<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start<span id="more"></span></h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.25</title>
    <url>/2021/10/25/leetcode10-25/</url>
    <content><![CDATA[<p>题目:</p>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。<br><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii">链接</a></li>
</ul>
<h2 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路<span id="more"></span></h2><p>一开始我的思路就是通过两次二分找到答案,然后发现不行,因为二分不能直接找到答案所在的行;</p>
<p>所以我换了一个思路,先找到答案所在的行的区间再二分:</p>
<ol>
<li><strong>通过二分来找到行的上边界和下边界</strong></li>
<li><strong>对每一行进行二分搜索</strong></li>
</ol>
<p>具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;<span class="comment">// 开始寻找下边界</span></span><br><span class="line">        <span class="keyword">int</span> end = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;<span class="comment">// 找到左边界小于target的行</span></span><br><span class="line">                end = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> begin = -<span class="number">1</span>;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = end;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][m - <span class="number">1</span>] &gt;= target) &#123;<span class="comment">// 找到右边界打于target的行</span></span><br><span class="line">                begin = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;<span class="comment">// 对每一行二分</span></span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][mid] &lt; target) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][mid] &gt; target) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可是看了题解之后发现这个方法也不太行</p>
<h2 id="题解的思路"><a href="#题解的思路" class="headerlink" title="题解的思路:"></a>题解的思路:</h2><ol>
<li><p>从矩阵的右上角matrix[x] [y] (x = 0,  y = m - 1)开始查找, 答案就<strong>限定在matrix[x] [y]和matrix[n - 1] [0]之间</strong></p>
</li>
<li><p>如果matrix[x] [y] &gt; target, 说明 y 列都大于 target, 故<strong>应将y减一进行移动</strong></p>
</li>
<li><p>同理, 如果matrix[x] [y] &lt; target, 说明 x 行都大于 target, 故<strong>应将x加一进行移动</strong></p>
</li>
<li><p>如果 x, y 越界, 则找不到target, 应返回false</p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; n &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] &gt; target) &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Markdown学习</title>
    <url>/2021/10/25/Markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习<span id="more"></span></h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>hello, world!</p>
<p><strong>hello, world!</strong>(ctrl + b)</p>
<p><em>hello, world!</em>( ctrl + i)</p>
<p><em><strong>hello, world!</strong></em></p>
<p><del>hello, world!</del></p>
<p> <u>hello, world!</u> (ctrl + u)</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p><strong>学习要持之以恒                                                                                                                            -范佳兴</strong></p>
</blockquote>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
<hr>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="C:\Users\yoga\Pictures\asoul\珈乐\b025eb04fd5d728925d31da409ab25c764d3e815.jpg@1320w_1600h.webp" alt="截图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ischenysh/images@master/%E5%A4%B4%E5%83%8F.5afo5fhm0nc0.webp" alt="头像"></p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a class="link"   href="https://ischenysh.github.io/" >点击跳转到个人博客<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol>
<li>A</li>
<li>B</li>
<li>C</li>
</ol>
<ul>
<li>A</li>
<li>B</li>
<li>C</li>
</ul>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>姓名</th>
<th>性别</th>
<th>生日</th>
</tr>
</thead>
</table>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">psvm</span><br></pre></td></tr></table></figure>

<p><code>psvm</code></p>
]]></content>
  </entry>
  <entry>
    <title>多线程与并发</title>
    <url>/2021/10/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发<span id="more"></span></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="普通方法调用与多线程的区别"><a href="#普通方法调用与多线程的区别" class="headerlink" title="普通方法调用与多线程的区别:"></a>普通方法调用与多线程的区别:</h3><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B1.4ztxbzdar4w0.png" alt="多线程1"></p>
<h3 id="进程-Process-与线程-Thread-的区别"><a href="#进程-Process-与线程-Thread-的区别" class="headerlink" title="进程(Process)与线程(Thread)的区别"></a>进程(Process)与线程(Thread)的区别</h3><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E9%A1%B9%E7%A8%8B2.5xsngvti8vo0.png" alt="多项程2"></p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B4.2bfyewdz96f4.png" alt="多线程4"></p>
<ul>
<li><strong>NEW</strong> (新建)</li>
<li><strong>RUNNABLE</strong>(可运行)</li>
<li><strong>BLOCKED</strong>(阻塞)</li>
<li><strong>WAITING</strong>(等待)</li>
<li><strong>TIMED_WAITING</strong>(计时等待)</li>
<li><strong>TERMINATED</strong>(终止)</li>
</ul>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B3.2sjqzrq4id40.png" alt="多线程3"></p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">// 创建子线程对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> ThreadTest().start();<span class="comment">// 创建匿名对象并开启线程</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子类继承Thread类具有多线程能力</li>
<li>启动线程:子类对象.start()</li>
<li><strong>不建议使用:避免OOP单继承局限性</strong></li>
</ul>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadTest2()).start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现接口Runnable具有多线程能力</li>
<li>启动线程:传入目标对象+Thread对象.start()</li>
<li><strong>推荐使用:避免单继承局限性,灵活方便,方便同一个对象被多个线程使用</strong></li>
</ul>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;<span class="comment">// 实现Callable接口</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 重写call()方法, 有返回值且类型与Callable&lt;&gt;的尖括号中一样</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">		ThreadTest3 task1 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ThreadTest3 task2 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ThreadTest3 task3 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ExecutorService service = Executors.newCachedThreadPool();<span class="comment">// 创建服务</span></span><br><span class="line">        <span class="comment">// Future用于接受结果或结束任务, submit方法用于提交任务, 服务会将其并入线程池</span></span><br><span class="line">		Future&lt;Boolean&gt; ans1 = service.submit(task1);</span><br><span class="line">		Future&lt;Boolean&gt; ans2 = service.submit(task2);</span><br><span class="line">		Future&lt;Boolean&gt; ans3 = service.submit(task3);</span><br><span class="line">		System.out.println(ans1.get());<span class="comment">// 输出得到的结果</span></span><br><span class="line">		System.out.println(ans2.get());</span><br><span class="line">		System.out.println(ans3.get());</span><br><span class="line">		service.shutdown();<span class="comment">// 关闭服务</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>实现Callable接口, 需要返回值类型</p>
</li>
<li><p>重写call方法, 需要抛出异常</p>
</li>
<li><p>创建目标对象</p>
</li>
<li><p>创建执行服务:<code>ExecutorService service = Executors.newCachedThreadPool();</code></p>
</li>
<li><p>提交执行:<code>Future&lt;Boolean&gt; ans1 = service.submit(task1);</code></p>
</li>
<li><p>获取结果:<code>ans1.get()</code></p>
</li>
<li><p>关闭服务:<code>service.shutdown();</code></p>
<h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenyusheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Marry you = <span class="keyword">new</span> You();</span><br><span class="line">		<span class="keyword">new</span> WeddingCompany(you).HappyMarry();</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;我好开心!&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要结婚啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	Marry person;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry person)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.person = person;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;准备婚礼&quot;</span>);</span><br><span class="line">		person.HappyMarry();</span><br><span class="line">		System.out.println(<span class="string">&quot;收拾现场&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>真实对象和代理对象都要<strong>实现一个接口</strong></p>
</li>
<li><p>代理对象要<strong>代理</strong>真实角色</p>
</li>
</ul>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>代理对象可以做很多真实对象做不了的事情</li>
<li>真实对象<strong>专注做自己的事情</strong></li>
</ul>
<h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>setPriority(int newPriority)</code></td>
<td align="center">更改线程的优先级</td>
</tr>
<tr>
<td align="center"><code>static void sleep(long millis)</code></td>
<td align="center">在指定的毫秒数内让当前正在执行的线程休眠</td>
</tr>
<tr>
<td align="center"><code>void join()</code></td>
<td align="center">等待该线程终止</td>
</tr>
<tr>
<td align="center"><code>static void yield()</code></td>
<td align="center">暂停当前正在执行的线程对象, 并执行其他线程</td>
</tr>
<tr>
<td align="center"><code>void interrupt()</code></td>
<td align="center">设置线程中断标志为true</td>
</tr>
<tr>
<td align="center"><code>boolean isAlive</code></td>
<td align="center">测试线程是否处于活动状态</td>
</tr>
<tr>
<td align="center"><code>Thread.State getState()</code></td>
<td align="center">获取当前线程状态</td>
</tr>
<tr>
<td align="center"><code>static boolean Thread.Interrpted()</code></td>
<td align="center">获取当前线程的中断标志并清除标志</td>
</tr>
<tr>
<td align="center"><code>boolean isInterrupted()</code></td>
<td align="center">获取线程的中断标志但不会清除标志</td>
</tr>
</tbody></table>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><h3 id="使用标志位退出-正常退出"><a href="#使用标志位退出-正常退出" class="headerlink" title="使用标志位退出,正常退出"></a>使用标志位退出,正常退出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopTest1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">// 设置标志位</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadStopTest1 task = <span class="keyword">new</span> ThreadStopTest1();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">		task.flag = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用interrupt方法打断线程"><a href="#使用interrupt方法打断线程" class="headerlink" title="使用interrupt方法打断线程"></a>使用interrupt方法打断线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">// 判断线程的中断标志</span></span><br><span class="line">			<span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程被打断了, 拜拜!&quot;</span> </span><br><span class="line">                                   + <span class="string">&quot;中断标志 &quot;</span> </span><br><span class="line">                                   + Thread.currentThread().isInterrupted());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程被打断了, 拜拜!&quot;</span> </span><br><span class="line">                                   + <span class="string">&quot;中断标志 &quot;</span> </span><br><span class="line">                                   + Thread.currentThread().isInterrupted());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				sleep(<span class="number">200</span>);<span class="comment">// 如果在睡眠中被打断, 将会抛出InterruptedException异常</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				System.out.println(<span class="string">&quot;线程在睡眠中被打断了, 拜拜!&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStopTest2());</span><br><span class="line">		thread.start();</span><br><span class="line">		sleep(<span class="number">2000</span>);</span><br><span class="line">		thread.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一般写法"><a href="#一般写法" class="headerlink" title="一般写法"></a>一般写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = ()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep or wait</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clean up, <span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果每次工作迭代后都使用sleep()方法(或其他可中断方法), 则无需进行中断状态的检查, 因为在休眠中被打断,它会清除中断状态并抛出 <strong>InterruptedException</strong> 异常.代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = ()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">            Thread.sleep(delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clean up, <span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h2><p><code>static void yield</code></p>
<p><strong>静态方法</strong>, 使当前线程从运行状态变为<strong>就绪状态</strong>,让 cpu <strong>重新调度</strong>.</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p><code>thread.setDaemon(true)</code></p>
<p>将一个线程转换为守护线程, <strong>用户线程默认为 false</strong>, 用途是<strong>为其他线程提供服务</strong>, 如计时器, <strong>当只剩下守护线程时, 程序将会结束</strong></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="使用-Lock-Condition-结构"><a href="#使用-Lock-Condition-结构" class="headerlink" title="使用 Lock/Condition 结构"></a>使用 Lock/Condition 结构</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构:"></a>基本结构:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myLock.lock();<span class="comment">// 一个锁对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    myLock.unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>这个结构能够保证任何时刻只有一个线程能够进入临界区, 一旦一个线程锁定了锁对象, 其他任何线程都无法通过lock语句, 当其他线程调用lock时, 他们会暂停, 直到第一个线程释放这个锁对象.</p>
</li>
<li><p><strong>一个对象定义一个锁对象,</strong> 当两个线程操作两个对象时, 两个线程都不会阻塞</p>
</li>
</ul>
<h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><ul>
<li><p>当线程进入临界区后发现只有满足某个条件后它才能执行, 此时可以使用一个<strong>条件对象</strong>来管理这些线程</p>
</li>
<li><p>通过锁对象调用Condition方法<code>lock.newCondition()</code>来创建一个条件对象, 当线程不满足运行条件就通过条件对象来调用await方法<code>condition.await()</code><strong>将该线程暂停并放弃锁</strong><strong>, 该线程将进入这个条件的等待集(wait set), 当锁可用时, 该线程并不会变成可运行状态, 直到另一个线程在</strong>同一条件**下调用<code>signAll</code>方法<code>condition.signAll()</code>.</p>
</li>
<li><p><code>signAll()</code>方法会重新激活等待这个条件的所有线程, 将他们从等待集中移出, 它们再次变成可运行的线程, 当锁再次可用时, 他们中的某个线程将<strong>从<code>await()</code>调用中返回</strong>, 从<strong>暂停的地方继续执行</strong>.</p>
</li>
<li><p>此时, 线程应再次测试条件, <strong>不能保证现在一定满足条件-</strong>—-<code>signAll()</code>方法仅仅是通知等待的线程:</p>
<p><strong>现在有可能满足条件, 值得再次检查</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!OK to proceed) &#123;</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>死锁(deadlock)现象</strong>:所有线程都阻塞, 程序永远无法继续运行</li>
</ul>
<p>程序实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span>[] account;<span class="comment">// 银行账户</span></span><br><span class="line">	<span class="keyword">private</span> Lock lock;<span class="comment">// 锁对象</span></span><br><span class="line">	<span class="keyword">private</span> Condition sufficientFunds;<span class="comment">// 条件对象</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">double</span> initAmount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.account = <span class="keyword">new</span> <span class="keyword">double</span>[size];</span><br><span class="line">		Arrays.fill(<span class="keyword">this</span>.account, initAmount);</span><br><span class="line">		lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">		sufficientFunds = lock.newCondition();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从一个账户向另一个账户转账</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> from 转帐的一方</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> to 收钱的一方</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> amount 转账数额</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (account[from] &lt; amount) &#123;</span><br><span class="line">				sufficientFunds.await();<span class="comment">// 当余额不足时, 线程挂起</span></span><br><span class="line">			&#125;</span><br><span class="line">			account[from] -= amount;</span><br><span class="line">			account[to] += amount;</span><br><span class="line">			System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">					<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">			sufficientFunds.signalAll();<span class="comment">// 账户余额变更后应通知所有该条件的等待线程</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获得银行总资产</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 银行总资产</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalAsset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">double</span> e : account) &#123;</span><br><span class="line">				total += e;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> total;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USERSIZE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADSIZE = <span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAY = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> INITAMOUNT = <span class="number">10000.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bank bank = <span class="keyword">new</span> Bank(USERSIZE, INITAMOUNT);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADSIZE; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">						<span class="keyword">int</span> from = (<span class="keyword">int</span>) (Math.random() * USERSIZE);</span><br><span class="line">						<span class="keyword">int</span> to = (<span class="keyword">int</span>) (Math.random() * USERSIZE);</span><br><span class="line">						<span class="keyword">if</span> (from == to) &#123;</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">double</span> amount = Math.random() * INITAMOUNT;</span><br><span class="line">						bank.transfer(from, to, amount);</span><br><span class="line">						Thread.sleep(DELAY);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用-synchronized-关键字"><a href="#使用-synchronized-关键字" class="headerlink" title="使用 synchronized 关键字"></a>使用 synchronized 关键字</h3><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>Java中每一个对象都有一个对象内部锁, 当一个方法被声明为同步方法时, 对象内部锁将会保护整个方法</p>
<p>即:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		method body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		method body</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部对象锁只有一个关联对象, <code>wait()</code>方法将线程添加到等待集中, <code>notifyAll()</code>/<code>notify()</code>方法可以解除等待线程的阻塞,调用<code>wait()</code>方法和<code>notifyAll()</code>等价于调用:<br><code>intrinsicContition.await();</code><br><code>intrinsicContition.signalAll();</code></p>
<p>使用 synchronized 关键字的 transfer 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (account[from] &lt; amount) &#123;</span><br><span class="line">		wait();</span><br><span class="line">	&#125;</span><br><span class="line">	account[from] -= amount;</span><br><span class="line">	account[to] += amount;</span><br><span class="line">	System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">			<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">	notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul>
<li>最好不使用上面两种方法, 在大部分的情况下使用java.util.concurrent包中的某种机制就可以解决所有的锁定问题(<strong>不会用</strong>, <strong>笑嘻了</strong>)</li>
<li>如果使用 synchronized 关键字就可以满足你的需求, 就使用它, 因为可以让代码变得简洁</li>
<li>如果实在需要Lock/Condition 结构的额外能力才使用它</li>
</ul>
<h3 id="使用同步块"><a href="#使用同步块" class="headerlink" title="使用同步块"></a>使用同步块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;<span class="comment">// 获得该对象的锁</span></span><br><span class="line">	critical section<span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 同步块的 transfer 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Vector&lt;Double&gt; accounts, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (accounts) &#123;</span><br><span class="line">       	accounts.set(from, accounts.get(from) - amount);</span><br><span class="line">		accounts.set(to  , accounts.get(to  ) + amount);</span><br><span class="line">       &#125;</span><br><span class="line">	System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">			<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-volatile-关键字"><a href="#使用-volatile-关键字" class="headerlink" title="使用 volatile 关键字"></a>使用 volatile 关键字</h3><p>将一个实例字段声明为为 volatile , 可以保证该字段的修改对所有线程可见, 但由于不能保证其原子性, 故不能对其进行非原子的操作, 最好只进行赋值和读取.</p>
<p>具体可以查询<a class="link"   href="https://blog.csdn.net/u012723673/article/details/80682208?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163531427216780271545094%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163531427216780271545094&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80682208.first_rank_v2_pc_rank_v29&utm_term=volatile&spm=1018.2226.3001.4187" >Java volatile关键字最全总结<i class="fas fa-external-link-alt"></i></a>)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.26_496.下一个更大元素I</title>
    <url>/2021/10/27/leetcode10-26-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</url>
    <content><![CDATA[<p>题目如下<span id="more"></span></p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/leetcode10.26.nbf6kkpd9y8.png" alt="leetcode10"></p>
<h1 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h1><p>暴力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">boolean</span> isFound = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nums2[j] == nums1[i]) &#123;</span><br><span class="line">					index = j;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (nums2[j] &gt; nums1[i] &amp;&amp; index &lt; j) &#123;</span><br><span class="line">					ans[i] = nums2[j];</span><br><span class="line">					isFound = <span class="keyword">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!isFound) &#123;</span><br><span class="line">				ans[i] = -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题解真的牛逼, 麻了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> n = nums2.length;</span><br><span class="line">		stack.push(nums2[n - <span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 逆序遍历</span></span><br><span class="line">			<span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[i]) &#123;</span><br><span class="line">				stack.pop();<span class="comment">// pop栈中所有小于当前元素的值</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">				map.put(nums2[i], stack.peek());<span class="comment">// 如果栈不为空则右边存在比该元素大的值</span></span><br><span class="line">			&#125;</span><br><span class="line">			stack.push(nums2[i]);<span class="comment">// 存入当前元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">			num1[i] = map.getOrDefault(nums1[i], -<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逆序遍历 nums2 数组, 栈中只允许存在比当前元素大的元素, 则栈顶元素就为当前元素右边大于该元素的第一个元素, 如果栈为空则右边不存在比该元素大的元素, 用哈希表存储该答案,最后将当前元素push进去;</li>
<li>获取结果:遍历 nums1 数组, 将哈希表存储的答案写入</li>
<li>stack永远单调</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.28.869.重新排序得到 2 的幂</title>
    <url>/2021/10/28/leetcode10-28-869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0-2-%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述<span id="more"></span></h1><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/leedcode10.28.6hb3dzhwkeo0.png" alt="leedcode10"></p>
<h1 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路:"></a>个人思路:</h1><ul>
<li><p>利用递归加回溯进行全排列, </p>
</li>
<li><p>判断是否合法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归加回溯</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2_1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] nums = String.valueOf(n).toCharArray();</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">		<span class="keyword">return</span> dfs(nums, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((current &amp; (current - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vis.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[i] || (index == <span class="number">0</span> &amp;&amp; nums[i] == <span class="string">&#x27;0&#x27;</span>) || (i != <span class="number">0</span> &amp;&amp; !vis[i - <span class="number">1</span>] &amp;&amp; nums[i - <span class="number">1</span>] == nums[i])) &#123;<span class="comment">// 如果本次已经选中过相同的数字,就continue(!vis[i - 1] &amp;&amp; nums[i - 1] == nums[i])</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[i] = <span class="keyword">true</span>;</span><br><span class="line">			ans |= dfs(nums, index + <span class="number">1</span>, current * <span class="number">10</span> + nums[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			vis[i] = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路:"></a>题解思路:</h1><p>预处理加哈希表</p>
<ul>
<li><p>如果 a 和 b 重新排列后,都是同一个 2 的幂, 那么他们每个数字出现的次数应该相同,</p>
</li>
<li><p>利用这个结论我们可以将 1 到1e9 之间的 2 的幂的每个数字出现的次数转化成字符串全部存到set中.</p>
</li>
<li><p>查询即可</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_2</span> </span>&#123;</span><br><span class="line">	Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		init();<span class="comment">// 初始化</span></span><br><span class="line">		<span class="keyword">return</span> set.contains(numsCount(n));<span class="comment">// 查询</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">// 将 1 到1e9 之间的 2 的幂的每个数字出现的次数转化成字符串全部存到set中.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e9</span>; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			set.add(numsCount(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">numsCount</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;<span class="comment">// 每个数字出现的次数转化成字符串</span></span><br><span class="line">		<span class="keyword">int</span>[] numsCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			numsCount[num % <span class="number">10</span>]++;</span><br><span class="line">			num /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(numsCount);</span><br><span class="line">		<span class="keyword">return</span> String.valueOf(numsCount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Java 流</title>
    <url>/2021/10/28/Java-%E6%B5%81/</url>
    <content><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="从迭代到流的操作"><a href="#从迭代到流的操作" class="headerlink" title="从迭代到流的操作"></a>从迭代到流的操作</h2><p>当处理集合时, 我们通常会迭代它的元素, 并在每个元素上执行某项操作. </p>
<p>例如, 假设我们想要对某本书的所有长单词进行计数.首先, 将所有单词放到一个列表里:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String contents = <span class="keyword">new</span> String(</span><br><span class="line">				Files.readAllBytes(path), StandardCharsets.UTF_8);</span><br><span class="line">List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));<span class="comment">// 以非字母的字符为分隔符</span></span><br></pre></td></tr></table></figure>

<p>如果使用迭代:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String e : words) &#123;</span><br><span class="line">	<span class="keyword">if</span> (e.length() &gt; <span class="number">12</span>) &#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用流:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.Stream().filter(e -&gt; e.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>

<p>仅将<code>Stream</code>改为<code>parallelStream</code>就可以让流库以并行方式执行过滤和计数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.parallelStream().filter(e -&gt; e.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>

<h3 id="流与集合的差距"><a href="#流与集合的差距" class="headerlink" title="流与集合的差距"></a>流与集合的差距</h3><ul>
<li>流不存储元素, 这些元素可能存储在底层的集合中, 或者按需生成.</li>
<li>流的操作不会改变其数据源. 例如, <code>filter</code>方法不会从流中移除元素, 而是产生一个新的流, 其中不包含被过滤掉的元素</li>
<li>流的操作时尽可能惰性执行的, 这意味着直至需要结果时,操作才会执行,</li>
</ul>
<p>示例解释:</p>
<p><code>Stream</code>和<code>parallelStream</code>方法会产生一个用于 words 列表的 stream . <code>filter</code>方法会返回另一个流, 其中只包含长度大于12的单词. count 方法会将这个流化简为一个结果.</p>
<h3 id="操作流时的典型流程"><a href="#操作流时的典型流程" class="headerlink" title="操作流时的典型流程"></a>操作流时的典型流程</h3><ol>
<li>创建一个流.</li>
<li>指定将初始流转换成其他流的中间操作, 可能包含多个步骤.</li>
<li>引用停止操作, 从而产生结果, 这个操作会强制执行之前的惰性操作, 从此之后, 这个流就不能用了</li>
</ol>
<p>实例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wordCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountLongWord</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String contents = <span class="keyword">new</span> String(</span><br><span class="line">				Files.readAllBytes(path), StandardCharsets.UTF_8);</span><br><span class="line">		List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));<span class="comment">// 以非字母的字符为分隔符</span></span><br><span class="line">		<span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (String e : words) &#123;</span><br><span class="line">			<span class="keyword">if</span> (e.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		count = words.stream().filter(e -&gt; e.length() &gt; <span class="number">5</span>).count();</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		count = words.parallelStream().filter(e -&gt; e.length() &gt; <span class="number">5</span>).count();</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		CountLongWord(Paths.get(<span class="string">&quot;D:\\Documents\\blog\\themes\\hexo-theme-keep\\languages\\en.yml&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>java io流</title>
    <url>/2021/10/28/java-io%E6%B5%81-0/</url>
    <content><![CDATA[<h1 id="IO概念"><a href="#IO概念" class="headerlink" title="IO概念"></a>IO概念</h1><ul>
<li>I/O 即输入Input/Output的缩写, 其实就是计算机调度吧吧各个存储中(包括内存和外存)的数据写入写出的过程;<span id="more"></span></li>
<li>java中用”流(stream)”来抽象表示这么一个写入写出的功能,封装成一个”类”, 都放在java.io这个包里面.</li>
</ul>
<h1 id="“流”是什么"><a href="#“流”是什么" class="headerlink" title="“流”是什么"></a>“流”是什么</h1><p>通过”流”的形式允许java程序通过使用相同的方式来访问不同的输入/输出源. stream是从起源(source)到接收的(sink)的有序数据. 如果把输入/输出源对比成’水桶’, 那么流就是”管道”, 这个”管道”的粗细, 单向性等属性也就是区分了不同”流”的特性.</p>
<h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ol>
<li><p>按照流的方向(输入输出都是站在程序所在内存的角度划分的)</p>
<ul>
<li>输入流:只能从中读取数据[主要由InputStream和Reader作为基类]</li>
<li>输出流:只能先其写入数据[主要由outputStream和Writer作为基类]</li>
</ul>
</li>
<li><p>按照流的操作颗粒度划分</p>
<ul>
<li>字节流: 以字节为单元, 可操作任何数据[主要由InputStream和OutputStream作为基类]</li>
<li>字符流: 以字符为单元, 只能操作纯字符数据, 比较方便[主要由Reader和Writer作为基类]</li>
</ul>
</li>
<li><p>按照六点角色划分</p>
<ul>
<li>节点流: 可以从/向一个特定的IO设备(如磁盘, 网络) 读/写 数据的流, 也叫[低级流, 主要流]</li>
<li>处理流: 用于对一个已存在的流进行封装, 通过封装后的流来实现数据的 读/写 功能, 也叫[高级流]</li>
</ul>
</li>
</ol>
<h1 id="流的原理以及一共有多少IO流"><a href="#流的原理以及一共有多少IO流" class="headerlink" title="流的原理以及一共有多少IO流"></a>流的原理以及一共有多少IO流</h1><h2 id="流的原理解析"><a href="#流的原理解析" class="headerlink" title="流的原理解析"></a>流的原理解析</h2><blockquote>
<p>流想象成”水管”, 源端和目的端就是两个’水桶’, 数据是通过这个”水管”进行流动传输的, 以”InputStream”和Reader为例, 水管的每个”水滴”就是具体的数据, 如果是字节流, 那么一个”水滴”就是一个字节, 如果是字符流, 那么一个”水滴”就是一个字符</p>
</blockquote>
<p>当创建一个流对象的时候, 如<code>fis = new FileInputstream(&quot;...\xx\xx.txt&quot;)</code>, 记录指针表示当前正准备从哪个”水滴”开始读取, 每当程序从InputStream或者Reader里面取出一个或多个”水滴”后, 记录指针自定向后移动; 除此之外, InputStream和Reader里面都提供了一些方法来控制记录指针的移动.如果是处理流的话, 就相当于在这个”水管”上面装了一些”控制阀门”, 最终用户只要关心”阀门”具备的能力就行.</p>
<h2 id="java中所有流汇总"><a href="#java中所有流汇总" class="headerlink" title="java中所有流汇总"></a>java中所有流汇总</h2><p>java.io种子类中有40个”流”类, 表格如下</p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/IO1.1645xmt3farg.png" alt="IO1"></p>
<h1 id="常见IO流的实战"><a href="#常见IO流的实战" class="headerlink" title="常见IO流的实战"></a>常见IO流的实战</h1><h2 id="访问操作文件-FileInputStream-FileReader-FileOutStream-FileWriter"><a href="#访问操作文件-FileInputStream-FileReader-FileOutStream-FileWriter" class="headerlink" title="访问操作文件(FileInputStream/FileReader, FileOutStream/FileWriter)"></a>访问操作文件(FileInputStream/FileReader, FileOutStream/FileWriter)</h2><ol>
<li><p>使用FileInputStream, 从文件中读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileInputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">null</span>;<span class="comment">// 使用FileInputStream</span></span><br><span class="line"><span class="comment">//      FileReader in = null;// 使用FileReader</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);<span class="comment">// 使用FileInputStream</span></span><br><span class="line"><span class="comment">//			in = new FileReader(&quot;D:\\Documents\\logs\\java0.log&quot;);// 使用FileReader</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;文件未找到, 程序退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line">			in.close();</span><br><span class="line">			System.out.println(<span class="string">&quot;共读取了&quot;</span> + len + <span class="string">&quot;个字节&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常, 程序退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用输出流, 往文件中写数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileOutputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//		FileInputStream in = null;</span></span><br><span class="line">		FileReader in = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//		FileOutputStream out = null;</span></span><br><span class="line">		FileWriter out = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//			in = new FileInputStream(&quot;D:\\Documents\\logs\\java0.log&quot;);</span></span><br><span class="line">			in = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);</span><br><span class="line"><span class="comment">//			out = new FileOutputStream(&quot;D:\\Documents\\logs\\java1.log&quot;);</span></span><br><span class="line">			out = <span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\Documents\\logs\\java1.log&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;不存在该文件,程序即将退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				out.write(b);</span><br><span class="line">			&#125;</span><br><span class="line">			in.close();</span><br><span class="line">			out.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常, 程序即将退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;文件复制完成!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="缓存流的使用-BufferedInputStream-BuffereOutputStream-BufferedReader-BufferedWriter"><a href="#缓存流的使用-BufferedInputStream-BuffereOutputStream-BufferedReader-BufferedWriter" class="headerlink" title="缓存流的使用(BufferedInputStream/BuffereOutputStream, BufferedReader/BufferedWriter)"></a>缓存流的使用(BufferedInputStream/BuffereOutputStream, BufferedReader/BufferedWriter)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">		FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">		BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">		BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);</span><br><span class="line">			fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\Documents\\logs\\java1.log&quot;</span>);</span><br><span class="line">			bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">			bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((off = bis.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				bos.write(buffer, <span class="number">0</span>, off);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;文件复制完成&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			bis.close();</span><br><span class="line">			bos.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换流的使用-InputStreamReader-OutputStreamReader"><a href="#转换流的使用-InputStreamReader-OutputStreamReader" class="headerlink" title="转换流的使用(InputStreamReader/OutputStreamReader)"></a>转换流的使用(InputStreamReader/OutputStreamReader)</h2><p>将字节流转化成字符流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\Documents\\logs\\java2.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (line.equals(<span class="string">&quot;over&quot;</span>))&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			bw.write(line);</span><br><span class="line">			bw.newLine();</span><br><span class="line">			bw.flush();<span class="comment">// 刷新字符输出流</span></span><br><span class="line">		&#125;</span><br><span class="line">		br.close();</span><br><span class="line">		bw.close();<span class="comment">// 关闭前必须刷新</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>对象流就是一种特殊的处理流, 也是在基础的字节流上封装.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectOutputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Person ming = <span class="keyword">new</span> Person(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">15</span>);</span><br><span class="line">			FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\Documents\\logs\\java3.txt&quot;</span>);</span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">			oos.writeObject(ming);</span><br><span class="line">			FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java3.txt&quot;</span>);</span><br><span class="line">			ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">			Person p2 = (Person) ois.readObject();</span><br><span class="line">			System.out.println(p2);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			oos.flush();</span><br><span class="line">			oos.close();</span><br><span class="line">			ois.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;<span class="comment">// 对象必须实现序列化接口</span></span><br><span class="line">	<span class="keyword">private</span> String name = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节数据流的使用（ByteArrayInputStream-ByteArrayOutputStream）【通常结合数据流DataInputStream-DataOutputStream】"><a href="#字节数据流的使用（ByteArrayInputStream-ByteArrayOutputStream）【通常结合数据流DataInputStream-DataOutputStream】" class="headerlink" title="字节数据流的使用（ByteArrayInputStream/ByteArrayOutputStream）【通常结合数据流DataInputStream/DataOutputStream】"></a>字节数据流的使用（ByteArrayInputStream/ByteArrayOutputStream）【通常结合数据流DataInputStream/DataOutputStream】</h2><ul>
<li>为了提高效率, 避免频繁的读写文件, 于是出现了字节数组流, 因为存放在内存中, 所以也被称为”内存流”; 字节数组流也是一种节点流;</li>
<li>数据处理流是一种处理流, 用于针对数据类型传输处理的, 一般用于序列化与反序列化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDateStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">// 创建字节数组, 同时会在内存中创建数组</span></span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);<span class="comment">// 将字节数组流封装成数据处理流</span></span><br><span class="line">		DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			dos.writeDouble(Math.random());</span><br><span class="line">			dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">			ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">			System.out.println(bais.available());</span><br><span class="line"></span><br><span class="line">			dis = <span class="keyword">new</span> DataInputStream(bais);</span><br><span class="line">			System.out.println(dis.readDouble());</span><br><span class="line">			System.out.println(dis.readBoolean());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			dos.close();</span><br><span class="line">			dis.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>junit入门</title>
    <url>/2021/10/31/junit%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="junit单元测试"><a href="#junit单元测试" class="headerlink" title="junit单元测试"></a>junit单元测试<span id="more"></span></h1><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><ul>
<li>黑盒测试 : 不关注具体的代码实现, 只需要关注能否得到正确结果</li>
<li>白盒测试 : 不只要关注能否得到正确结果, 还要关注具体的代码实现</li>
</ul>
<h2 id="junit使用"><a href="#junit使用" class="headerlink" title="junit使用"></a>junit使用</h2><ul>
<li><p>步骤</p>
<ol>
<li><p>定义一个测试类(测试用例)</p>
<p>建议:</p>
<ul>
<li>测试类名 : 被测试的类 + Test</li>
<li>包名 : 与被测试的类所在的包同级, 且取名为test <img src="https://raw.githubusercontent.com/ischenysh/images/master/junit.2wcf1jwyhj60.png" alt="junit"></li>
</ul>
</li>
<li><p>定义测试方法 : <strong>可以独立运行</strong></p>
<p>建议:</p>
<ul>
<li>方法名 : test + 被测试的方法名</li>
<li>返回值 : void</li>
<li>参数列表 : 空参</li>
</ul>
</li>
</ol>
<ol start="3">
<li>给方法前加 <em>@test</em> 注解</li>
<li>导入junit 依赖环境</li>
</ol>
</li>
<li><p>判定结果</p>
<ul>
<li>红色 : 失败</li>
<li>绿色 : 成功</li>
<li>一般会使用断言操作</li>
</ul>
</li>
<li><p>补充</p>
<ul>
<li><p><em>@Before</em> :</p>
<p>被注解的方法总是在测试方法之前执行</p>
</li>
<li><p><em>@After</em> :</p>
<p>被注解的方法总是在测试方法之后执行</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.junit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a - b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chenysh.junit.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Calculator calculator;</span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		一般用于申请资源, 总是在test方法执行之前执行</span></span><br><span class="line">		calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">		System.out.println(<span class="string">&quot;我被初始化啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/**test使用规范:</span></span><br><span class="line"><span class="comment">   *总是返回null</span></span><br><span class="line"><span class="comment">   *无参数传入</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = calculator.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		Assert.assertEquals(result, <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = calculator.sub(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		Assert.assertEquals(result, -<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@After</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		一般用于清理资源, 总是在test方法执行之后执行, 不管test方法有没有正常执行完成</span></span><br><span class="line">		System.out.println(<span class="string">&quot;我被清理啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>反射入门</title>
    <url>/2021/10/31/%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="反射-框架设计的灵魂"><a href="#反射-框架设计的灵魂" class="headerlink" title="反射 : 框架设计的灵魂"></a>反射 : 框架设计的灵魂<span id="more"></span></h1><ul>
<li><p>框架 : 半成品软件, 可以在框架的基础上进行软件开发, 简化编码</p>
</li>
<li><p>反射 : 将类的各个组成部分封装为其他对象</p>
<p>​    好处:</p>
<ul>
<li><p>可以在程序运行过程中操作这些对象</p>
</li>
<li><p>可以解耦, 增强程序的拓展性</p>
</li>
</ul>
</li>
</ul>
<h2 id="获取class-对象的方式"><a href="#获取class-对象的方式" class="headerlink" title="获取class 对象的方式"></a>获取class 对象的方式</h2><ol>
<li><p><code>Class.forName(&quot;全类名&quot;)</code> : 将字节码加载进内存, 返回 class 对象</p>
<p>多用于配置文件, 使类名定义在配置文件中; 通过读取文件来加载类</p>
</li>
<li><p><code>类名.class</code> : 通过类名的属性 class 获取</p>
<p>用于参数的传递</p>
</li>
<li><p><code>对象.getClass()</code> : getClass() 方法定义在 Object 类中</p>
<p>多用于对象的获取字节码的方式</p>
</li>
<li><p>结论 : </p>
<p>同一个字节码文件(*.class)在一次程序运行过程中只会被加载一次, 所有方式获取的Class对象都是同一个</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class class1 = Class.forName(<span class="string">&quot;com.chenysh.reflect.Person&quot;</span>);</span><br><span class="line">		Class class2 = Person.class;</span><br><span class="line">		Class class3 = <span class="keyword">new</span> Person().getClass();</span><br><span class="line">		System.out.println(class1.equals(class2));</span><br><span class="line">		System.out.println(class2.equals(class3));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="class对象的功能"><a href="#class对象的功能" class="headerlink" title="class对象的功能"></a>class对象的功能</h2><ul>
<li><p>获取功能</p>
<ol>
<li><p>获取成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] getFields()</span><br><span class="line"><span class="function">Field <span class="title">getFields</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>获取成员构造方法</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>获取成员方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure></li>
<li><p>获取类名</p>
<p><code>String getName()</code></p>
</li>
</ol>
</li>
<li><p>成员变量</p>
<ol>
<li><p>设置值</p>
<p><code>void set(Object obj, Object value)</code></p>
</li>
<li><p>获取值</p>
<p><code>get (Object obj)</code></p>
</li>
<li><p>忽略访问权限修饰符的安全检查</p>
<p><code>setAccessible(true)</code>// 暴力反射</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Field[] getFields()</span></span><br><span class="line"><span class="comment">Field getField(String name)</span></span><br><span class="line"><span class="comment">Field getDeclaredField(String name)</span></span><br><span class="line"><span class="comment">Field[] getDeclaredFields()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Constructor&lt;?&gt;[] getConstructors()</span></span><br><span class="line"><span class="comment">Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Constructor&lt;?&gt;[] getDeclaredConstructors()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Method[] getMethods()</span></span><br><span class="line"><span class="comment">Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Method[] getDeclaredMethods()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="number">20</span>, <span class="string">&quot;man&quot;</span>, <span class="string">&quot;chenysh&quot;</span>);</span><br><span class="line">		Class class1 = Person.class;</span><br><span class="line">		Field field2 = class1.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">		Field[] fields = class1.getFields();</span><br><span class="line">		System.out.println(field2.get(person));</span><br><span class="line">		field2.set(person, <span class="number">2</span>);<span class="comment">// 修改字段的值</span></span><br><span class="line">		System.out.println(field2.get(person));<span class="comment">// 设置字段的值</span></span><br><span class="line">		<span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">			System.out.println(field);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">		Field field = class1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		fields = class1.getDeclaredFields();</span><br><span class="line">		<span class="keyword">for</span> (Field field1 : fields) &#123;</span><br><span class="line">			System.out.println(field1);</span><br><span class="line">		&#125;</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>);<span class="comment">// 暴力反射</span></span><br><span class="line">		System.out.println(field.get(person));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Constructor[] constructors = class1.getConstructors();</span><br><span class="line">		Constructor constructor = class1.getConstructor(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, String.class, String.class);</span><br><span class="line">		System.out.println(constructor);</span><br><span class="line">		<span class="keyword">for</span> (Constructor constructor1 : constructors) &#123;</span><br><span class="line">			System.out.println(constructor1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Person person1 = (Person) constructor.newInstance(<span class="number">2</span>, <span class="number">21</span>, <span class="string">&quot;yuan&quot;</span>, <span class="string">&quot;woman&quot;</span>);<span class="comment">//      全参构造</span></span><br><span class="line">		System.out.println(person1);</span><br><span class="line">		Object obj = constructors[<span class="number">1</span>].newInstance();<span class="comment">// 空参构造1</span></span><br><span class="line">		System.out.println(obj);</span><br><span class="line">		System.out.println((Person) class1.newInstance());<span class="comment">// 空参构造2</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Method method = class1.getMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">		method.invoke(person, <span class="string">&quot;yuanqinakai&quot;</span>);<span class="comment">// 调用方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li><p>需求 : 写一个”框架”, 可以帮我们创建任意类对象, 并且执行其中任意方法 </p>
</li>
<li><p>实现 :</p>
<ol>
<li>配置文件</li>
<li>反射</li>
</ol>
</li>
<li><p>步骤 : </p>
<ol>
<li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中(配置文件放在src目录下)</li>
<li>在程序中加载读取配置文件</li>
<li>使用反射技术来加载类文件进内存</li>
<li>创建对象</li>
<li>执行方法</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo03</span> </span>&#123;</span><br><span class="line"><span class="comment">//	可以帮我们创建任意类对象, 并且执行其中任意方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		1. 加载配置文件</span></span><br><span class="line"><span class="comment">//		1.1 创建 Properties 对象</span></span><br><span class="line">		Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//		1.2 加载配置文件, 转换为一个集合</span></span><br><span class="line"><span class="comment">//      1.2.1 获取class目录下的配置文件</span></span><br><span class="line">		ClassLoader classLoader = demo03.class.getClassLoader();</span><br><span class="line">		InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;demo.properties&quot;</span>);</span><br><span class="line">		properties.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		2. 获取配置文件中定义的数据</span></span><br><span class="line">		String className = properties.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">		String methodName = properties.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		3. 加载该类进内存</span></span><br><span class="line">		Class aClass = Class.forName(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		4. 创建对象</span></span><br><span class="line">		Object obj = aClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//		5.获取方法对象</span></span><br><span class="line">		Method method = aClass.getMethod(methodName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		6. 执行方法</span></span><br><span class="line">		method.invoke(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>注解的介绍</title>
    <url>/2021/10/31/%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解<span id="more"></span></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>概念 : 说明程序的, 给计算机看</p>
</li>
<li><p>与注释的区别 : 注释是给人看的</p>
</li>
<li><p>定义 : <strong>Java注解</strong>又称<strong>Java标注</strong>，是<a class="link"   href="https://zh.wikipedia.org/wiki/Java" >Java<i class="fas fa-external-link-alt"></i></a>语言<strong>5.0版本</strong>开始支持加入<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81" >源代码<i class="fas fa-external-link-alt"></i></a>的特殊语法<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%85%83%E6%95%B0%E6%8D%AE" >元数据<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3#cite_note-1" >1]<i class="fas fa-external-link-alt"></i></a>。</p>
<p>Java语言中的类、方法、变量、参数和包等都可以被标注。和<a class="link"   href="https://zh.wikipedia.org/wiki/Javadoc" >Javadoc<i class="fas fa-external-link-alt"></i></a>不同，Java标注可以通过反射获取标注内容。在<a class="link"   href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8" >编译器<i class="fas fa-external-link-alt"></i></a>生成<a class="link"   href="https://zh.wikipedia.org/w/index.php?title=%E7%B1%BB%E6%96%87%E4%BB%B6&action=edit&redlink=1" >类文件<i class="fas fa-external-link-alt"></i></a>时，标注可以被嵌入到<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81" >字节码<i class="fas fa-external-link-alt"></i></a>中。<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" >Java虚拟机<i class="fas fa-external-link-alt"></i></a>可以保留标注内容，在运行时可以获取到标注内容[<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3#cite_note-2" >2]<i class="fas fa-external-link-alt"></i></a>。 当然它也支持自定义Java标注[<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3#cite_note-3" >3]<i class="fas fa-external-link-alt"></i></a>。</p>
</li>
<li><p>使用方法 : @ + 注解名称</p>
</li>
<li><p>作用分类 :</p>
<ol>
<li><p>编写文档 : 通过代码里表识的注解生成文档 [生成文档 doc文档] 命令行 javadoc + Java源文件名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解javadoc演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chnysh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算两数之和</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a 整数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> b 整数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 两数之和</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<em>javadoc demo01.java</em></p>
</li>
<li><p>代码分析 : 通过代码里的标识的注解对代码进行分析[使用反射]</p>
</li>
<li><p>编译检查 : 通过代码里标识的注解让编译器能够实现基本的编译检查[<em>@Override</em>]</p>
</li>
</ol>
</li>
</ul>
<h2 id="java中预定义的注解"><a href="#java中预定义的注解" class="headerlink" title="java中预定义的注解"></a>java中预定义的注解</h2><ul>
<li><code>@Override</code> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li><code>@Deprecated</code> - 标记过时方法。如果使用该方法，会报编译警告。</li>
<li><code>@SuppressWarnings</code> - 指示编译器去忽略注解中声明的警告。[@SuppressWarnings(“all”)]</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul>
<li><p>格式 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称()&#123;</span><br><span class="line">    属性列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>本质 : 注解的本质就是一个接口, 该接口默认继承Annotation接口</p>
</li>
<li><p>属性 : 接口中定义的成员方法</p>
<ul>
<li><p>要求:</p>
<ol>
<li><p>属性的返回值类型限制 : </p>
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
<li><p>定义了属性, 在使用注解时需要给其赋值</p>
<ul>
<li>可以使用default关键字给属性默认的初始化值, 这样在使用注解时可以选择不赋值</li>
<li>如果只有一个属性, 且名为 value, 则 value 可以省略, 直接定义值</li>
<li>数组赋值时要使用 {}, 如果数组中只有一个值, 则可以省略 {}</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>元注解 : 用于描述注解的注解</p>
<ul>
<li><p>@Target : 描述注解能够作用的位置</p>
<p>ElementType取值: </p>
<ul>
<li>TYPE : 类</li>
<li>METHOD : 方法</li>
<li>FIELD : 成员变量</li>
</ul>
</li>
<li><p>@Retention : 描述注解被保留的阶段</p>
<p>RetentionPolicy取值</p>
<ul>
<li>SOURCE : 保留在源文件中</li>
<li>CLASS : 保留到字节码中</li>
<li>RUNTIME : 保留到字节码中, 且可以被JVM读取到 </li>
</ul>
</li>
<li><p>@Documented : 描述注解是否被抽取到 api 文档中</p>
</li>
<li><p>@Inherited : 描述注解是否被子类继承</p>
</li>
</ul>
</li>
</ul>
<h2 id="在程序中使用注解-获取注解中定义的属性值"><a href="#在程序中使用注解-获取注解中定义的属性值" class="headerlink" title="在程序中使用注解 : 获取注解中定义的属性值"></a>在程序中使用注解 : 获取注解中定义的属性值</h2><ol>
<li><p>获取注解定义的位置类的字节码文件对象 (Class, Method, Field)</p>
</li>
<li><p>获取需要的注解</p>
<p><code>getAnnotation(Class)</code></p>
</li>
<li><p>调用注解中的抽象方法获取配置的属性值 : <strong>本质是一个实现类实现了抽象方法</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@properties(className = &quot;com.chenysh.domain.Person&quot;, methodName = &quot;eat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">personTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		获取该类的字节码文件对象</span></span><br><span class="line">		Class personTestClass = personTest.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//		获取注解对象</span></span><br><span class="line">		properties anno = (properties) personTestClass.getAnnotation(properties.class);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		使用注解对象的属性</span></span><br><span class="line">		Class aClass = Class.forName(anno.className());</span><br><span class="line">		Object obj = aClass.newInstance();</span><br><span class="line">		Method method = aClass.getMethod(anno.methodName());</span><br><span class="line">		method.invoke(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>大多数只要会使用注解即可</li>
<li>注解不是程序的一部分, 可以理解为一个标签</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MySQL学习</title>
    <url>/2021/10/31/MySQL%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="数据库-DateBase-简介"><a href="#数据库-DateBase-简介" class="headerlink" title="数据库(DateBase)简介"></a>数据库(DateBase)简介<span id="more"></span></h1><ul>
<li><p>数据库的英文单词 : DateBase  简称(DB)</p>
</li>
<li><p>什么是数据库 :</p>
<p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p>
</li>
<li><p>数据库的特点 :</p>
<ol>
<li>持久化存储数据.</li>
<li>方便存储和管理</li>
<li>使用了统一的方式操作数据库 –<strong>SQL</strong></li>
</ol>
</li>
<li><p>MySQL数据库</p>
<ul>
<li><p>MySQL 是一个关系型数据库管理系统, 开源且强大</p>
</li>
<li><p>使用 : </p>
<p>打开与关闭MySQL服务:</p>
<p>​    net start mysql;</p>
<p>​    net stop mysql;</p>
<p>登录与登出 :</p>
<p>​    mysql -u +  用户名 -p + 密码(p与密码中间不能有空格)    </p>
<p>​    exit 或 quit</p>
</li>
</ul>
</li>
</ul>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>简介 : <strong>SQL</strong>，<strong>Structured Query Language:结构化查询语言</strong>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-6" >6]<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-7" >7]<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-8" >8]<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-9" >9]<i class="fas fa-external-link-alt"></i></a>）是一种<a class="link"   href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%AE%9A%E7%9B%AE%E7%9A%84%E7%A8%8B%E5%BC%8F%E8%AF%AD%E8%A8%80" >特定目的编程语言<i class="fas fa-external-link-alt"></i></a>，用于管理<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" >关系数据库管理系统<i class="fas fa-external-link-alt"></i></a>（RDBMS），或在<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" >关系流数据管理系统<i class="fas fa-external-link-alt"></i></a>（RDSMS）中进行流处理。</p>
<ul>
<li><p>通用语法:</p>
<ol>
<li>SQL语句可以单行或多行书写, 以分号结尾.</li>
<li>可使用空格或缩进来提高可读性</li>
<li>SQL语句不区分大小写, 但推荐关键字大写</li>
<li>单行注释 – 或 #</li>
<li>多行注释/* 注释 */</li>
</ol>
</li>
<li><p>SQL分类</p>
<ol>
<li><p><strong>DDL</strong>(DateBase Definition Language) : 数据定义语言</p>
<p>用来定义数据库对象 : 数据库, 表, 列等, 关键字 : create, drop, alter等</p>
</li>
<li><p>DML(DateBase Manipulation Language) : 数据操作语言</p>
<p>用于对数据库中表的数据进行增删改. 关键字 : insert, delete, update等</p>
</li>
<li><p>DQL(DateBase Query Language) : 数据查询语言</p>
<p>用于查询数据库中表的记录(数据). 关键字 : select, where 等</p>
</li>
<li><p>DCL(DateBase Control Language) : 数据控制语言</p>
<p>用于定义数据库中的访问权限和安全级别以及创建用户. 关键字 : GRANT, REVOKE 等 </p>
</li>
</ol>
</li>
</ul>
<h2 id="DDL-操作数据库-表"><a href="#DDL-操作数据库-表" class="headerlink" title="DDL : 操作数据库, 表"></a>DDL : 操作数据库, 表</h2><h3 id="操作数据库-CRUD"><a href="#操作数据库-CRUD" class="headerlink" title="操作数据库 : CRUD"></a>操作数据库 : <strong>CRUD</strong></h3><ul>
<li><p>C(Create) : 创建</p>
<ul>
<li><p>创建数据库</p>
<p><code>create datebase 数据库名称; </code></p>
</li>
<li><p>当数据库不存在时创建数据库</p>
<p><code>create datebase if not exists 数据库名称; </code></p>
</li>
<li><p>当数据库并设定字符集</p>
<p><code>create datebase 数据库名称 character set 字符集名;</code></p>
</li>
</ul>
<p> <code>create datebase if not exists 数据库名称 character set 字符集名;</code></p>
</li>
<li><p>R(Retrieve) : 查询</p>
<ul>
<li><p>查询所有数据库的名称</p>
<p><code>show databases;</code></p>
</li>
<li><p>查询某个数据库的创建语句</p>
<p><code>show create database 数据名称;</code></p>
</li>
</ul>
</li>
<li><p>U(Update) : 修改</p>
<ul>
<li><p>修改字符串的字符集</p>
<p><code>alter database 数据库名称 character set 字符集名称;</code></p>
</li>
</ul>
</li>
<li><p>D(Delete) : 删除</p>
<ul>
<li><p>删除数据库</p>
<p><code>drop datebase 数据库名称; </code></p>
</li>
<li><p>当数据库存在时删除数据库</p>
<p><code>drop datebase if exists 数据库名称; </code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用数据库</p>
<ul>
<li><p>使用数据库</p>
<p><code>use 数据库名称;</code></p>
</li>
<li><p>查询当前正在使用的数据库名称</p>
<p><code>select database();</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="操作表-CRUD"><a href="#操作表-CRUD" class="headerlink" title="操作表 : CRUD"></a>操作表 : <strong>CRUD</strong></h3><ul>
<li><p>C(Create) : 创建</p>
<ol>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    列名<span class="number">1</span> 数据类型,</span><br><span class="line">    列名<span class="number">2</span> 数据类型,</span><br><span class="line">    ...</span><br><span class="line">    列名n 数据类型</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">like</span> 要复制的表名;</span><br></pre></td></tr></table></figure></li>
<li><p>数据类型</p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/sql1.43288dgb5j80.png" alt="sql1"></p>
<p><img src="C:\Users\yoga\AppData\Roaming\Typora\typora-user-images\image-20211031192630420.png" alt="image-20211031192630420"></p>
<p><img src="C:\Users\yoga\AppData\Roaming\Typora\typora-user-images\image-20211031192640110.png" alt="image-20211031192640110"></p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>R(Retrieve) : 查询</p>
<ul>
<li><p>查询某个数据库的所有表的名称</p>
<p><code>show tables;</code></p>
</li>
<li><p>查询表结构</p>
<p><code>desc 表名;</code></p>
</li>
</ul>
</li>
<li><p>U(Update) : 修改</p>
<ul>
<li><p>修改表名</p>
<p><code>alter table 表名 rename to 新表名;</code></p>
</li>
<li><p>修改表的字符集</p>
<p><code>alter table 表名 character set 字符集名;</code></p>
</li>
<li><p>添加一列</p>
<p><code>alter table 表名 add 列名 数据类型;</code></p>
</li>
<li><p>修改列的名称和类型</p>
<ul>
<li><code>alter table 表名 change 列名 新列名 新数据类型;</code></li>
<li><code>alter table 表名 modify 列名 新数据类型;</code></li>
</ul>
</li>
<li><p>删除列</p>
<p><code>alter table 表名 drop 列名;</code></p>
</li>
</ul>
</li>
<li><p>D(Delete) : 删除</p>
<ul>
<li><code>drop table 表名;</code></li>
<li><code>drop table if exists 表名;</code></li>
</ul>
</li>
</ul>
<h2 id="DML-增删改表中数据"><a href="#DML-增删改表中数据" class="headerlink" title="DML : 增删改表中数据"></a>DML : 增删改表中数据</h2><ol>
<li><p>添加数据</p>
<ul>
<li><p>语法 :</p>
<ul>
<li><code>insert into 表名(列名1, 列名2....列名n) vaules(值1, 值2...值n);</code></li>
</ul>
</li>
<li><p>注意事项 :</p>
<ul>
<li><p>列名和值要一一对应</p>
</li>
<li><p>如果表名后不定义列名, 默认给所有列复制</p>
<p><code>insert into 表名 vaules(值1, 值2...值n);</code></p>
</li>
<li><p>除了数字类型, 其他类型需要引号(单双都可以)引起来</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>删除数据</p>
<ul>
<li><p>语法</p>
<p>​    <code>delete from 表名 [where 条件];</code></p>
</li>
<li><p>注意:</p>
<ul>
<li>如果不加条件, 则会删除表中所有记录</li>
<li>删除所有记录的方式<ul>
<li><code>delete from 表名;;</code>  只删除数据不删除表的结构, 且可以回滚</li>
<li><code>truncate 表名;</code> :  只删除数据不删除表的结构, 不可以回滚</li>
<li><code>drop table 表名;</code>: 删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于 该表的存储过程/函数将保留,但是变为 invalid 状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改数据</p>
<ul>
<li><p>语法:</p>
<p><code>update 表名 set 列名1 = 值1, 列名2 = 值2,  ... [where 条件];</code></p>
</li>
<li><p>注意 :</p>
<p>如果不加条件会把所有记录都修改.</p>
</li>
</ul>
</li>
</ol>
<h2 id="DQL-查询表中数据"><a href="#DQL-查询表中数据" class="headerlink" title="DQL : 查询表中数据"></a>DQL : 查询表中数据</h2><ul>
<li><p>语法 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">	分组列表</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">	分组之后的条件</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">	排序</span><br><span class="line">limit</span><br><span class="line">	分页限定</span><br></pre></td></tr></table></figure></li>
<li><p>基础查询</p>
<ul>
<li><p>多个字段的查询</p>
<p><code>select 字段名1, 字段名2, .... from 表名;</code></p>
<p>注意 :  如果要查询所有字段可以用 * 来替代字段列表</p>
</li>
<li><p>去除重复</p>
<p><code>select distinct 字段名1, 字段名2, .... from 表名;</code></p>
</li>
<li><p>计算列</p>
<ul>
<li><p><code>select 字段名1, ifnull(字段名2, 0) + 字段名3, .... from 表名;</code></p>
</li>
<li><p>一般可以使用四则运算计算一些列的值.(一般只进行数值型的运算)</p>
</li>
<li><p><code>ifnull(表达式1, 表达式2);</code>如果表达式1为null, 将返回表达式2, 不然返回表达式</p>
</li>
</ul>
</li>
<li><p>起别名</p>
<p><code>select 字段名1 (as) 别名1, 字段名2 (as) 别名1, .... from 表名;</code>– <strong>as可省略</strong></p>
</li>
</ul>
</li>
<li><p>条件查询</p>
<ul>
<li><code>where 条件;</code></li>
<li>运算符<ul>
<li>‘&gt;’, &lt;, &lt;=. &lt;=, =, &lt;&gt;, !=</li>
<li>between…and…</li>
<li>in(集合)</li>
<li>like<ul>
<li>占位符 :<ul>
<li>_ : 单个任意字符</li>
<li>%: 任意多个字符</li>
</ul>
</li>
</ul>
</li>
<li>is null, is not null</li>
<li>ans / &amp;&amp;</li>
<li>or / ||</li>
<li>not / !</li>
</ul>
</li>
</ul>
</li>
<li><p>排序查询</p>
<ul>
<li><p>语法 : </p>
<p><code>order by 排序字段1 排序方式1, 排序字段2 排序方式2, .... </code></p>
</li>
<li><p>排序方式 : </p>
<ul>
<li>ASC : 升序(default)</li>
<li>DESC : 降序. </li>
</ul>
</li>
<li><p>注意 : </p>
<p>排序优先级有先后之分, 只有前面的一样时才会比较后面的</p>
</li>
</ul>
</li>
<li><p>聚合函数 : 将一列数据进行计算</p>
<ul>
<li><p>语法 : </p>
<p><code>select 函数名(列名) from 表名;</code></p>
</li>
<li><p>count : 计算个数</p>
<ul>
<li>一般选择非空的列 : 主键</li>
</ul>
</li>
<li><p>max : 计算最大值</p>
</li>
<li><p>min : 计算最小值</p>
</li>
<li><p>sum : 计算和</p>
</li>
<li><p>avg : 计算平均值</p>
</li>
<li><p>聚合函数默认排除null值</p>
<ul>
<li>解决方案 : <ol>
<li>选择非空的列</li>
<li>ifnull函数 </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分组查询 : </p>
<ul>
<li><p>语法 :</p>
<p><code>group by 分组字段;</code></p>
</li>
<li><p>注意 : </p>
<ol>
<li>分组之后查询字段 : 分组字段, 聚合函数1,  聚合函数2, …</li>
<li>where 与 having 的区别<ul>
<li>where 在分组之前进行限定, 如果不满足条件, 则不会参与分组</li>
<li>having 在分组之后进行限定, 如果不满足条件, 则不会被查询出来<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	sex, <span class="built_in">count</span>(id) num, <span class="built_in">avg</span>(math) </span><br><span class="line">	<span class="keyword">from</span> student </span><br><span class="line">	<span class="keyword">where</span> english <span class="operator">&gt;</span> <span class="number">70</span> </span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span> sex </span><br><span class="line">	<span class="keyword">having</span> num <span class="operator">&gt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>分页查询</p>
<ul>
<li><p>语法 : </p>
<p><code>imit 开始的索引, 每页显示的条数;</code></p>
</li>
<li><p>开始的索引 = (要查询的页码 - 1) * 每页显示的条数;</p>
</li>
<li><p>只在MySQL中可用</p>
</li>
</ul>
</li>
</ul>
<h2 id="DCL-管理用户-授权"><a href="#DCL-管理用户-授权" class="headerlink" title="DCL : 管理用户, 授权"></a>DCL : 管理用户, 授权</h2><ol>
<li><p>管理用户</p>
<ol>
<li><p>添加用户 : </p>
<ul>
<li>语法 :<code> CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></li>
</ul>
</li>
<li><p>删除用户 :</p>
<ul>
<li>语法 : <code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
<li><p>修改用户密码 :</p>
<ul>
<li><code>UPDATE USER SET PASSWORD = PASSWORD(新密码) WHERE USER = &#39;用户名&#39;;</code></li>
<li><code>SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD = PASSWORD(新密码);</code></li>
</ul>
</li>
<li><p>查询用户 :</p>
<ol>
<li><p>切换到mysql数据库</p>
</li>
<li><p>查询 user 表</p>
</li>
</ol>
<ul>
<li>通配符 : % 表示可以在任意主机上使用用户登录数据库</li>
</ul>
</li>
</ol>
</li>
<li><p>授权</p>
<ol>
<li><p>查询权限 :</p>
<p><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
<li><p>授予权限</p>
<p><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
<p>ALL 代表所有权限或所有库</p>
</li>
<li><p>撤销权限</p>
<p><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
</ol>
</li>
</ol>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul>
<li><p>概念 :  对表中数据进行限定, 保证数据的准确性, 有效性和完整性.</p>
</li>
<li><p>分类 : </p>
<ol>
<li><p>主键约束 : primary key</p>
<ul>
<li><p>注意 :</p>
<ol>
<li>含义 : 非空且唯一.</li>
<li>一张表只能有一个主键</li>
<li>主键就是表中记录的唯一标识</li>
</ol>
</li>
<li><p>创建时添加约束</p>
<p><code>列名1 数据类型 PRIMARY KEY</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 PRIMARY KEY;</code></p>
</li>
<li><p>删除约束</p>
<p><code>ALTER TABLE 表名 DROP PRIMARY KEY;</code></p>
</li>
<li><p>自动增长</p>
<ul>
<li><p>概念 : 如果一列是数据类型的, 使用 auto_increment可以完成值的自dongle增长(从上一行的值增加)</p>
</li>
<li><p>创建时添加自动增长</p>
<p><code>列名1 数据类型 AUTO_INCREMENT</code></p>
</li>
<li><p>创建后添加自动增长</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 AUTO_INCREMENT;</code></p>
</li>
<li><p>删除自动增长</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型;</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>非空约束 : not null</p>
<ul>
<li><p>创建时添加约束</p>
<p><code>列名1 数据类型 NOT NULL</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 NOT NULL;</code></p>
</li>
<li><p>删除约束</p>
<p>  <code>ALTER TABLE 表名 MODIFY 列名 新数据类型;</code></p>
</li>
</ul>
</li>
<li><p>唯一约束 : unique</p>
<ul>
<li><p>创建时添加约束</p>
<p><code>列名1 数据类型 UNIQUE</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 UNIQUE;</code></p>
</li>
<li><p>删除约束</p>
<p><code>ALTER TABLE 表名 DROP INDEX 列名;</code></p>
</li>
</ul>
</li>
<li><p>外键约束 : foreign key</p>
<ul>
<li><p>创建时添加约束</p>
<p><code>constraint 外键名称 foreign key (外键列名称) reference 主表名称(主表列名称)</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名称 ADD constraint 外键名称 foreign key (外键列名称) reference 主表名称(主表列名称);</code></p>
</li>
<li><p>删除约束</p>
<p><code>ALTER TABLE 表名称 DROP FOREIGN KEY 外键名称;</code></p>
</li>
<li><p>级联操作</p>
<ul>
<li>语法 : <code>constraint 外键名称 foreign key (外键列名称) reference 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE</code></li>
<li>分类 :<ol>
<li>级联更新 : ON UPDATE CASCADE</li>
<li>级联删除 : ON DELETE CASCADE`</li>
</ol>
</li>
<li>注意 : 要谨慎使用</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><ol>
<li><p>多表之间的关系</p>
<ol>
<li><p>分类</p>
<ol>
<li>一对一 : e.g : 人和身份证</li>
<li>一对多 (多对一) : e.g : 部门和员工</li>
<li>多对多 :  e.g : 学生和课程</li>
</ol>
</li>
<li><p>实现方式 :</p>
<ol>
<li><p>一对一 : </p>
<p>在任意一方添加<strong>唯一</strong>外键指向另一方的主键.</p>
</li>
<li><p>一对多(多对一) :</p>
<p>在多的一方建立外键指向一的一方.</p>
</li>
<li><p>多对多 :</p>
<p>借助第三张中间表, 中间表至少包含两个字段, 分别指向两张表的主键</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据库的设计范式 :</p>
<ul>
<li><p>概念 :设计关系<a class="link"   href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728" >数据库<i class="fas fa-external-link-alt"></i></a>时，遵从不同的规范<a class="link"   href="https://baike.baidu.com/item/%E8%A6%81%E6%B1%82/3598753" >要求<i class="fas fa-external-link-alt"></i></a>，设计出合理的<a class="link"   href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/8999831" >关系型数据库<i class="fas fa-external-link-alt"></i></a>，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>
<p><a class="link"   href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/1237340" >关系数据库<i class="fas fa-external-link-alt"></i></a>有六种范式：第一范式（1NF）、第二范式（2NF）、<a class="link"   href="https://baike.baidu.com/item/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F/3193798" >第三范式<i class="fas fa-external-link-alt"></i></a>（3NF）、巴斯-科德范式（BCNF）、<a class="link"   href="https://baike.baidu.com/item/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F/3193985" >第四范式<i class="fas fa-external-link-alt"></i></a>(4NF）和<a class="link"   href="https://baike.baidu.com/item/%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F/5025271" >第五范式<i class="fas fa-external-link-alt"></i></a>（5NF，又称完美范式）。</p>
</li>
<li><p>前置知识 :</p>
<ol>
<li>函数依赖 : A –&gt; B, 如果通过A属性(属性组)的值, 可以唯一确定唯一B属性的值, 则称B依赖于A</li>
<li>完全函数依赖 : A –&gt; B, 如果要唯一确定B属性的值, 要借助A属性组的<strong>所有值</strong>, 则称B依赖于A</li>
<li>部分函数依赖 : A –&gt; B, 如果要唯一确定B属性的值, <strong>只</strong>要借助A属性组的<strong>部分值</strong>, 则称B依赖于A</li>
<li>传递函数依赖 : A–&gt; B, B –&gt; C, 如果B依赖于A, C依赖于B, 则称C依赖于A.</li>
<li>码 : 如果在一张表中, 一个属性(属性组)被<strong>其他所有</strong>属性完全依赖, 则称这个属性(属性组)为该表的码</li>
</ol>
</li>
<li><p>分类 :</p>
<ol>
<li><p>第一范式 (1NF) : </p>
<p>数据库表的每一列都是不可分割的原子数据项</p>
</li>
<li><p>第二范式 (2NF) : </p>
<p>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上<strong>消除</strong>非主属性对主码的<strong>部分函数依赖</strong>.</p>
</li>
<li><p>第三范式 (3NF) : </p>
<p>在2NF基础上，任何非主<a class="link"   href="https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7" >属性<i class="fas fa-external-link-alt"></i></a>不依赖于其它非主属性（在2NF基础上<strong>消除传递依赖</strong>）</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="数据库的备份与还原"><a href="#数据库的备份与还原" class="headerlink" title="数据库的备份与还原"></a>数据库的备份与还原</h2><ol>
<li><p>命令行 :</p>
<ul>
<li>语法 :<ol>
<li>备份 : mysqldump -u用户名 -p密码 要备份的数据库名 &gt; 保存的路径</li>
<li>还原 :<ol>
<li>登录数据库</li>
<li>创建数据库</li>
<li>使用数据库</li>
<li>执行文件<code>source 文件路径;</code><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>查询语法 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	表名列表;</span><br></pre></td></tr></table></figure></li>
<li><p>笛卡尔积 : </p>
<p>笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尔积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员 </p>
</li>
<li><p>分类 :</p>
<ul>
<li><p>内连接查询</p>
<ol>
<li>隐式内连接 : 使用 where 条件 来清除无用的数据</li>
<li>显示内连接 : <ul>
<li>语法 : <code>select 字段列表 from 表名1 [inner] join 表名2 on 条件;</code></li>
<li>查询两表的交集部分</li>
</ul>
</li>
<li>明确要求 :<ol>
<li>要从那些表中查询数据</li>
<li>条件是什么</li>
<li>要查询哪些字段</li>
</ol>
</li>
</ol>
</li>
<li><p>外连接查询</p>
<ol>
<li>左外连接 : <ul>
<li>语法 : <code>select 字段列表 from 表名1 left [outer] join 表名2 on 条件;</code></li>
<li>查询的是左表的所有数据以及其交集部分</li>
</ul>
</li>
<li>右外连接<ul>
<li>语法 : <code>select 字段列表 from 表名1 right [outer] join 表名2 on 条件;</code></li>
<li>查询的是右表的所有数据以及其交集部分</li>
</ul>
</li>
</ol>
</li>
<li><p>子查询</p>
<ul>
<li><p>概念 : 在查询中嵌套查询, 则称嵌套查询为子查询.</p>
</li>
<li><p>子查询的不同种情况 :</p>
<ol>
<li><p>子查询的结果是单行单列的 :</p>
<p>子查询可以作为条件, 使用运算符(&gt;, &lt;, =…)进行判断</p>
</li>
<li><p>子查询的结果是单行多列的 :</p>
<p>子查询可以作为条件, 使用运算符 <em>in</em> 进行判断</p>
</li>
<li><p>子查询的结果是多行多列的 :</p>
<p>子查询可以作为一张虚拟表参与查询</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ol>
<li><p>事务的基本介绍</p>
<ol>
<li><p>概念 :</p>
<ul>
<li>如果一个包含多个步骤的业务操作, 被事务管理, 那么这些操作要么同时成功, 要么同时失败.</li>
</ul>
</li>
<li><p>操作 :</p>
<ol>
<li><p>开启事务 : <code>start transaction;</code></p>
</li>
<li><p>回滚 :<code>roll back;</code></p>
</li>
<li><p>提交 : <code>commit;</code></p>
</li>
<li><p>MySQL数据库中事务默认自动提交</p>
<ul>
<li>事务提交的两种方式<ol>
<li>自动提交 : 一条DML(增删改)语句会自动提交一次事务</li>
<li>手动提交 : 需要先开启事务再提交, Oracle数据库默认手动提交</li>
</ol>
</li>
<li>修改事务的默认提交方式 :<ul>
<li>查看事务的默认提交方式 : <code>SELECT @@autocommit;</code>– 0为手动, 1为自动</li>
<li>修改事务的默认提交方式 : <code>SET @@autocommit = 0;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>事务的四大特征 :</p>
<ol>
<li>原子性 : 是不可分割的最小操作单位, 要么同时成功, 要么同时失败</li>
<li>持久性 : 当事务提交或回滚后, 数据库会持久化的保留数据.</li>
<li>隔离性 : 多个事务之间相互独立</li>
<li>一致性 : 事务操作前后, 数据总量不变</li>
</ol>
</li>
<li><p>事务的隔离级别</p>
<ul>
<li><p>概念 : 如果多个事务同时操作同一批数据,, 则会引发一些问题, 需要设置不同的隔离级别来解决这些问题</p>
</li>
<li><p>存在问题种类 :</p>
<ol>
<li>脏读 : 一个事务读取到另一个事务没有提交的数据</li>
<li>不可重复读(虚读) : 在同一个事务中, 两次读取到的数据不一样 </li>
<li>幻读 : 一个事务操作(DML)数据表中所有数据, 另一个事务添加了一条数据, 则第一个事务查询不到自己的修改.</li>
</ol>
</li>
<li><p>隔离级别</p>
<ol>
<li>read uncommitted : 读未提交<ul>
<li>产生的问题 : 脏读, 虚读,幻读</li>
</ul>
</li>
<li>read commited : 读已提交(Oracle默认级别)<ul>
<li>产生的问题 : 虚读,幻读</li>
</ul>
</li>
<li>repeatable read : 可重复读(MySQL默认级别)<ul>
<li>产生的问题 :幻读</li>
</ul>
</li>
<li>serializable : 串行化<ul>
<li>可以解决所有问题</li>
</ul>
</li>
</ol>
<ul>
<li><p>注意 : 隔离级别安全性越高, 效率越低</p>
</li>
<li><p>数据库查询隔离级别</p>
<p><code>select @@tx_isolation;</code></p>
</li>
<li><p>数据库设置隔离级别</p>
<p><code>select global transaction isolation level 级别字符串;</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>JDBC学习</title>
    <url>/2021/11/01/JDBC%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><ol>
<li><p>概念 : JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API<span id="more"></span>，可以为多种关系数据库提供统一访问，它由一组用<a class="link"   href="https://link.jianshu.com/?t=https://baike.baidu.com/item/Java%E8%AF%AD%E8%A8%80" >Java语言<i class="fas fa-external-link-alt"></i></a>编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。</p>
</li>
<li><p>快速入门:</p>
<ul>
<li><p>步骤 :</p>
<ol>
<li>导入驱动 jar 包</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql</li>
<li>获取执行 sql 语句的对象 Statement</li>
<li>执行sql, 接受返回结果</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
</li>
<li><p>代码实现 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		1. 导入驱动 jar 包</span></span><br><span class="line"><span class="comment">//		2. 注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//		3. 获取数据库连接对象 Connection</span></span><br><span class="line">		Connection condition = DriverManager.getConnection(</span><br><span class="line">				<span class="string">&quot;jdbc:mysql://localhost:3306/school&quot;</span>,</span><br><span class="line">				<span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//		4. 定义sql</span></span><br><span class="line">		String sql = <span class="string">&quot;update teacher set name = &#x27;chen&#x27; where id = 2&quot;</span>;</span><br><span class="line"><span class="comment">//		5. 获取执行 sql 语句的对象 Statement</span></span><br><span class="line">		Statement statement = condition.createStatement();</span><br><span class="line"><span class="comment">//		6. 执行sql, 接受返回结果</span></span><br><span class="line">		<span class="keyword">int</span> count = statement.executeUpdate(sql);</span><br><span class="line"><span class="comment">//		7. 处理结果</span></span><br><span class="line">		System.out.println(count);</span><br><span class="line"><span class="comment">//		8. 释放资源</span></span><br><span class="line">		statement.close();</span><br><span class="line">		condition.close();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li></li>
</ol>
]]></content>
  </entry>
</search>
