<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start<span id="more"></span></h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.25</title>
    <url>/2021/10/25/leetcode10-25/</url>
    <content><![CDATA[<p>题目:</p>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。<br><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii">链接</a></li>
</ul>
<h2 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路<span id="more"></span></h2><p>一开始我的思路就是通过两次二分找到答案,然后发现不行,因为二分不能直接找到答案所在的行;</p>
<p>所以我换了一个思路,先找到答案所在的行的区间再二分:</p>
<ol>
<li><strong>通过二分来找到行的上边界和下边界</strong></li>
<li><strong>对每一行进行二分搜索</strong></li>
</ol>
<p>具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;<span class="comment">// 开始寻找下边界</span></span><br><span class="line">        <span class="keyword">int</span> end = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;<span class="comment">// 找到左边界小于target的行</span></span><br><span class="line">                end = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> begin = -<span class="number">1</span>;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = end;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][m - <span class="number">1</span>] &gt;= target) &#123;<span class="comment">// 找到右边界打于target的行</span></span><br><span class="line">                begin = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;<span class="comment">// 对每一行二分</span></span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][mid] &lt; target) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][mid] &gt; target) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可是看了题解之后发现这个方法也不太行</p>
<h2 id="题解的思路"><a href="#题解的思路" class="headerlink" title="题解的思路:"></a>题解的思路:</h2><ol>
<li><p>从矩阵的右上角matrix[x] [y] (x = 0,  y = m - 1)开始查找, 答案就<strong>限定在matrix[x] [y]和matrix[n - 1] [0]之间</strong></p>
</li>
<li><p>如果matrix[x] [y] &gt; target, 说明 y 列都大于 target, 故<strong>应将y减一进行移动</strong></p>
</li>
<li><p>同理, 如果matrix[x] [y] &lt; target, 说明 x 行都大于 target, 故<strong>应将x加一进行移动</strong></p>
</li>
<li><p>如果 x, y 越界, 则找不到target, 应返回false</p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; n &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] &gt; target) &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Markdown学习</title>
    <url>/2021/10/25/Markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习<span id="more"></span></h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>hello, world!</p>
<p><strong>hello, world!</strong>(ctrl + b)</p>
<p><em>hello, world!</em>( ctrl + i)</p>
<p><em><strong>hello, world!</strong></em></p>
<p><del>hello, world!</del></p>
<p> <u>hello, world!</u> (ctrl + u)</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p><strong>学习要持之以恒                                                                                                                            -范佳兴</strong></p>
</blockquote>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
<hr>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="C:\Users\yoga\Pictures\asoul\珈乐\b025eb04fd5d728925d31da409ab25c764d3e815.jpg@1320w_1600h.webp" alt="截图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ischenysh/images@master/%E5%A4%B4%E5%83%8F.5afo5fhm0nc0.webp" alt="头像"></p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a class="link"   href="https://ischenysh.github.io/" >点击跳转到个人博客<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol>
<li>A</li>
<li>B</li>
<li>C</li>
</ol>
<ul>
<li>A</li>
<li>B</li>
<li>C</li>
</ul>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>姓名</th>
<th>性别</th>
<th>生日</th>
</tr>
</thead>
</table>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">psvm</span><br></pre></td></tr></table></figure>

<p><code>psvm</code></p>
]]></content>
  </entry>
  <entry>
    <title>多线程与并发</title>
    <url>/2021/10/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发<span id="more"></span></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="普通方法调用与多线程的区别"><a href="#普通方法调用与多线程的区别" class="headerlink" title="普通方法调用与多线程的区别:"></a>普通方法调用与多线程的区别:</h3><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B1.4ztxbzdar4w0.png" alt="多线程1"></p>
<h3 id="进程-Process-与线程-Thread-的区别"><a href="#进程-Process-与线程-Thread-的区别" class="headerlink" title="进程(Process)与线程(Thread)的区别"></a>进程(Process)与线程(Thread)的区别</h3><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E9%A1%B9%E7%A8%8B2.5xsngvti8vo0.png" alt="多项程2"></p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B4.2bfyewdz96f4.png" alt="多线程4"></p>
<ul>
<li><strong>NEW</strong> (新建)</li>
<li><strong>RUNNABLE</strong>(可运行)</li>
<li><strong>BLOCKED</strong>(阻塞)</li>
<li><strong>WAITING</strong>(等待)</li>
<li><strong>TIMED_WAITING</strong>(计时等待)</li>
<li><strong>TERMINATED</strong>(终止)</li>
</ul>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B3.2sjqzrq4id40.png" alt="多线程3"></p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">// 创建子线程对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> ThreadTest().start();<span class="comment">// 创建匿名对象并开启线程</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子类继承Thread类具有多线程能力</li>
<li>启动线程:子类对象.start()</li>
<li><strong>不建议使用:避免OOP单继承局限性</strong></li>
</ul>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadTest2()).start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现接口Runnable具有多线程能力</li>
<li>启动线程:传入目标对象+Thread对象.start()</li>
<li><strong>推荐使用:避免单继承局限性,灵活方便,方便同一个对象被多个线程使用</strong></li>
</ul>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;<span class="comment">// 实现Callable接口</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 重写call()方法, 有返回值且类型与Callable&lt;&gt;的尖括号中一样</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">		ThreadTest3 task1 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ThreadTest3 task2 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ThreadTest3 task3 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ExecutorService service = Executors.newCachedThreadPool();<span class="comment">// 创建服务</span></span><br><span class="line">        <span class="comment">// Future用于接受结果或结束任务, submit方法用于提交任务, 服务会将其并入线程池</span></span><br><span class="line">		Future&lt;Boolean&gt; ans1 = service.submit(task1);</span><br><span class="line">		Future&lt;Boolean&gt; ans2 = service.submit(task2);</span><br><span class="line">		Future&lt;Boolean&gt; ans3 = service.submit(task3);</span><br><span class="line">		System.out.println(ans1.get());<span class="comment">// 输出得到的结果</span></span><br><span class="line">		System.out.println(ans2.get());</span><br><span class="line">		System.out.println(ans3.get());</span><br><span class="line">		service.shutdown();<span class="comment">// 关闭服务</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>实现Callable接口, 需要返回值类型</p>
</li>
<li><p>重写call方法, 需要抛出异常</p>
</li>
<li><p>创建目标对象</p>
</li>
<li><p>创建执行服务:<code>ExecutorService service = Executors.newCachedThreadPool();</code></p>
</li>
<li><p>提交执行:<code>Future&lt;Boolean&gt; ans1 = service.submit(task1);</code></p>
</li>
<li><p>获取结果:<code>ans1.get()</code></p>
</li>
<li><p>关闭服务:<code>service.shutdown();</code></p>
<h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenyusheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Marry you = <span class="keyword">new</span> You();</span><br><span class="line">		<span class="keyword">new</span> WeddingCompany(you).HappyMarry();</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;我好开心!&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要结婚啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	Marry person;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry person)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.person = person;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;准备婚礼&quot;</span>);</span><br><span class="line">		person.HappyMarry();</span><br><span class="line">		System.out.println(<span class="string">&quot;收拾现场&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>真实对象和代理对象都要<strong>实现一个接口</strong></p>
</li>
<li><p>代理对象要<strong>代理</strong>真实角色</p>
</li>
</ul>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>代理对象可以做很多真实对象做不了的事情</li>
<li>真实对象<strong>专注做自己的事情</strong></li>
</ul>
<h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>setPriority(int newPriority)</code></td>
<td align="center">更改线程的优先级</td>
</tr>
<tr>
<td align="center"><code>static void sleep(long millis)</code></td>
<td align="center">在指定的毫秒数内让当前正在执行的线程休眠</td>
</tr>
<tr>
<td align="center"><code>void join()</code></td>
<td align="center">等待该线程终止</td>
</tr>
<tr>
<td align="center"><code>static void yield()</code></td>
<td align="center">暂停当前正在执行的线程对象, 并执行其他线程</td>
</tr>
<tr>
<td align="center"><code>void interrupt()</code></td>
<td align="center">设置线程中断标志为true</td>
</tr>
<tr>
<td align="center"><code>boolean isAlive</code></td>
<td align="center">测试线程是否处于活动状态</td>
</tr>
<tr>
<td align="center"><code>Thread.State getState()</code></td>
<td align="center">获取当前线程状态</td>
</tr>
<tr>
<td align="center"><code>static boolean Thread.Interrpted()</code></td>
<td align="center">获取当前线程的中断标志并清除标志</td>
</tr>
<tr>
<td align="center"><code>boolean isInterrupted()</code></td>
<td align="center">获取线程的中断标志但不会清除标志</td>
</tr>
</tbody></table>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><h3 id="使用标志位退出-正常退出"><a href="#使用标志位退出-正常退出" class="headerlink" title="使用标志位退出,正常退出"></a>使用标志位退出,正常退出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopTest1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">// 设置标志位</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadStopTest1 task = <span class="keyword">new</span> ThreadStopTest1();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">		task.flag = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用interrupt方法打断线程"><a href="#使用interrupt方法打断线程" class="headerlink" title="使用interrupt方法打断线程"></a>使用interrupt方法打断线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">// 判断线程的中断标志</span></span><br><span class="line">			<span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程被打断了, 拜拜!&quot;</span> </span><br><span class="line">                                   + <span class="string">&quot;中断标志 &quot;</span> </span><br><span class="line">                                   + Thread.currentThread().isInterrupted());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程被打断了, 拜拜!&quot;</span> </span><br><span class="line">                                   + <span class="string">&quot;中断标志 &quot;</span> </span><br><span class="line">                                   + Thread.currentThread().isInterrupted());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				sleep(<span class="number">200</span>);<span class="comment">// 如果在睡眠中被打断, 将会抛出InterruptedException异常</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				System.out.println(<span class="string">&quot;线程在睡眠中被打断了, 拜拜!&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStopTest2());</span><br><span class="line">		thread.start();</span><br><span class="line">		sleep(<span class="number">2000</span>);</span><br><span class="line">		thread.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一般写法"><a href="#一般写法" class="headerlink" title="一般写法"></a>一般写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = ()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep or wait</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clean up, <span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果每次工作迭代后都使用sleep()方法(或其他可中断方法), 则无需进行中断状态的检查, 因为在休眠中被打断,它会清除中断状态并抛出 <strong>InterruptedException</strong> 异常.代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = ()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">            Thread.sleep(delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clean up, <span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h2><p><code>static void yield</code></p>
<p><strong>静态方法</strong>, 使当前线程从运行状态变为<strong>就绪状态</strong>,让 cpu <strong>重新调度</strong>.</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p><code>thread.setDaemon(true)</code></p>
<p>将一个线程转换为守护线程, <strong>用户线程默认为 false</strong>, 用途是<strong>为其他线程提供服务</strong>, 如计时器, <strong>当只剩下守护线程时, 程序将会结束</strong></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="使用-Lock-Condition-结构"><a href="#使用-Lock-Condition-结构" class="headerlink" title="使用 Lock/Condition 结构"></a>使用 Lock/Condition 结构</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构:"></a>基本结构:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myLock.lock();<span class="comment">// 一个锁对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    myLock.unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>这个结构能够保证任何时刻只有一个线程能够进入临界区, 一旦一个线程锁定了锁对象, 其他任何线程都无法通过lock语句, 当其他线程调用lock时, 他们会暂停, 直到第一个线程释放这个锁对象.</p>
</li>
<li><p><strong>一个对象定义一个锁对象,</strong> 当两个线程操作两个对象时, 两个线程都不会阻塞</p>
</li>
</ul>
<h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><ul>
<li><p>当线程进入临界区后发现只有满足某个条件后它才能执行, 此时可以使用一个<strong>条件对象</strong>来管理这些线程</p>
</li>
<li><p>通过锁对象调用Condition方法<code>lock.newCondition()</code>来创建一个条件对象, 当线程不满足运行条件就通过条件对象来调用await方法<code>condition.await()</code><strong>将该线程暂停并放弃锁</strong><strong>, 该线程将进入这个条件的等待集(wait set), 当锁可用时, 该线程并不会变成可运行状态, 直到另一个线程在</strong>同一条件**下调用<code>signAll</code>方法<code>condition.signAll()</code>.</p>
</li>
<li><p><code>signAll()</code>方法会重新激活等待这个条件的所有线程, 将他们从等待集中移出, 它们再次变成可运行的线程, 当锁再次可用时, 他们中的某个线程将<strong>从<code>await()</code>调用中返回</strong>, 从<strong>暂停的地方继续执行</strong>.</p>
</li>
<li><p>此时, 线程应再次测试条件, <strong>不能保证现在一定满足条件-</strong>—-<code>signAll()</code>方法仅仅是通知等待的线程:</p>
<p><strong>现在有可能满足条件, 值得再次检查</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!OK to proceed) &#123;</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>死锁(deadlock)现象</strong>:所有线程都阻塞, 程序永远无法继续运行</li>
</ul>
<p>程序实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span>[] account;<span class="comment">// 银行账户</span></span><br><span class="line">	<span class="keyword">private</span> Lock lock;<span class="comment">// 锁对象</span></span><br><span class="line">	<span class="keyword">private</span> Condition sufficientFunds;<span class="comment">// 条件对象</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">double</span> initAmount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.account = <span class="keyword">new</span> <span class="keyword">double</span>[size];</span><br><span class="line">		Arrays.fill(<span class="keyword">this</span>.account, initAmount);</span><br><span class="line">		lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">		sufficientFunds = lock.newCondition();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从一个账户向另一个账户转账</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> from 转帐的一方</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> to 收钱的一方</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> amount 转账数额</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (account[from] &lt; amount) &#123;</span><br><span class="line">				sufficientFunds.await();<span class="comment">// 当余额不足时, 线程挂起</span></span><br><span class="line">			&#125;</span><br><span class="line">			account[from] -= amount;</span><br><span class="line">			account[to] += amount;</span><br><span class="line">			System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">					<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">			sufficientFunds.signalAll();<span class="comment">// 账户余额变更后应通知所有该条件的等待线程</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获得银行总资产</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 银行总资产</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalAsset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">double</span> e : account) &#123;</span><br><span class="line">				total += e;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> total;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USERSIZE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADSIZE = <span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAY = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> INITAMOUNT = <span class="number">10000.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bank bank = <span class="keyword">new</span> Bank(USERSIZE, INITAMOUNT);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADSIZE; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">						<span class="keyword">int</span> from = (<span class="keyword">int</span>) (Math.random() * USERSIZE);</span><br><span class="line">						<span class="keyword">int</span> to = (<span class="keyword">int</span>) (Math.random() * USERSIZE);</span><br><span class="line">						<span class="keyword">if</span> (from == to) &#123;</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">double</span> amount = Math.random() * INITAMOUNT;</span><br><span class="line">						bank.transfer(from, to, amount);</span><br><span class="line">						Thread.sleep(DELAY);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用-synchronized-关键字"><a href="#使用-synchronized-关键字" class="headerlink" title="使用 synchronized 关键字"></a>使用 synchronized 关键字</h3><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>Java中每一个对象都有一个对象内部锁, 当一个方法被声明为同步方法时, 对象内部锁将会保护整个方法</p>
<p>即:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		method body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		method body</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部对象锁只有一个关联对象, <code>wait()</code>方法将线程添加到等待集中, <code>notifyAll()</code>/<code>notify()</code>方法可以解除等待线程的阻塞,调用<code>wait()</code>方法和<code>notifyAll()</code>等价于调用:<br><code>intrinsicContition.await();</code><br><code>intrinsicContition.signalAll();</code></p>
<p>使用 synchronized 关键字的 transfer 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (account[from] &lt; amount) &#123;</span><br><span class="line">		wait();</span><br><span class="line">	&#125;</span><br><span class="line">	account[from] -= amount;</span><br><span class="line">	account[to] += amount;</span><br><span class="line">	System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">			<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">	notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul>
<li>最好不使用上面两种方法, 在大部分的情况下使用java.util.concurrent包中的某种机制就可以解决所有的锁定问题(<strong>不会用</strong>, <strong>笑嘻了</strong>)</li>
<li>如果使用 synchronized 关键字就可以满足你的需求, 就使用它, 因为可以让代码变得简洁</li>
<li>如果实在需要Lock/Condition 结构的额外能力才使用它</li>
</ul>
<h3 id="使用同步块"><a href="#使用同步块" class="headerlink" title="使用同步块"></a>使用同步块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;<span class="comment">// 获得该对象的锁</span></span><br><span class="line">	critical section<span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 同步块的 transfer 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Vector&lt;Double&gt; accounts, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (accounts) &#123;</span><br><span class="line">       	accounts.set(from, accounts.get(from) - amount);</span><br><span class="line">		accounts.set(to  , accounts.get(to  ) + amount);</span><br><span class="line">       &#125;</span><br><span class="line">	System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">			<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-volatile-关键字"><a href="#使用-volatile-关键字" class="headerlink" title="使用 volatile 关键字"></a>使用 volatile 关键字</h3><p>将一个实例字段声明为为 volatile , 可以保证该字段的修改对所有线程可见, 但由于不能保证其原子性, 故不能对其进行非原子的操作, 最好只进行赋值和读取.</p>
<p>具体可以查询<a class="link"   href="https://blog.csdn.net/u012723673/article/details/80682208?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163531427216780271545094%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163531427216780271545094&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80682208.first_rank_v2_pc_rank_v29&utm_term=volatile&spm=1018.2226.3001.4187" >Java volatile关键字最全总结<i class="fas fa-external-link-alt"></i></a>)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.26_496.下一个更大元素I</title>
    <url>/2021/10/27/leetcode10-26-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</url>
    <content><![CDATA[<p>题目如下<span id="more"></span></p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/leetcode10.26.nbf6kkpd9y8.png" alt="leetcode10"></p>
<h1 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h1><p>暴力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">boolean</span> isFound = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nums2[j] == nums1[i]) &#123;</span><br><span class="line">					index = j;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (nums2[j] &gt; nums1[i] &amp;&amp; index &lt; j) &#123;</span><br><span class="line">					ans[i] = nums2[j];</span><br><span class="line">					isFound = <span class="keyword">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!isFound) &#123;</span><br><span class="line">				ans[i] = -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题解真的牛逼, 麻了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> n = nums2.length;</span><br><span class="line">		stack.push(nums2[n - <span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 逆序遍历</span></span><br><span class="line">			<span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[i]) &#123;</span><br><span class="line">				stack.pop();<span class="comment">// pop栈中所有小于当前元素的值</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">				map.put(nums2[i], stack.peek());<span class="comment">// 如果栈不为空则右边存在比该元素大的值</span></span><br><span class="line">			&#125;</span><br><span class="line">			stack.push(nums2[i]);<span class="comment">// 存入当前元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">			num1[i] = map.getOrDefault(nums1[i], -<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逆序遍历 nums2 数组, 栈中只允许存在比当前元素大的元素, 则栈顶元素就为当前元素右边大于该元素的第一个元素, 如果栈为空则右边不存在比该元素大的元素, 用哈希表存储该答案,最后将当前元素push进去;</li>
<li>获取结果:遍历 nums1 数组, 将哈希表存储的答案写入</li>
<li>stack永远单调</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.28.869.重新排序得到 2 的幂</title>
    <url>/2021/10/28/leetcode10-28-869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0-2-%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述<span id="more"></span></h1><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/leedcode10.28.6hb3dzhwkeo0.png" alt="leedcode10"></p>
<h1 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路:"></a>个人思路:</h1><ul>
<li><p>利用递归加回溯进行全排列, </p>
</li>
<li><p>判断是否合法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归加回溯</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2_1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] nums = String.valueOf(n).toCharArray();</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">		<span class="keyword">return</span> dfs(nums, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((current &amp; (current - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vis.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[i] || (index == <span class="number">0</span> &amp;&amp; nums[i] == <span class="string">&#x27;0&#x27;</span>) || (i != <span class="number">0</span> &amp;&amp; !vis[i - <span class="number">1</span>] &amp;&amp; nums[i - <span class="number">1</span>] == nums[i])) &#123;<span class="comment">// 如果本次已经选中过相同的数字,就continue(!vis[i - 1] &amp;&amp; nums[i - 1] == nums[i])</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[i] = <span class="keyword">true</span>;</span><br><span class="line">			ans |= dfs(nums, index + <span class="number">1</span>, current * <span class="number">10</span> + nums[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			vis[i] = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路:"></a>题解思路:</h1><p>预处理加哈希表</p>
<ul>
<li><p>如果 a 和 b 重新排列后,都是同一个 2 的幂, 那么他们每个数字出现的次数应该相同,</p>
</li>
<li><p>利用这个结论我们可以将 1 到1e9 之间的 2 的幂的每个数字出现的次数转化成字符串全部存到set中.</p>
</li>
<li><p>查询即可</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_2</span> </span>&#123;</span><br><span class="line">	Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		init();<span class="comment">// 初始化</span></span><br><span class="line">		<span class="keyword">return</span> set.contains(numsCount(n));<span class="comment">// 查询</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">// 将 1 到1e9 之间的 2 的幂的每个数字出现的次数转化成字符串全部存到set中.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e9</span>; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			set.add(numsCount(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">numsCount</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;<span class="comment">// 每个数字出现的次数转化成字符串</span></span><br><span class="line">		<span class="keyword">int</span>[] numsCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			numsCount[num % <span class="number">10</span>]++;</span><br><span class="line">			num /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(numsCount);</span><br><span class="line">		<span class="keyword">return</span> String.valueOf(numsCount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Java 流</title>
    <url>/2021/10/28/Java-%E6%B5%81/</url>
    <content><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="从迭代到流的操作"><a href="#从迭代到流的操作" class="headerlink" title="从迭代到流的操作"></a>从迭代到流的操作</h2><p>当处理集合时, 我们通常会迭代它的元素, 并在每个元素上执行某项操作. </p>
<p>例如, 假设我们想要对某本书的所有长单词进行计数.首先, 将所有单词放到一个列表里:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String contents = <span class="keyword">new</span> String(</span><br><span class="line">				Files.readAllBytes(path), StandardCharsets.UTF_8);</span><br><span class="line">List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));<span class="comment">// 以非字母的字符为分隔符</span></span><br></pre></td></tr></table></figure>

<p>如果使用迭代:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String e : words) &#123;</span><br><span class="line">	<span class="keyword">if</span> (e.length() &gt; <span class="number">12</span>) &#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用流:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.Stream().filter(e -&gt; e.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>

<p>仅将<code>Stream</code>改为<code>parallelStream</code>就可以让流库以并行方式执行过滤和计数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.parallelStream().filter(e -&gt; e.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>

<h3 id="流与集合的差距"><a href="#流与集合的差距" class="headerlink" title="流与集合的差距"></a>流与集合的差距</h3><ul>
<li>流不存储元素, 这些元素可能存储在底层的集合中, 或者按需生成.</li>
<li>流的操作不会改变其数据源. 例如, <code>filter</code>方法不会从流中移除元素, 而是产生一个新的流, 其中不包含被过滤掉的元素</li>
<li>流的操作时尽可能惰性执行的, 这意味着直至需要结果时,操作才会执行,</li>
</ul>
<p>示例解释:</p>
<p><code>Stream</code>和<code>parallelStream</code>方法会产生一个用于 words 列表的 stream . <code>filter</code>方法会返回另一个流, 其中只包含长度大于12的单词. count 方法会将这个流化简为一个结果.</p>
<h3 id="操作流时的典型流程"><a href="#操作流时的典型流程" class="headerlink" title="操作流时的典型流程"></a>操作流时的典型流程</h3><ol>
<li>创建一个流.</li>
<li>指定将初始流转换成其他流的中间操作, 可能包含多个步骤.</li>
<li>引用停止操作, 从而产生结果, 这个操作会强制执行之前的惰性操作, 从此之后, 这个流就不能用了</li>
</ol>
<p>实例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wordCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountLongWord</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String contents = <span class="keyword">new</span> String(</span><br><span class="line">				Files.readAllBytes(path), StandardCharsets.UTF_8);</span><br><span class="line">		List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));<span class="comment">// 以非字母的字符为分隔符</span></span><br><span class="line">		<span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (String e : words) &#123;</span><br><span class="line">			<span class="keyword">if</span> (e.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		count = words.stream().filter(e -&gt; e.length() &gt; <span class="number">5</span>).count();</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		count = words.parallelStream().filter(e -&gt; e.length() &gt; <span class="number">5</span>).count();</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		CountLongWord(Paths.get(<span class="string">&quot;D:\\Documents\\blog\\themes\\hexo-theme-keep\\languages\\en.yml&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>java io流</title>
    <url>/2021/10/28/java-io%E6%B5%81-0/</url>
    <content><![CDATA[<h1 id="IO概念"><a href="#IO概念" class="headerlink" title="IO概念"></a>IO概念</h1><ul>
<li>I/O 即输入Input/Output的缩写, 其实就是计算机调度吧吧各个存储中(包括内存和外存)的数据写入写出的过程;<span id="more"></span></li>
<li>java中用”流(stream)”来抽象表示这么一个写入写出的功能,封装成一个”类”, 都放在java.io这个包里面.</li>
</ul>
<h1 id="“流”是什么"><a href="#“流”是什么" class="headerlink" title="“流”是什么"></a>“流”是什么</h1><p>通过”流”的形式允许java程序通过使用相同的方式来访问不同的输入/输出源. stream是从起源(source)到接收的(sink)的有序数据. 如果把输入/输出源对比成’水桶’, 那么流就是”管道”, 这个”管道”的粗细, 单向性等属性也就是区分了不同”流”的特性.</p>
<h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ol>
<li><p>按照流的方向(输入输出都是站在程序所在内存的角度划分的)</p>
<ul>
<li>输入流:只能从中读取数据[主要由InputStream和Reader作为基类]</li>
<li>输出流:只能先其写入数据[主要由outputStream和Writer作为基类]</li>
</ul>
</li>
<li><p>按照流的操作颗粒度划分</p>
<ul>
<li>字节流: 以字节为单元, 可操作任何数据[主要由InputStream和OutputStream作为基类]</li>
<li>字符流: 以字符为单元, 只能操作纯字符数据, 比较方便[主要由Reader和Writer作为基类]</li>
</ul>
</li>
<li><p>按照六点角色划分</p>
<ul>
<li>节点流: 可以从/向一个特定的IO设备(如磁盘, 网络) 读/写 数据的流, 也叫[低级流, 主要流]</li>
<li>处理流: 用于对一个已存在的流进行封装, 通过封装后的流来实现数据的 读/写 功能, 也叫[高级流]</li>
</ul>
</li>
</ol>
<h1 id="流的原理以及一共有多少IO流"><a href="#流的原理以及一共有多少IO流" class="headerlink" title="流的原理以及一共有多少IO流"></a>流的原理以及一共有多少IO流</h1><h2 id="流的原理解析"><a href="#流的原理解析" class="headerlink" title="流的原理解析"></a>流的原理解析</h2><blockquote>
<p>流想象成”水管”, 源端和目的端就是两个’水桶’, 数据是通过这个”水管”进行流动传输的, 以”InputStream”和Reader为例, 水管的每个”水滴”就是具体的数据, 如果是字节流, 那么一个”水滴”就是一个字节, 如果是字符流, 那么一个”水滴”就是一个字符</p>
</blockquote>
<p>当创建一个流对象的时候, 如<code>fis = new FileInputstream(&quot;...\xx\xx.txt&quot;)</code>, 记录指针表示当前正准备从哪个”水滴”开始读取, 每当程序从InputStream或者Reader里面取出一个或多个”水滴”后, 记录指针自定向后移动; 除此之外, InputStream和Reader里面都提供了一些方法来控制记录指针的移动.如果是处理流的话, 就相当于在这个”水管”上面装了一些”控制阀门”, 最终用户只要关心”阀门”具备的能力就行.</p>
<h2 id="java中所有流汇总"><a href="#java中所有流汇总" class="headerlink" title="java中所有流汇总"></a>java中所有流汇总</h2><p>java.io种子类中有40个”流”类, 表格如下</p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/IO1.1645xmt3farg.png" alt="IO1"></p>
<h1 id="常见IO流的实战"><a href="#常见IO流的实战" class="headerlink" title="常见IO流的实战"></a>常见IO流的实战</h1><h2 id="访问操作文件-FileInputStream-FileReader-FileOutStream-FileWriter"><a href="#访问操作文件-FileInputStream-FileReader-FileOutStream-FileWriter" class="headerlink" title="访问操作文件(FileInputStream/FileReader, FileOutStream/FileWriter)"></a>访问操作文件(FileInputStream/FileReader, FileOutStream/FileWriter)</h2><ol>
<li><p>使用FileInputStream, 从文件中读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileInputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">null</span>;<span class="comment">// 使用FileInputStream</span></span><br><span class="line"><span class="comment">//      FileReader in = null;// 使用FileReader</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);<span class="comment">// 使用FileInputStream</span></span><br><span class="line"><span class="comment">//			in = new FileReader(&quot;D:\\Documents\\logs\\java0.log&quot;);// 使用FileReader</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;文件未找到, 程序退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line">			in.close();</span><br><span class="line">			System.out.println(<span class="string">&quot;共读取了&quot;</span> + len + <span class="string">&quot;个字节&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常, 程序退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用输出流, 往文件中写数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileOutputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//		FileInputStream in = null;</span></span><br><span class="line">		FileReader in = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//		FileOutputStream out = null;</span></span><br><span class="line">		FileWriter out = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//			in = new FileInputStream(&quot;D:\\Documents\\logs\\java0.log&quot;);</span></span><br><span class="line">			in = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);</span><br><span class="line"><span class="comment">//			out = new FileOutputStream(&quot;D:\\Documents\\logs\\java1.log&quot;);</span></span><br><span class="line">			out = <span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\Documents\\logs\\java1.log&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;不存在该文件,程序即将退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				out.write(b);</span><br><span class="line">			&#125;</span><br><span class="line">			in.close();</span><br><span class="line">			out.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常, 程序即将退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;文件复制完成!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="缓存流的使用-BufferedInputStream-BuffereOutputStream-BufferedReader-BufferedWriter"><a href="#缓存流的使用-BufferedInputStream-BuffereOutputStream-BufferedReader-BufferedWriter" class="headerlink" title="缓存流的使用(BufferedInputStream/BuffereOutputStream, BufferedReader/BufferedWriter)"></a>缓存流的使用(BufferedInputStream/BuffereOutputStream, BufferedReader/BufferedWriter)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">		FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">		BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">		BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);</span><br><span class="line">			fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\Documents\\logs\\java1.log&quot;</span>);</span><br><span class="line">			bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">			bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((off = bis.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				bos.write(buffer, <span class="number">0</span>, off);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;文件复制完成&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			bis.close();</span><br><span class="line">			bos.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换流的使用-InputStreamReader-OutputStreamReader"><a href="#转换流的使用-InputStreamReader-OutputStreamReader" class="headerlink" title="转换流的使用(InputStreamReader/OutputStreamReader)"></a>转换流的使用(InputStreamReader/OutputStreamReader)</h2><p>将字节流转化成字符流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\Documents\\logs\\java2.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (line.equals(<span class="string">&quot;over&quot;</span>))&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			bw.write(line);</span><br><span class="line">			bw.newLine();</span><br><span class="line">			bw.flush();<span class="comment">// 刷新字符输出流</span></span><br><span class="line">		&#125;</span><br><span class="line">		br.close();</span><br><span class="line">		bw.close();<span class="comment">// 关闭前必须刷新</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>对象流就是一种特殊的处理流, 也是在基础的字节流上封装.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectOutputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Person ming = <span class="keyword">new</span> Person(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">15</span>);</span><br><span class="line">			FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\Documents\\logs\\java3.txt&quot;</span>);</span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">			oos.writeObject(ming);</span><br><span class="line">			FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java3.txt&quot;</span>);</span><br><span class="line">			ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">			Person p2 = (Person) ois.readObject();</span><br><span class="line">			System.out.println(p2);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			oos.flush();</span><br><span class="line">			oos.close();</span><br><span class="line">			ois.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;<span class="comment">// 对象必须实现序列化接口</span></span><br><span class="line">	<span class="keyword">private</span> String name = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节数据流的使用（ByteArrayInputStream-ByteArrayOutputStream）【通常结合数据流DataInputStream-DataOutputStream】"><a href="#字节数据流的使用（ByteArrayInputStream-ByteArrayOutputStream）【通常结合数据流DataInputStream-DataOutputStream】" class="headerlink" title="字节数据流的使用（ByteArrayInputStream/ByteArrayOutputStream）【通常结合数据流DataInputStream/DataOutputStream】"></a>字节数据流的使用（ByteArrayInputStream/ByteArrayOutputStream）【通常结合数据流DataInputStream/DataOutputStream】</h2><ul>
<li>为了提高效率, 避免频繁的读写文件, 于是出现了字节数组流, 因为存放在内存中, 所以也被称为”内存流”; 字节数组流也是一种节点流;</li>
<li>数据处理流是一种处理流, 用于针对数据类型传输处理的, 一般用于序列化与反序列化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDateStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">// 创建字节数组, 同时会在内存中创建数组</span></span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);<span class="comment">// 将字节数组流封装成数据处理流</span></span><br><span class="line">		DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			dos.writeDouble(Math.random());</span><br><span class="line">			dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">			ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">			System.out.println(bais.available());</span><br><span class="line"></span><br><span class="line">			dis = <span class="keyword">new</span> DataInputStream(bais);</span><br><span class="line">			System.out.println(dis.readDouble());</span><br><span class="line">			System.out.println(dis.readBoolean());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			dos.close();</span><br><span class="line">			dis.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>junit入门</title>
    <url>/2021/10/31/junit%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="junit单元测试"><a href="#junit单元测试" class="headerlink" title="junit单元测试"></a>junit单元测试<span id="more"></span></h1><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><ul>
<li>黑盒测试 : 不关注具体的代码实现, 只需要关注能否得到正确结果</li>
<li>白盒测试 : 不只要关注能否得到正确结果, 还要关注具体的代码实现</li>
</ul>
<h2 id="junit使用"><a href="#junit使用" class="headerlink" title="junit使用"></a>junit使用</h2><ul>
<li><p>步骤</p>
<ol>
<li><p>定义一个测试类(测试用例)</p>
<p>建议:</p>
<ul>
<li>测试类名 : 被测试的类 + Test</li>
<li>包名 : 与被测试的类所在的包同级, 且取名为test <img src="https://raw.githubusercontent.com/ischenysh/images/master/junit.2wcf1jwyhj60.png" alt="junit"></li>
</ul>
</li>
<li><p>定义测试方法 : <strong>可以独立运行</strong></p>
<p>建议:</p>
<ul>
<li>方法名 : test + 被测试的方法名</li>
<li>返回值 : void</li>
<li>参数列表 : 空参</li>
</ul>
</li>
</ol>
<ol start="3">
<li>给方法前加 <em>@test</em> 注解</li>
<li>导入junit 依赖环境</li>
</ol>
</li>
<li><p>判定结果</p>
<ul>
<li>红色 : 失败</li>
<li>绿色 : 成功</li>
<li>一般会使用断言操作</li>
</ul>
</li>
<li><p>补充</p>
<ul>
<li><p><em>@Before</em> :</p>
<p>被注解的方法总是在测试方法之前执行</p>
</li>
<li><p><em>@After</em> :</p>
<p>被注解的方法总是在测试方法之后执行</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.junit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a - b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chenysh.junit.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Calculator calculator;</span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		一般用于申请资源, 总是在test方法执行之前执行</span></span><br><span class="line">		calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">		System.out.println(<span class="string">&quot;我被初始化啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/**test使用规范:</span></span><br><span class="line"><span class="comment">   *总是返回null</span></span><br><span class="line"><span class="comment">   *无参数传入</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = calculator.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		Assert.assertEquals(result, <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = calculator.sub(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		Assert.assertEquals(result, -<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@After</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		一般用于清理资源, 总是在test方法执行之后执行, 不管test方法有没有正常执行完成</span></span><br><span class="line">		System.out.println(<span class="string">&quot;我被清理啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>反射入门</title>
    <url>/2021/10/31/%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="反射-框架设计的灵魂"><a href="#反射-框架设计的灵魂" class="headerlink" title="反射 : 框架设计的灵魂"></a>反射 : 框架设计的灵魂<span id="more"></span></h1><ul>
<li><p>框架 : 半成品软件, 可以在框架的基础上进行软件开发, 简化编码</p>
</li>
<li><p>反射 : 将类的各个组成部分封装为其他对象</p>
<p>​    好处:</p>
<ul>
<li><p>可以在程序运行过程中操作这些对象</p>
</li>
<li><p>可以解耦, 增强程序的拓展性</p>
</li>
</ul>
</li>
</ul>
<h2 id="获取class-对象的方式"><a href="#获取class-对象的方式" class="headerlink" title="获取class 对象的方式"></a>获取class 对象的方式</h2><ol>
<li><p><code>Class.forName(&quot;全类名&quot;)</code> : 将字节码加载进内存, 返回 class 对象</p>
<p>多用于配置文件, 使类名定义在配置文件中; 通过读取文件来加载类</p>
</li>
<li><p><code>类名.class</code> : 通过类名的属性 class 获取</p>
<p>用于参数的传递</p>
</li>
<li><p><code>对象.getClass()</code> : getClass() 方法定义在 Object 类中</p>
<p>多用于对象的获取字节码的方式</p>
</li>
<li><p>结论 : </p>
<p>同一个字节码文件(*.class)在一次程序运行过程中只会被加载一次, 所有方式获取的Class对象都是同一个</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class class1 = Class.forName(<span class="string">&quot;com.chenysh.reflect.Person&quot;</span>);</span><br><span class="line">		Class class2 = Person.class;</span><br><span class="line">		Class class3 = <span class="keyword">new</span> Person().getClass();</span><br><span class="line">		System.out.println(class1.equals(class2));</span><br><span class="line">		System.out.println(class2.equals(class3));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
