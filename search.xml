<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start<span id="more"></span></h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.25</title>
    <url>/2021/10/25/leetcode10-25/</url>
    <content><![CDATA[<p>题目:</p>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。<br><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii">链接</a></li>
</ul>
<h2 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路<span id="more"></span></h2><p>一开始我的思路就是通过两次二分找到答案,然后发现不行,因为二分不能直接找到答案所在的行;</p>
<p>所以我换了一个思路,先找到答案所在的行的区间再二分:</p>
<ol>
<li><strong>通过二分来找到行的上边界和下边界</strong></li>
<li><strong>对每一行进行二分搜索</strong></li>
</ol>
<p>具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;<span class="comment">// 开始寻找下边界</span></span><br><span class="line">        <span class="keyword">int</span> end = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;<span class="comment">// 找到左边界小于target的行</span></span><br><span class="line">                end = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> begin = -<span class="number">1</span>;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = end;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][m - <span class="number">1</span>] &gt;= target) &#123;<span class="comment">// 找到右边界打于target的行</span></span><br><span class="line">                begin = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;<span class="comment">// 对每一行二分</span></span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][mid] &lt; target) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][mid] &gt; target) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可是看了题解之后发现这个方法也不太行</p>
<h2 id="题解的思路"><a href="#题解的思路" class="headerlink" title="题解的思路:"></a>题解的思路:</h2><ol>
<li><p>从矩阵的右上角matrix[x] [y] (x = 0,  y = m - 1)开始查找, 答案就<strong>限定在matrix[x] [y]和matrix[n - 1] [0]之间</strong></p>
</li>
<li><p>如果matrix[x] [y] &gt; target, 说明 y 列都大于 target, 故<strong>应将y减一进行移动</strong></p>
</li>
<li><p>同理, 如果matrix[x] [y] &lt; target, 说明 x 行都大于 target, 故<strong>应将x加一进行移动</strong></p>
</li>
<li><p>如果 x, y 越界, 则找不到target, 应返回false</p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; n &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] &gt; target) &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Markdown学习</title>
    <url>/2021/10/25/Markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习<span id="more"></span></h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>hello, world!</p>
<p><strong>hello, world!</strong>(ctrl + b)</p>
<p><em>hello, world!</em>( ctrl + i)</p>
<p><em><strong>hello, world!</strong></em></p>
<p><del>hello, world!</del></p>
<p> <u>hello, world!</u> (ctrl + u)</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p><strong>学习要持之以恒                                                                                                                            -范佳兴</strong></p>
</blockquote>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
<hr>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="C:\Users\yoga\Pictures\asoul\珈乐\b025eb04fd5d728925d31da409ab25c764d3e815.jpg@1320w_1600h.webp" alt="截图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ischenysh/images@master/%E5%A4%B4%E5%83%8F.5afo5fhm0nc0.webp" alt="头像"></p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a class="link"   href="https://ischenysh.github.io/" >点击跳转到个人博客<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol>
<li>A</li>
<li>B</li>
<li>C</li>
</ol>
<ul>
<li>A</li>
<li>B</li>
<li>C</li>
</ul>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>姓名</th>
<th>性别</th>
<th>生日</th>
</tr>
</thead>
</table>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">psvm</span><br></pre></td></tr></table></figure>

<p><code>psvm</code></p>
]]></content>
  </entry>
  <entry>
    <title>多线程与并发</title>
    <url>/2021/10/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发<span id="more"></span></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="普通方法调用与多线程的区别"><a href="#普通方法调用与多线程的区别" class="headerlink" title="普通方法调用与多线程的区别:"></a>普通方法调用与多线程的区别:</h3><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B1.4ztxbzdar4w0.png" alt="多线程1"></p>
<h3 id="进程-Process-与线程-Thread-的区别"><a href="#进程-Process-与线程-Thread-的区别" class="headerlink" title="进程(Process)与线程(Thread)的区别"></a>进程(Process)与线程(Thread)的区别</h3><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E9%A1%B9%E7%A8%8B2.5xsngvti8vo0.png" alt="多项程2"></p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B4.2bfyewdz96f4.png" alt="多线程4"></p>
<ul>
<li><strong>NEW</strong> (新建)</li>
<li><strong>RUNNABLE</strong>(可运行)</li>
<li><strong>BLOCKED</strong>(阻塞)</li>
<li><strong>WAITING</strong>(等待)</li>
<li><strong>TIMED_WAITING</strong>(计时等待)</li>
<li><strong>TERMINATED</strong>(终止)</li>
</ul>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B3.2sjqzrq4id40.png" alt="多线程3"></p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">// 创建子线程对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> ThreadTest().start();<span class="comment">// 创建匿名对象并开启线程</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子类继承Thread类具有多线程能力</li>
<li>启动线程:子类对象.start()</li>
<li><strong>不建议使用:避免OOP单继承局限性</strong></li>
</ul>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadTest2()).start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现接口Runnable具有多线程能力</li>
<li>启动线程:传入目标对象+Thread对象.start()</li>
<li><strong>推荐使用:避免单继承局限性,灵活方便,方便同一个对象被多个线程使用</strong></li>
</ul>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;<span class="comment">// 实现Callable接口</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 重写call()方法, 有返回值且类型与Callable&lt;&gt;的尖括号中一样</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">		ThreadTest3 task1 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ThreadTest3 task2 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ThreadTest3 task3 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">		ExecutorService service = Executors.newCachedThreadPool();<span class="comment">// 创建服务</span></span><br><span class="line">        <span class="comment">// Future用于接受结果或结束任务, submit方法用于提交任务, 服务会将其并入线程池</span></span><br><span class="line">		Future&lt;Boolean&gt; ans1 = service.submit(task1);</span><br><span class="line">		Future&lt;Boolean&gt; ans2 = service.submit(task2);</span><br><span class="line">		Future&lt;Boolean&gt; ans3 = service.submit(task3);</span><br><span class="line">		System.out.println(ans1.get());<span class="comment">// 输出得到的结果</span></span><br><span class="line">		System.out.println(ans2.get());</span><br><span class="line">		System.out.println(ans3.get());</span><br><span class="line">		service.shutdown();<span class="comment">// 关闭服务</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>实现Callable接口, 需要返回值类型</p>
</li>
<li><p>重写call方法, 需要抛出异常</p>
</li>
<li><p>创建目标对象</p>
</li>
<li><p>创建执行服务:<code>ExecutorService service = Executors.newCachedThreadPool();</code></p>
</li>
<li><p>提交执行:<code>Future&lt;Boolean&gt; ans1 = service.submit(task1);</code></p>
</li>
<li><p>获取结果:<code>ans1.get()</code></p>
</li>
<li><p>关闭服务:<code>service.shutdown();</code></p>
<h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenyusheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Marry you = <span class="keyword">new</span> You();</span><br><span class="line">		<span class="keyword">new</span> WeddingCompany(you).HappyMarry();</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;我好开心!&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要结婚啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	Marry person;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry person)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.person = person;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;准备婚礼&quot;</span>);</span><br><span class="line">		person.HappyMarry();</span><br><span class="line">		System.out.println(<span class="string">&quot;收拾现场&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>真实对象和代理对象都要<strong>实现一个接口</strong></p>
</li>
<li><p>代理对象要<strong>代理</strong>真实角色</p>
</li>
</ul>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>代理对象可以做很多真实对象做不了的事情</li>
<li>真实对象<strong>专注做自己的事情</strong></li>
</ul>
<h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>setPriority(int newPriority)</code></td>
<td align="center">更改线程的优先级</td>
</tr>
<tr>
<td align="center"><code>static void sleep(long millis)</code></td>
<td align="center">在指定的毫秒数内让当前正在执行的线程休眠</td>
</tr>
<tr>
<td align="center"><code>void join()</code></td>
<td align="center">等待该线程终止</td>
</tr>
<tr>
<td align="center"><code>static void yield()</code></td>
<td align="center">暂停当前正在执行的线程对象, 并执行其他线程</td>
</tr>
<tr>
<td align="center"><code>void interrupt()</code></td>
<td align="center">设置线程中断标志为true</td>
</tr>
<tr>
<td align="center"><code>boolean isAlive</code></td>
<td align="center">测试线程是否处于活动状态</td>
</tr>
<tr>
<td align="center"><code>Thread.State getState()</code></td>
<td align="center">获取当前线程状态</td>
</tr>
<tr>
<td align="center"><code>static boolean Thread.Interrpted()</code></td>
<td align="center">获取当前线程的中断标志并清除标志</td>
</tr>
<tr>
<td align="center"><code>boolean isInterrupted()</code></td>
<td align="center">获取线程的中断标志但不会清除标志</td>
</tr>
</tbody></table>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><h3 id="使用标志位退出-正常退出"><a href="#使用标志位退出-正常退出" class="headerlink" title="使用标志位退出,正常退出"></a>使用标志位退出,正常退出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopTest1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">// 设置标志位</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadStopTest1 task = <span class="keyword">new</span> ThreadStopTest1();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">		task.flag = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用interrupt方法打断线程"><a href="#使用interrupt方法打断线程" class="headerlink" title="使用interrupt方法打断线程"></a>使用interrupt方法打断线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">// 判断线程的中断标志</span></span><br><span class="line">			<span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程被打断了, 拜拜!&quot;</span> </span><br><span class="line">                                   + <span class="string">&quot;中断标志 &quot;</span> </span><br><span class="line">                                   + Thread.currentThread().isInterrupted());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程被打断了, 拜拜!&quot;</span> </span><br><span class="line">                                   + <span class="string">&quot;中断标志 &quot;</span> </span><br><span class="line">                                   + Thread.currentThread().isInterrupted());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				sleep(<span class="number">200</span>);<span class="comment">// 如果在睡眠中被打断, 将会抛出InterruptedException异常</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				System.out.println(<span class="string">&quot;线程在睡眠中被打断了, 拜拜!&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStopTest2());</span><br><span class="line">		thread.start();</span><br><span class="line">		sleep(<span class="number">2000</span>);</span><br><span class="line">		thread.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一般写法"><a href="#一般写法" class="headerlink" title="一般写法"></a>一般写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = ()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep or wait</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clean up, <span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果每次工作迭代后都使用sleep()方法(或其他可中断方法), 则无需进行中断状态的检查, 因为在休眠中被打断,它会清除中断状态并抛出 <strong>InterruptedException</strong> 异常.代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = ()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">            Thread.sleep(delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clean up, <span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h2><p><code>static void yield</code></p>
<p><strong>静态方法</strong>, 使当前线程从运行状态变为<strong>就绪状态</strong>,让 cpu <strong>重新调度</strong>.</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p><code>thread.setDaemon(true)</code></p>
<p>将一个线程转换为守护线程, <strong>用户线程默认为 false</strong>, 用途是<strong>为其他线程提供服务</strong>, 如计时器, <strong>当只剩下守护线程时, 程序将会结束</strong></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="使用-Lock-Condition-结构"><a href="#使用-Lock-Condition-结构" class="headerlink" title="使用 Lock/Condition 结构"></a>使用 Lock/Condition 结构</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构:"></a>基本结构:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myLock.lock();<span class="comment">// 一个锁对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    myLock.unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>这个结构能够保证任何时刻只有一个线程能够进入临界区, 一旦一个线程锁定了锁对象, 其他任何线程都无法通过lock语句, 当其他线程调用lock时, 他们会暂停, 直到第一个线程释放这个锁对象.</p>
</li>
<li><p><strong>一个对象定义一个锁对象,</strong> 当两个线程操作两个对象时, 两个线程都不会阻塞</p>
</li>
</ul>
<h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><ul>
<li><p>当线程进入临界区后发现只有满足某个条件后它才能执行, 此时可以使用一个<strong>条件对象</strong>来管理这些线程</p>
</li>
<li><p>通过锁对象调用Condition方法<code>lock.newCondition()</code>来创建一个条件对象, 当线程不满足运行条件就通过条件对象来调用await方法<code>condition.await()</code><strong>将该线程暂停并放弃锁</strong><strong>, 该线程将进入这个条件的等待集(wait set), 当锁可用时, 该线程并不会变成可运行状态, 直到另一个线程在</strong>同一条件**下调用<code>signAll</code>方法<code>condition.signAll()</code>.</p>
</li>
<li><p><code>signAll()</code>方法会重新激活等待这个条件的所有线程, 将他们从等待集中移出, 它们再次变成可运行的线程, 当锁再次可用时, 他们中的某个线程将<strong>从<code>await()</code>调用中返回</strong>, 从<strong>暂停的地方继续执行</strong>.</p>
</li>
<li><p>此时, 线程应再次测试条件, <strong>不能保证现在一定满足条件-</strong>—-<code>signAll()</code>方法仅仅是通知等待的线程:</p>
<p><strong>现在有可能满足条件, 值得再次检查</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!OK to proceed) &#123;</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>死锁(deadlock)现象</strong>:所有线程都阻塞, 程序永远无法继续运行</li>
</ul>
<p>程序实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span>[] account;<span class="comment">// 银行账户</span></span><br><span class="line">	<span class="keyword">private</span> Lock lock;<span class="comment">// 锁对象</span></span><br><span class="line">	<span class="keyword">private</span> Condition sufficientFunds;<span class="comment">// 条件对象</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">double</span> initAmount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.account = <span class="keyword">new</span> <span class="keyword">double</span>[size];</span><br><span class="line">		Arrays.fill(<span class="keyword">this</span>.account, initAmount);</span><br><span class="line">		lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">		sufficientFunds = lock.newCondition();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从一个账户向另一个账户转账</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> from 转帐的一方</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> to 收钱的一方</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> amount 转账数额</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (account[from] &lt; amount) &#123;</span><br><span class="line">				sufficientFunds.await();<span class="comment">// 当余额不足时, 线程挂起</span></span><br><span class="line">			&#125;</span><br><span class="line">			account[from] -= amount;</span><br><span class="line">			account[to] += amount;</span><br><span class="line">			System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">					<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">			sufficientFunds.signalAll();<span class="comment">// 账户余额变更后应通知所有该条件的等待线程</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获得银行总资产</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 银行总资产</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalAsset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">double</span> e : account) &#123;</span><br><span class="line">				total += e;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> total;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USERSIZE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADSIZE = <span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAY = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> INITAMOUNT = <span class="number">10000.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bank bank = <span class="keyword">new</span> Bank(USERSIZE, INITAMOUNT);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADSIZE; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">						<span class="keyword">int</span> from = (<span class="keyword">int</span>) (Math.random() * USERSIZE);</span><br><span class="line">						<span class="keyword">int</span> to = (<span class="keyword">int</span>) (Math.random() * USERSIZE);</span><br><span class="line">						<span class="keyword">if</span> (from == to) &#123;</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">double</span> amount = Math.random() * INITAMOUNT;</span><br><span class="line">						bank.transfer(from, to, amount);</span><br><span class="line">						Thread.sleep(DELAY);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用-synchronized-关键字"><a href="#使用-synchronized-关键字" class="headerlink" title="使用 synchronized 关键字"></a>使用 synchronized 关键字</h3><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>Java中每一个对象都有一个对象内部锁, 当一个方法被声明为同步方法时, 对象内部锁将会保护整个方法</p>
<p>即:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		method body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		method body</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部对象锁只有一个关联对象, <code>wait()</code>方法将线程添加到等待集中, <code>notifyAll()</code>/<code>notify()</code>方法可以解除等待线程的阻塞,调用<code>wait()</code>方法和<code>notifyAll()</code>等价于调用:<br><code>intrinsicContition.await();</code><br><code>intrinsicContition.signalAll();</code></p>
<p>使用 synchronized 关键字的 transfer 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (account[from] &lt; amount) &#123;</span><br><span class="line">		wait();</span><br><span class="line">	&#125;</span><br><span class="line">	account[from] -= amount;</span><br><span class="line">	account[to] += amount;</span><br><span class="line">	System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">			<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">	notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul>
<li>最好不使用上面两种方法, 在大部分的情况下使用java.util.concurrent包中的某种机制就可以解决所有的锁定问题(<strong>不会用</strong>, <strong>笑嘻了</strong>)</li>
<li>如果使用 synchronized 关键字就可以满足你的需求, 就使用它, 因为可以让代码变得简洁</li>
<li>如果实在需要Lock/Condition 结构的额外能力才使用它</li>
</ul>
<h3 id="使用同步块"><a href="#使用同步块" class="headerlink" title="使用同步块"></a>使用同步块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;<span class="comment">// 获得该对象的锁</span></span><br><span class="line">	critical section<span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 同步块的 transfer 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Vector&lt;Double&gt; accounts, <span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (accounts) &#123;</span><br><span class="line">       	accounts.set(from, accounts.get(from) - amount);</span><br><span class="line">		accounts.set(to  , accounts.get(to  ) + amount);</span><br><span class="line">       &#125;</span><br><span class="line">	System.out.printf(<span class="string">&quot;client %2d transferred client %2d %8.2f dollar.\n&quot;</span> +</span><br><span class="line">			<span class="string">&quot;Total asset : % 10.2f\n&quot;</span>, from, to, amount, getTotalAsset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-volatile-关键字"><a href="#使用-volatile-关键字" class="headerlink" title="使用 volatile 关键字"></a>使用 volatile 关键字</h3><p>将一个实例字段声明为为 volatile , 可以保证该字段的修改对所有线程可见, 但由于不能保证其原子性, 故不能对其进行非原子的操作, 最好只进行赋值和读取.</p>
<p>具体可以查询<a class="link"   href="https://blog.csdn.net/u012723673/article/details/80682208?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163531427216780271545094%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163531427216780271545094&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80682208.first_rank_v2_pc_rank_v29&utm_term=volatile&spm=1018.2226.3001.4187" >Java volatile关键字最全总结<i class="fas fa-external-link-alt"></i></a>)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.26_496.下一个更大元素I</title>
    <url>/2021/10/27/leetcode10-26-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I/</url>
    <content><![CDATA[<p>题目如下<span id="more"></span></p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/leetcode10.26.nbf6kkpd9y8.png" alt="leetcode10"></p>
<h1 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h1><p>暴力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">boolean</span> isFound = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nums2[j] == nums1[i]) &#123;</span><br><span class="line">					index = j;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (nums2[j] &gt; nums1[i] &amp;&amp; index &lt; j) &#123;</span><br><span class="line">					ans[i] = nums2[j];</span><br><span class="line">					isFound = <span class="keyword">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!isFound) &#123;</span><br><span class="line">				ans[i] = -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题解真的牛逼, 麻了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> n = nums2.length;</span><br><span class="line">		stack.push(nums2[n - <span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 逆序遍历</span></span><br><span class="line">			<span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[i]) &#123;</span><br><span class="line">				stack.pop();<span class="comment">// pop栈中所有小于当前元素的值</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">				map.put(nums2[i], stack.peek());<span class="comment">// 如果栈不为空则右边存在比该元素大的值</span></span><br><span class="line">			&#125;</span><br><span class="line">			stack.push(nums2[i]);<span class="comment">// 存入当前元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">			num1[i] = map.getOrDefault(nums1[i], -<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逆序遍历 nums2 数组, 栈中只允许存在比当前元素大的元素, 则栈顶元素就为当前元素右边大于该元素的第一个元素, 如果栈为空则右边不存在比该元素大的元素, 用哈希表存储该答案,最后将当前元素push进去;</li>
<li>获取结果:遍历 nums1 数组, 将哈希表存储的答案写入</li>
<li>stack永远单调</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>leetcode10.28.869.重新排序得到 2 的幂</title>
    <url>/2021/10/28/leetcode10-28-869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0-2-%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述<span id="more"></span></h1><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/leedcode10.28.6hb3dzhwkeo0.png" alt="leedcode10"></p>
<h1 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路:"></a>个人思路:</h1><ul>
<li><p>利用递归加回溯进行全排列, </p>
</li>
<li><p>判断是否合法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归加回溯</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2_1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] nums = String.valueOf(n).toCharArray();</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">		<span class="keyword">return</span> dfs(nums, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((current &amp; (current - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vis.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[i] || (index == <span class="number">0</span> &amp;&amp; nums[i] == <span class="string">&#x27;0&#x27;</span>) || (i != <span class="number">0</span> &amp;&amp; !vis[i - <span class="number">1</span>] &amp;&amp; nums[i - <span class="number">1</span>] == nums[i])) &#123;<span class="comment">// 如果本次已经选中过相同的数字,就continue(!vis[i - 1] &amp;&amp; nums[i - 1] == nums[i])</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[i] = <span class="keyword">true</span>;</span><br><span class="line">			ans |= dfs(nums, index + <span class="number">1</span>, current * <span class="number">10</span> + nums[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			vis[i] = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路:"></a>题解思路:</h1><p>预处理加哈希表</p>
<ul>
<li><p>如果 a 和 b 重新排列后,都是同一个 2 的幂, 那么他们每个数字出现的次数应该相同,</p>
</li>
<li><p>利用这个结论我们可以将 1 到1e9 之间的 2 的幂的每个数字出现的次数转化成字符串全部存到set中.</p>
</li>
<li><p>查询即可</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_2</span> </span>&#123;</span><br><span class="line">	Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		init();<span class="comment">// 初始化</span></span><br><span class="line">		<span class="keyword">return</span> set.contains(numsCount(n));<span class="comment">// 查询</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">// 将 1 到1e9 之间的 2 的幂的每个数字出现的次数转化成字符串全部存到set中.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e9</span>; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			set.add(numsCount(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">numsCount</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;<span class="comment">// 每个数字出现的次数转化成字符串</span></span><br><span class="line">		<span class="keyword">int</span>[] numsCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			numsCount[num % <span class="number">10</span>]++;</span><br><span class="line">			num /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(numsCount);</span><br><span class="line">		<span class="keyword">return</span> String.valueOf(numsCount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Java 流</title>
    <url>/2021/10/28/Java-%E6%B5%81/</url>
    <content><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="从迭代到流的操作"><a href="#从迭代到流的操作" class="headerlink" title="从迭代到流的操作"></a>从迭代到流的操作</h2><p>当处理集合时, 我们通常会迭代它的元素, 并在每个元素上执行某项操作. </p>
<p>例如, 假设我们想要对某本书的所有长单词进行计数.首先, 将所有单词放到一个列表里:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String contents = <span class="keyword">new</span> String(</span><br><span class="line">				Files.readAllBytes(path), StandardCharsets.UTF_8);</span><br><span class="line">List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));<span class="comment">// 以非字母的字符为分隔符</span></span><br></pre></td></tr></table></figure>

<p>如果使用迭代:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String e : words) &#123;</span><br><span class="line">	<span class="keyword">if</span> (e.length() &gt; <span class="number">12</span>) &#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用流:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.Stream().filter(e -&gt; e.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>

<p>仅将<code>Stream</code>改为<code>parallelStream</code>就可以让流库以并行方式执行过滤和计数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.parallelStream().filter(e -&gt; e.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure>

<h3 id="流与集合的差距"><a href="#流与集合的差距" class="headerlink" title="流与集合的差距"></a>流与集合的差距</h3><ul>
<li>流不存储元素, 这些元素可能存储在底层的集合中, 或者按需生成.</li>
<li>流的操作不会改变其数据源. 例如, <code>filter</code>方法不会从流中移除元素, 而是产生一个新的流, 其中不包含被过滤掉的元素</li>
<li>流的操作时尽可能惰性执行的, 这意味着直至需要结果时,操作才会执行,</li>
</ul>
<p>示例解释:</p>
<p><code>Stream</code>和<code>parallelStream</code>方法会产生一个用于 words 列表的 stream . <code>filter</code>方法会返回另一个流, 其中只包含长度大于12的单词. count 方法会将这个流化简为一个结果.</p>
<h3 id="操作流时的典型流程"><a href="#操作流时的典型流程" class="headerlink" title="操作流时的典型流程"></a>操作流时的典型流程</h3><ol>
<li>创建一个流.</li>
<li>指定将初始流转换成其他流的中间操作, 可能包含多个步骤.</li>
<li>引用停止操作, 从而产生结果, 这个操作会强制执行之前的惰性操作, 从此之后, 这个流就不能用了</li>
</ol>
<p>实例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wordCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountLongWord</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String contents = <span class="keyword">new</span> String(</span><br><span class="line">				Files.readAllBytes(path), StandardCharsets.UTF_8);</span><br><span class="line">		List&lt;String&gt; words = Arrays.asList(contents.split(<span class="string">&quot;\\PL+&quot;</span>));<span class="comment">// 以非字母的字符为分隔符</span></span><br><span class="line">		<span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (String e : words) &#123;</span><br><span class="line">			<span class="keyword">if</span> (e.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		count = words.stream().filter(e -&gt; e.length() &gt; <span class="number">5</span>).count();</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		count = words.parallelStream().filter(e -&gt; e.length() &gt; <span class="number">5</span>).count();</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		CountLongWord(Paths.get(<span class="string">&quot;D:\\Documents\\blog\\themes\\hexo-theme-keep\\languages\\en.yml&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>java io流</title>
    <url>/2021/10/28/java-io%E6%B5%81-0/</url>
    <content><![CDATA[<h1 id="IO概念"><a href="#IO概念" class="headerlink" title="IO概念"></a>IO概念</h1><ul>
<li>I/O 即输入Input/Output的缩写, 其实就是计算机调度吧吧各个存储中(包括内存和外存)的数据写入写出的过程;<span id="more"></span></li>
<li>java中用”流(stream)”来抽象表示这么一个写入写出的功能,封装成一个”类”, 都放在java.io这个包里面.</li>
</ul>
<h1 id="“流”是什么"><a href="#“流”是什么" class="headerlink" title="“流”是什么"></a>“流”是什么</h1><p>通过”流”的形式允许java程序通过使用相同的方式来访问不同的输入/输出源. stream是从起源(source)到接收的(sink)的有序数据. 如果把输入/输出源对比成’水桶’, 那么流就是”管道”, 这个”管道”的粗细, 单向性等属性也就是区分了不同”流”的特性.</p>
<h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ol>
<li><p>按照流的方向(输入输出都是站在程序所在内存的角度划分的)</p>
<ul>
<li>输入流:只能从中读取数据[主要由InputStream和Reader作为基类]</li>
<li>输出流:只能先其写入数据[主要由outputStream和Writer作为基类]</li>
</ul>
</li>
<li><p>按照流的操作颗粒度划分</p>
<ul>
<li>字节流: 以字节为单元, 可操作任何数据[主要由InputStream和OutputStream作为基类]</li>
<li>字符流: 以字符为单元, 只能操作纯字符数据, 比较方便[主要由Reader和Writer作为基类]</li>
</ul>
</li>
<li><p>按照六点角色划分</p>
<ul>
<li>节点流: 可以从/向一个特定的IO设备(如磁盘, 网络) 读/写 数据的流, 也叫[低级流, 主要流]</li>
<li>处理流: 用于对一个已存在的流进行封装, 通过封装后的流来实现数据的 读/写 功能, 也叫[高级流]</li>
</ul>
</li>
</ol>
<h1 id="流的原理以及一共有多少IO流"><a href="#流的原理以及一共有多少IO流" class="headerlink" title="流的原理以及一共有多少IO流"></a>流的原理以及一共有多少IO流</h1><h2 id="流的原理解析"><a href="#流的原理解析" class="headerlink" title="流的原理解析"></a>流的原理解析</h2><blockquote>
<p>流想象成”水管”, 源端和目的端就是两个’水桶’, 数据是通过这个”水管”进行流动传输的, 以”InputStream”和Reader为例, 水管的每个”水滴”就是具体的数据, 如果是字节流, 那么一个”水滴”就是一个字节, 如果是字符流, 那么一个”水滴”就是一个字符</p>
</blockquote>
<p>当创建一个流对象的时候, 如<code>fis = new FileInputstream(&quot;...\xx\xx.txt&quot;)</code>, 记录指针表示当前正准备从哪个”水滴”开始读取, 每当程序从InputStream或者Reader里面取出一个或多个”水滴”后, 记录指针自定向后移动; 除此之外, InputStream和Reader里面都提供了一些方法来控制记录指针的移动.如果是处理流的话, 就相当于在这个”水管”上面装了一些”控制阀门”, 最终用户只要关心”阀门”具备的能力就行.</p>
<h2 id="java中所有流汇总"><a href="#java中所有流汇总" class="headerlink" title="java中所有流汇总"></a>java中所有流汇总</h2><p>java.io种子类中有40个”流”类, 表格如下</p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/IO1.1645xmt3farg.png" alt="IO1"></p>
<h1 id="常见IO流的实战"><a href="#常见IO流的实战" class="headerlink" title="常见IO流的实战"></a>常见IO流的实战</h1><h2 id="访问操作文件-FileInputStream-FileReader-FileOutStream-FileWriter"><a href="#访问操作文件-FileInputStream-FileReader-FileOutStream-FileWriter" class="headerlink" title="访问操作文件(FileInputStream/FileReader, FileOutStream/FileWriter)"></a>访问操作文件(FileInputStream/FileReader, FileOutStream/FileWriter)</h2><ol>
<li><p>使用FileInputStream, 从文件中读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileInputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">null</span>;<span class="comment">// 使用FileInputStream</span></span><br><span class="line"><span class="comment">//      FileReader in = null;// 使用FileReader</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);<span class="comment">// 使用FileInputStream</span></span><br><span class="line"><span class="comment">//			in = new FileReader(&quot;D:\\Documents\\logs\\java0.log&quot;);// 使用FileReader</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;文件未找到, 程序退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line">			in.close();</span><br><span class="line">			System.out.println(<span class="string">&quot;共读取了&quot;</span> + len + <span class="string">&quot;个字节&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常, 程序退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用输出流, 往文件中写数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileOutputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//		FileInputStream in = null;</span></span><br><span class="line">		FileReader in = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//		FileOutputStream out = null;</span></span><br><span class="line">		FileWriter out = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//			in = new FileInputStream(&quot;D:\\Documents\\logs\\java0.log&quot;);</span></span><br><span class="line">			in = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);</span><br><span class="line"><span class="comment">//			out = new FileOutputStream(&quot;D:\\Documents\\logs\\java1.log&quot;);</span></span><br><span class="line">			out = <span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\Documents\\logs\\java1.log&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;不存在该文件,程序即将退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				out.write(b);</span><br><span class="line">			&#125;</span><br><span class="line">			in.close();</span><br><span class="line">			out.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常, 程序即将退出!&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;文件复制完成!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="缓存流的使用-BufferedInputStream-BuffereOutputStream-BufferedReader-BufferedWriter"><a href="#缓存流的使用-BufferedInputStream-BuffereOutputStream-BufferedReader-BufferedWriter" class="headerlink" title="缓存流的使用(BufferedInputStream/BuffereOutputStream, BufferedReader/BufferedWriter)"></a>缓存流的使用(BufferedInputStream/BuffereOutputStream, BufferedReader/BufferedWriter)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">		FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">		BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">		BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java0.log&quot;</span>);</span><br><span class="line">			fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\Documents\\logs\\java1.log&quot;</span>);</span><br><span class="line">			bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">			bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((off = bis.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				bos.write(buffer, <span class="number">0</span>, off);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;文件复制完成&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;IO异常&quot;</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			bis.close();</span><br><span class="line">			bos.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换流的使用-InputStreamReader-OutputStreamReader"><a href="#转换流的使用-InputStreamReader-OutputStreamReader" class="headerlink" title="转换流的使用(InputStreamReader/OutputStreamReader)"></a>转换流的使用(InputStreamReader/OutputStreamReader)</h2><p>将字节流转化成字符流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\Documents\\logs\\java2.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (line.equals(<span class="string">&quot;over&quot;</span>))&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			bw.write(line);</span><br><span class="line">			bw.newLine();</span><br><span class="line">			bw.flush();<span class="comment">// 刷新字符输出流</span></span><br><span class="line">		&#125;</span><br><span class="line">		br.close();</span><br><span class="line">		bw.close();<span class="comment">// 关闭前必须刷新</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>对象流就是一种特殊的处理流, 也是在基础的字节流上封装.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectOutputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Person ming = <span class="keyword">new</span> Person(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">15</span>);</span><br><span class="line">			FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\Documents\\logs\\java3.txt&quot;</span>);</span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">			oos.writeObject(ming);</span><br><span class="line">			FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Documents\\logs\\java3.txt&quot;</span>);</span><br><span class="line">			ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">			Person p2 = (Person) ois.readObject();</span><br><span class="line">			System.out.println(p2);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			oos.flush();</span><br><span class="line">			oos.close();</span><br><span class="line">			ois.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;<span class="comment">// 对象必须实现序列化接口</span></span><br><span class="line">	<span class="keyword">private</span> String name = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节数据流的使用（ByteArrayInputStream-ByteArrayOutputStream）【通常结合数据流DataInputStream-DataOutputStream】"><a href="#字节数据流的使用（ByteArrayInputStream-ByteArrayOutputStream）【通常结合数据流DataInputStream-DataOutputStream】" class="headerlink" title="字节数据流的使用（ByteArrayInputStream/ByteArrayOutputStream）【通常结合数据流DataInputStream/DataOutputStream】"></a>字节数据流的使用（ByteArrayInputStream/ByteArrayOutputStream）【通常结合数据流DataInputStream/DataOutputStream】</h2><ul>
<li>为了提高效率, 避免频繁的读写文件, 于是出现了字节数组流, 因为存放在内存中, 所以也被称为”内存流”; 字节数组流也是一种节点流;</li>
<li>数据处理流是一种处理流, 用于针对数据类型传输处理的, 一般用于序列化与反序列化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDateStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">// 创建字节数组, 同时会在内存中创建数组</span></span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);<span class="comment">// 将字节数组流封装成数据处理流</span></span><br><span class="line">		DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			dos.writeDouble(Math.random());</span><br><span class="line">			dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">			ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">			System.out.println(bais.available());</span><br><span class="line"></span><br><span class="line">			dis = <span class="keyword">new</span> DataInputStream(bais);</span><br><span class="line">			System.out.println(dis.readDouble());</span><br><span class="line">			System.out.println(dis.readBoolean());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			dos.close();</span><br><span class="line">			dis.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>junit入门</title>
    <url>/2021/10/31/junit%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="junit单元测试"><a href="#junit单元测试" class="headerlink" title="junit单元测试"></a>junit单元测试<span id="more"></span></h1><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><ul>
<li>黑盒测试 : 不关注具体的代码实现, 只需要关注能否得到正确结果</li>
<li>白盒测试 : 不只要关注能否得到正确结果, 还要关注具体的代码实现</li>
</ul>
<h2 id="junit使用"><a href="#junit使用" class="headerlink" title="junit使用"></a>junit使用</h2><ul>
<li><p>步骤</p>
<ol>
<li><p>定义一个测试类(测试用例)</p>
<p>建议:</p>
<ul>
<li>测试类名 : 被测试的类 + Test</li>
<li>包名 : 与被测试的类所在的包同级, 且取名为test <img src="https://raw.githubusercontent.com/ischenysh/images/master/junit.2wcf1jwyhj60.png" alt="junit"></li>
</ul>
</li>
<li><p>定义测试方法 : <strong>可以独立运行</strong></p>
<p>建议:</p>
<ul>
<li>方法名 : test + 被测试的方法名</li>
<li>返回值 : void</li>
<li>参数列表 : 空参</li>
</ul>
</li>
</ol>
<ol start="3">
<li>给方法前加 <em>@test</em> 注解</li>
<li>导入junit 依赖环境</li>
</ol>
</li>
<li><p>判定结果</p>
<ul>
<li>红色 : 失败</li>
<li>绿色 : 成功</li>
<li>一般会使用断言操作</li>
</ul>
</li>
<li><p>补充</p>
<ul>
<li><p><em>@Before</em> :</p>
<p>被注解的方法总是在测试方法之前执行</p>
</li>
<li><p><em>@After</em> :</p>
<p>被注解的方法总是在测试方法之后执行</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.junit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a - b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chenysh.junit.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Calculator calculator;</span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		一般用于申请资源, 总是在test方法执行之前执行</span></span><br><span class="line">		calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">		System.out.println(<span class="string">&quot;我被初始化啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/**test使用规范:</span></span><br><span class="line"><span class="comment">   *总是返回null</span></span><br><span class="line"><span class="comment">   *无参数传入</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = calculator.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		Assert.assertEquals(result, <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = calculator.sub(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		Assert.assertEquals(result, -<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@After</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		一般用于清理资源, 总是在test方法执行之后执行, 不管test方法有没有正常执行完成</span></span><br><span class="line">		System.out.println(<span class="string">&quot;我被清理啦!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>反射入门</title>
    <url>/2021/10/31/%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="反射-框架设计的灵魂"><a href="#反射-框架设计的灵魂" class="headerlink" title="反射 : 框架设计的灵魂"></a>反射 : 框架设计的灵魂<span id="more"></span></h1><ul>
<li><p>框架 : 半成品软件, 可以在框架的基础上进行软件开发, 简化编码</p>
</li>
<li><p>反射 : 将类的各个组成部分封装为其他对象</p>
<p>​    好处:</p>
<ul>
<li><p>可以在程序运行过程中操作这些对象</p>
</li>
<li><p>可以解耦, 增强程序的拓展性</p>
</li>
</ul>
</li>
</ul>
<h2 id="获取class-对象的方式"><a href="#获取class-对象的方式" class="headerlink" title="获取class 对象的方式"></a>获取class 对象的方式</h2><ol>
<li><p><code>Class.forName(&quot;全类名&quot;)</code> : 将字节码加载进内存, 返回 class 对象</p>
<p>多用于配置文件, 使类名定义在配置文件中; 通过读取文件来加载类</p>
</li>
<li><p><code>类名.class</code> : 通过类名的属性 class 获取</p>
<p>用于参数的传递</p>
</li>
<li><p><code>对象.getClass()</code> : getClass() 方法定义在 Object 类中</p>
<p>多用于对象的获取字节码的方式</p>
</li>
<li><p>结论 : </p>
<p>同一个字节码文件(*.class)在一次程序运行过程中只会被加载一次, 所有方式获取的Class对象都是同一个</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class class1 = Class.forName(<span class="string">&quot;com.chenysh.reflect.Person&quot;</span>);</span><br><span class="line">		Class class2 = Person.class;</span><br><span class="line">		Class class3 = <span class="keyword">new</span> Person().getClass();</span><br><span class="line">		System.out.println(class1.equals(class2));</span><br><span class="line">		System.out.println(class2.equals(class3));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="class对象的功能"><a href="#class对象的功能" class="headerlink" title="class对象的功能"></a>class对象的功能</h2><ul>
<li><p>获取功能</p>
<ol>
<li><p>获取成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] getFields()</span><br><span class="line"><span class="function">Field <span class="title">getFields</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>获取成员构造方法</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>获取成员方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure></li>
<li><p>获取类名</p>
<p><code>String getName()</code></p>
</li>
</ol>
</li>
<li><p>成员变量</p>
<ol>
<li><p>设置值</p>
<p><code>void set(Object obj, Object value)</code></p>
</li>
<li><p>获取值</p>
<p><code>get (Object obj)</code></p>
</li>
<li><p>忽略访问权限修饰符的安全检查</p>
<p><code>setAccessible(true)</code>// 暴力反射</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Field[] getFields()</span></span><br><span class="line"><span class="comment">Field getField(String name)</span></span><br><span class="line"><span class="comment">Field getDeclaredField(String name)</span></span><br><span class="line"><span class="comment">Field[] getDeclaredFields()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Constructor&lt;?&gt;[] getConstructors()</span></span><br><span class="line"><span class="comment">Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Constructor&lt;?&gt;[] getDeclaredConstructors()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Method[] getMethods()</span></span><br><span class="line"><span class="comment">Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">Method[] getDeclaredMethods()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="number">20</span>, <span class="string">&quot;man&quot;</span>, <span class="string">&quot;chenysh&quot;</span>);</span><br><span class="line">		Class class1 = Person.class;</span><br><span class="line">		Field field2 = class1.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">		Field[] fields = class1.getFields();</span><br><span class="line">		System.out.println(field2.get(person));</span><br><span class="line">		field2.set(person, <span class="number">2</span>);<span class="comment">// 修改字段的值</span></span><br><span class="line">		System.out.println(field2.get(person));<span class="comment">// 设置字段的值</span></span><br><span class="line">		<span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">			System.out.println(field);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">		Field field = class1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		fields = class1.getDeclaredFields();</span><br><span class="line">		<span class="keyword">for</span> (Field field1 : fields) &#123;</span><br><span class="line">			System.out.println(field1);</span><br><span class="line">		&#125;</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>);<span class="comment">// 暴力反射</span></span><br><span class="line">		System.out.println(field.get(person));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Constructor[] constructors = class1.getConstructors();</span><br><span class="line">		Constructor constructor = class1.getConstructor(<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, String.class, String.class);</span><br><span class="line">		System.out.println(constructor);</span><br><span class="line">		<span class="keyword">for</span> (Constructor constructor1 : constructors) &#123;</span><br><span class="line">			System.out.println(constructor1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Person person1 = (Person) constructor.newInstance(<span class="number">2</span>, <span class="number">21</span>, <span class="string">&quot;yuan&quot;</span>, <span class="string">&quot;woman&quot;</span>);<span class="comment">//      全参构造</span></span><br><span class="line">		System.out.println(person1);</span><br><span class="line">		Object obj = constructors[<span class="number">1</span>].newInstance();<span class="comment">// 空参构造1</span></span><br><span class="line">		System.out.println(obj);</span><br><span class="line">		System.out.println((Person) class1.newInstance());<span class="comment">// 空参构造2</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Method method = class1.getMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">		method.invoke(person, <span class="string">&quot;yuanqinakai&quot;</span>);<span class="comment">// 调用方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li><p>需求 : 写一个”框架”, 可以帮我们创建任意类对象, 并且执行其中任意方法 </p>
</li>
<li><p>实现 :</p>
<ol>
<li>配置文件</li>
<li>反射</li>
</ol>
</li>
<li><p>步骤 : </p>
<ol>
<li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中(配置文件放在src目录下)</li>
<li>在程序中加载读取配置文件</li>
<li>使用反射技术来加载类文件进内存</li>
<li>创建对象</li>
<li>执行方法</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo03</span> </span>&#123;</span><br><span class="line"><span class="comment">//	可以帮我们创建任意类对象, 并且执行其中任意方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		1. 加载配置文件</span></span><br><span class="line"><span class="comment">//		1.1 创建 Properties 对象</span></span><br><span class="line">		Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//		1.2 加载配置文件, 转换为一个集合</span></span><br><span class="line"><span class="comment">//      1.2.1 获取class目录下的配置文件</span></span><br><span class="line">		ClassLoader classLoader = demo03.class.getClassLoader();</span><br><span class="line">		InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;demo.properties&quot;</span>);</span><br><span class="line">		properties.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		2. 获取配置文件中定义的数据</span></span><br><span class="line">		String className = properties.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">		String methodName = properties.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		3. 加载该类进内存</span></span><br><span class="line">		Class aClass = Class.forName(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		4. 创建对象</span></span><br><span class="line">		Object obj = aClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//		5.获取方法对象</span></span><br><span class="line">		Method method = aClass.getMethod(methodName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		6. 执行方法</span></span><br><span class="line">		method.invoke(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>注解的介绍</title>
    <url>/2021/10/31/%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解<span id="more"></span></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>概念 : 说明程序的, 给计算机看</p>
</li>
<li><p>与注释的区别 : 注释是给人看的</p>
</li>
<li><p>定义 : <strong>Java注解</strong>又称<strong>Java标注</strong>，是<a class="link"   href="https://zh.wikipedia.org/wiki/Java" >Java<i class="fas fa-external-link-alt"></i></a>语言<strong>5.0版本</strong>开始支持加入<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81" >源代码<i class="fas fa-external-link-alt"></i></a>的特殊语法<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%85%83%E6%95%B0%E6%8D%AE" >元数据<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3#cite_note-1" >1]<i class="fas fa-external-link-alt"></i></a>。</p>
<p>Java语言中的类、方法、变量、参数和包等都可以被标注。和<a class="link"   href="https://zh.wikipedia.org/wiki/Javadoc" >Javadoc<i class="fas fa-external-link-alt"></i></a>不同，Java标注可以通过反射获取标注内容。在<a class="link"   href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8" >编译器<i class="fas fa-external-link-alt"></i></a>生成<a class="link"   href="https://zh.wikipedia.org/w/index.php?title=%E7%B1%BB%E6%96%87%E4%BB%B6&action=edit&redlink=1" >类文件<i class="fas fa-external-link-alt"></i></a>时，标注可以被嵌入到<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81" >字节码<i class="fas fa-external-link-alt"></i></a>中。<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" >Java虚拟机<i class="fas fa-external-link-alt"></i></a>可以保留标注内容，在运行时可以获取到标注内容[<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3#cite_note-2" >2]<i class="fas fa-external-link-alt"></i></a>。 当然它也支持自定义Java标注[<a class="link"   href="https://zh.wikipedia.org/wiki/Java%E6%B3%A8%E8%A7%A3#cite_note-3" >3]<i class="fas fa-external-link-alt"></i></a>。</p>
</li>
<li><p>使用方法 : @ + 注解名称</p>
</li>
<li><p>作用分类 :</p>
<ol>
<li><p>编写文档 : 通过代码里表识的注解生成文档 [生成文档 doc文档] 命令行 javadoc + Java源文件名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解javadoc演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chnysh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算两数之和</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a 整数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> b 整数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 两数之和</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<em>javadoc demo01.java</em></p>
</li>
<li><p>代码分析 : 通过代码里的标识的注解对代码进行分析[使用反射]</p>
</li>
<li><p>编译检查 : 通过代码里标识的注解让编译器能够实现基本的编译检查[<em>@Override</em>]</p>
</li>
</ol>
</li>
</ul>
<h2 id="java中预定义的注解"><a href="#java中预定义的注解" class="headerlink" title="java中预定义的注解"></a>java中预定义的注解</h2><ul>
<li><code>@Override</code> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li><code>@Deprecated</code> - 标记过时方法。如果使用该方法，会报编译警告。</li>
<li><code>@SuppressWarnings</code> - 指示编译器去忽略注解中声明的警告。[@SuppressWarnings(“all”)]</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul>
<li><p>格式 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称()&#123;</span><br><span class="line">    属性列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>本质 : 注解的本质就是一个接口, 该接口默认继承Annotation接口</p>
</li>
<li><p>属性 : 接口中定义的成员方法</p>
<ul>
<li><p>要求:</p>
<ol>
<li><p>属性的返回值类型限制 : </p>
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
<li><p>定义了属性, 在使用注解时需要给其赋值</p>
<ul>
<li>可以使用default关键字给属性默认的初始化值, 这样在使用注解时可以选择不赋值</li>
<li>如果只有一个属性, 且名为 value, 则 value 可以省略, 直接定义值</li>
<li>数组赋值时要使用 {}, 如果数组中只有一个值, 则可以省略 {}</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>元注解 : 用于描述注解的注解</p>
<ul>
<li><p>@Target : 描述注解能够作用的位置</p>
<p>ElementType取值: </p>
<ul>
<li>TYPE : 类</li>
<li>METHOD : 方法</li>
<li>FIELD : 成员变量</li>
</ul>
</li>
<li><p>@Retention : 描述注解被保留的阶段</p>
<p>RetentionPolicy取值</p>
<ul>
<li>SOURCE : 保留在源文件中</li>
<li>CLASS : 保留到字节码中</li>
<li>RUNTIME : 保留到字节码中, 且可以被JVM读取到 </li>
</ul>
</li>
<li><p>@Documented : 描述注解是否被抽取到 api 文档中</p>
</li>
<li><p>@Inherited : 描述注解是否被子类继承</p>
</li>
</ul>
</li>
</ul>
<h2 id="在程序中使用注解-获取注解中定义的属性值"><a href="#在程序中使用注解-获取注解中定义的属性值" class="headerlink" title="在程序中使用注解 : 获取注解中定义的属性值"></a>在程序中使用注解 : 获取注解中定义的属性值</h2><ol>
<li><p>获取注解定义的位置类的字节码文件对象 (Class, Method, Field)</p>
</li>
<li><p>获取需要的注解</p>
<p><code>getAnnotation(Class)</code></p>
</li>
<li><p>调用注解中的抽象方法获取配置的属性值 : <strong>本质是一个实现类实现了抽象方法</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@properties(className = &quot;com.chenysh.domain.Person&quot;, methodName = &quot;eat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">personTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		获取该类的字节码文件对象</span></span><br><span class="line">		Class personTestClass = personTest.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//		获取注解对象</span></span><br><span class="line">		properties anno = (properties) personTestClass.getAnnotation(properties.class);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		使用注解对象的属性</span></span><br><span class="line">		Class aClass = Class.forName(anno.className());</span><br><span class="line">		Object obj = aClass.newInstance();</span><br><span class="line">		Method method = aClass.getMethod(anno.methodName());</span><br><span class="line">		method.invoke(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>大多数只要会使用注解即可</li>
<li>注解不是程序的一部分, 可以理解为一个标签</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MySQL学习</title>
    <url>/2021/10/31/MySQL%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="数据库-DateBase-简介"><a href="#数据库-DateBase-简介" class="headerlink" title="数据库(DateBase)简介"></a>数据库(DateBase)简介<span id="more"></span></h1><ul>
<li><p>数据库的英文单词 : DateBase  简称(DB)</p>
</li>
<li><p>什么是数据库 :</p>
<p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p>
</li>
<li><p>数据库的特点 :</p>
<ol>
<li>持久化存储数据.</li>
<li>方便存储和管理</li>
<li>使用了统一的方式操作数据库 –<strong>SQL</strong></li>
</ol>
</li>
<li><p>MySQL数据库</p>
<ul>
<li><p>MySQL 是一个关系型数据库管理系统, 开源且强大</p>
</li>
<li><p>使用 : </p>
<p>打开与关闭MySQL服务:</p>
<p>​    net start mysql;</p>
<p>​    net stop mysql;</p>
<p>登录与登出 :</p>
<p>​    mysql -u +  用户名 -p + 密码(p与密码中间不能有空格)    </p>
<p>​    exit 或 quit</p>
</li>
</ul>
</li>
</ul>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>简介 : <strong>SQL</strong>，<strong>Structured Query Language:结构化查询语言</strong>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-6" >6]<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-7" >7]<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-8" >8]<i class="fas fa-external-link-alt"></i></a>[<a class="link"   href="https://zh.wikipedia.org/wiki/SQL#cite_note-9" >9]<i class="fas fa-external-link-alt"></i></a>）是一种<a class="link"   href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%AE%9A%E7%9B%AE%E7%9A%84%E7%A8%8B%E5%BC%8F%E8%AF%AD%E8%A8%80" >特定目的编程语言<i class="fas fa-external-link-alt"></i></a>，用于管理<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" >关系数据库管理系统<i class="fas fa-external-link-alt"></i></a>（RDBMS），或在<a class="link"   href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" >关系流数据管理系统<i class="fas fa-external-link-alt"></i></a>（RDSMS）中进行流处理。</p>
<ul>
<li><p>通用语法:</p>
<ol>
<li>SQL语句可以单行或多行书写, 以分号结尾.</li>
<li>可使用空格或缩进来提高可读性</li>
<li>SQL语句不区分大小写, 但推荐关键字大写</li>
<li>单行注释 – 或 #</li>
<li>多行注释/* 注释 */</li>
</ol>
</li>
<li><p>SQL分类</p>
<ol>
<li><p><strong>DDL</strong>(DateBase Definition Language) : 数据定义语言</p>
<p>用来定义数据库对象 : 数据库, 表, 列等, 关键字 : create, drop, alter等</p>
</li>
<li><p>DML(DateBase Manipulation Language) : 数据操作语言</p>
<p>用于对数据库中表的数据进行增删改. 关键字 : insert, delete, update等</p>
</li>
<li><p>DQL(DateBase Query Language) : 数据查询语言</p>
<p>用于查询数据库中表的记录(数据). 关键字 : select, where 等</p>
</li>
<li><p>DCL(DateBase Control Language) : 数据控制语言</p>
<p>用于定义数据库中的访问权限和安全级别以及创建用户. 关键字 : GRANT, REVOKE 等 </p>
</li>
</ol>
</li>
</ul>
<h2 id="DDL-操作数据库-表"><a href="#DDL-操作数据库-表" class="headerlink" title="DDL : 操作数据库, 表"></a>DDL : 操作数据库, 表</h2><h3 id="操作数据库-CRUD"><a href="#操作数据库-CRUD" class="headerlink" title="操作数据库 : CRUD"></a>操作数据库 : <strong>CRUD</strong></h3><ul>
<li><p>C(Create) : 创建</p>
<ul>
<li><p>创建数据库</p>
<p><code>create datebase 数据库名称; </code></p>
</li>
<li><p>当数据库不存在时创建数据库</p>
<p><code>create datebase if not exists 数据库名称; </code></p>
</li>
<li><p>当数据库并设定字符集</p>
<p><code>create datebase 数据库名称 character set 字符集名;</code></p>
</li>
</ul>
<p> <code>create datebase if not exists 数据库名称 character set 字符集名;</code></p>
</li>
<li><p>R(Retrieve) : 查询</p>
<ul>
<li><p>查询所有数据库的名称</p>
<p><code>show databases;</code></p>
</li>
<li><p>查询某个数据库的创建语句</p>
<p><code>show create database 数据名称;</code></p>
</li>
</ul>
</li>
<li><p>U(Update) : 修改</p>
<ul>
<li><p>修改字符串的字符集</p>
<p><code>alter database 数据库名称 character set 字符集名称;</code></p>
</li>
</ul>
</li>
<li><p>D(Delete) : 删除</p>
<ul>
<li><p>删除数据库</p>
<p><code>drop datebase 数据库名称; </code></p>
</li>
<li><p>当数据库存在时删除数据库</p>
<p><code>drop datebase if exists 数据库名称; </code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用数据库</p>
<ul>
<li><p>使用数据库</p>
<p><code>use 数据库名称;</code></p>
</li>
<li><p>查询当前正在使用的数据库名称</p>
<p><code>select database();</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="操作表-CRUD"><a href="#操作表-CRUD" class="headerlink" title="操作表 : CRUD"></a>操作表 : <strong>CRUD</strong></h3><ul>
<li><p>C(Create) : 创建</p>
<ol>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    列名<span class="number">1</span> 数据类型,</span><br><span class="line">    列名<span class="number">2</span> 数据类型,</span><br><span class="line">    ...</span><br><span class="line">    列名n 数据类型</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">like</span> 要复制的表名;</span><br></pre></td></tr></table></figure></li>
<li><p>数据类型</p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/sql1.43288dgb5j80.png" alt="sql1"></p>
<p><img src="C:\Users\yoga\AppData\Roaming\Typora\typora-user-images\image-20211031192630420.png" alt="image-20211031192630420"></p>
<p><img src="C:\Users\yoga\AppData\Roaming\Typora\typora-user-images\image-20211031192640110.png" alt="image-20211031192640110"></p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>R(Retrieve) : 查询</p>
<ul>
<li><p>查询某个数据库的所有表的名称</p>
<p><code>show tables;</code></p>
</li>
<li><p>查询表结构</p>
<p><code>desc 表名;</code></p>
</li>
</ul>
</li>
<li><p>U(Update) : 修改</p>
<ul>
<li><p>修改表名</p>
<p><code>alter table 表名 rename to 新表名;</code></p>
</li>
<li><p>修改表的字符集</p>
<p><code>alter table 表名 character set 字符集名;</code></p>
</li>
<li><p>添加一列</p>
<p><code>alter table 表名 add 列名 数据类型;</code></p>
</li>
<li><p>修改列的名称和类型</p>
<ul>
<li><code>alter table 表名 change 列名 新列名 新数据类型;</code></li>
<li><code>alter table 表名 modify 列名 新数据类型;</code></li>
</ul>
</li>
<li><p>删除列</p>
<p><code>alter table 表名 drop 列名;</code></p>
</li>
</ul>
</li>
<li><p>D(Delete) : 删除</p>
<ul>
<li><code>drop table 表名;</code></li>
<li><code>drop table if exists 表名;</code></li>
</ul>
</li>
</ul>
<h2 id="DML-增删改表中数据"><a href="#DML-增删改表中数据" class="headerlink" title="DML : 增删改表中数据"></a>DML : 增删改表中数据</h2><ol>
<li><p>添加数据</p>
<ul>
<li><p>语法 :</p>
<ul>
<li><code>insert into 表名(列名1, 列名2....列名n) vaules(值1, 值2...值n);</code></li>
</ul>
</li>
<li><p>注意事项 :</p>
<ul>
<li><p>列名和值要一一对应</p>
</li>
<li><p>如果表名后不定义列名, 默认给所有列复制</p>
<p><code>insert into 表名 vaules(值1, 值2...值n);</code></p>
</li>
<li><p>除了数字类型, 其他类型需要引号(单双都可以)引起来</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>删除数据</p>
<ul>
<li><p>语法</p>
<p>​    <code>delete from 表名 [where 条件];</code></p>
</li>
<li><p>注意:</p>
<ul>
<li>如果不加条件, 则会删除表中所有记录</li>
<li>删除所有记录的方式<ul>
<li><code>delete from 表名;;</code>  只删除数据不删除表的结构, 且可以回滚</li>
<li><code>truncate 表名;</code> :  只删除数据不删除表的结构, 不可以回滚</li>
<li><code>drop table 表名;</code>: 删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于 该表的存储过程/函数将保留,但是变为 invalid 状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改数据</p>
<ul>
<li><p>语法:</p>
<p><code>update 表名 set 列名1 = 值1, 列名2 = 值2,  ... [where 条件];</code></p>
</li>
<li><p>注意 :</p>
<p>如果不加条件会把所有记录都修改.</p>
</li>
</ul>
</li>
</ol>
<h2 id="DQL-查询表中数据"><a href="#DQL-查询表中数据" class="headerlink" title="DQL : 查询表中数据"></a>DQL : 查询表中数据</h2><ul>
<li><p>语法 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">	分组列表</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">	分组之后的条件</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">	排序</span><br><span class="line">limit</span><br><span class="line">	分页限定</span><br></pre></td></tr></table></figure></li>
<li><p>基础查询</p>
<ul>
<li><p>多个字段的查询</p>
<p><code>select 字段名1, 字段名2, .... from 表名;</code></p>
<p>注意 :  如果要查询所有字段可以用 * 来替代字段列表</p>
</li>
<li><p>去除重复</p>
<p><code>select distinct 字段名1, 字段名2, .... from 表名;</code></p>
</li>
<li><p>计算列</p>
<ul>
<li><p><code>select 字段名1, ifnull(字段名2, 0) + 字段名3, .... from 表名;</code></p>
</li>
<li><p>一般可以使用四则运算计算一些列的值.(一般只进行数值型的运算)</p>
</li>
<li><p><code>ifnull(表达式1, 表达式2);</code>如果表达式1为null, 将返回表达式2, 不然返回表达式</p>
</li>
</ul>
</li>
<li><p>起别名</p>
<p><code>select 字段名1 (as) 别名1, 字段名2 (as) 别名1, .... from 表名;</code>– <strong>as可省略</strong></p>
</li>
</ul>
</li>
<li><p>条件查询</p>
<ul>
<li><code>where 条件;</code></li>
<li>运算符<ul>
<li>‘&gt;’, &lt;, &lt;=. &lt;=, =, &lt;&gt;, !=</li>
<li>between…and…</li>
<li>in(集合)</li>
<li>like<ul>
<li>占位符 :<ul>
<li>_ : 单个任意字符</li>
<li>%: 任意多个字符</li>
</ul>
</li>
</ul>
</li>
<li>is null, is not null</li>
<li>ans / &amp;&amp;</li>
<li>or / ||</li>
<li>not / !</li>
</ul>
</li>
</ul>
</li>
<li><p>排序查询</p>
<ul>
<li><p>语法 : </p>
<p><code>order by 排序字段1 排序方式1, 排序字段2 排序方式2, .... </code></p>
</li>
<li><p>排序方式 : </p>
<ul>
<li>ASC : 升序(default)</li>
<li>DESC : 降序. </li>
</ul>
</li>
<li><p>注意 : </p>
<p>排序优先级有先后之分, 只有前面的一样时才会比较后面的</p>
</li>
</ul>
</li>
<li><p>聚合函数 : 将一列数据进行计算</p>
<ul>
<li><p>语法 : </p>
<p><code>select 函数名(列名) from 表名;</code></p>
</li>
<li><p>count : 计算个数</p>
<ul>
<li>一般选择非空的列 : 主键</li>
</ul>
</li>
<li><p>max : 计算最大值</p>
</li>
<li><p>min : 计算最小值</p>
</li>
<li><p>sum : 计算和</p>
</li>
<li><p>avg : 计算平均值</p>
</li>
<li><p>聚合函数默认排除null值</p>
<ul>
<li>解决方案 : <ol>
<li>选择非空的列</li>
<li>ifnull函数 </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分组查询 : </p>
<ul>
<li><p>语法 :</p>
<p><code>group by 分组字段;</code></p>
</li>
<li><p>注意 : </p>
<ol>
<li>分组之后查询字段 : 分组字段, 聚合函数1,  聚合函数2, …</li>
<li>where 与 having 的区别<ul>
<li>where 在分组之前进行限定, 如果不满足条件, 则不会参与分组</li>
<li>having 在分组之后进行限定, 如果不满足条件, 则不会被查询出来<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	sex, <span class="built_in">count</span>(id) num, <span class="built_in">avg</span>(math) </span><br><span class="line">	<span class="keyword">from</span> student </span><br><span class="line">	<span class="keyword">where</span> english <span class="operator">&gt;</span> <span class="number">70</span> </span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span> sex </span><br><span class="line">	<span class="keyword">having</span> num <span class="operator">&gt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>分页查询</p>
<ul>
<li><p>语法 : </p>
<p><code>limit 开始的索引, 每页显示的条数;</code></p>
</li>
<li><p>开始的索引 = (要查询的页码 - 1) * 每页显示的条数;</p>
</li>
<li><p>只在MySQL中可用</p>
</li>
</ul>
</li>
</ul>
<h2 id="DCL-管理用户-授权"><a href="#DCL-管理用户-授权" class="headerlink" title="DCL : 管理用户, 授权"></a>DCL : 管理用户, 授权</h2><ol>
<li><p>管理用户</p>
<ol>
<li><p>添加用户 : </p>
<ul>
<li>语法 :<code> CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></li>
</ul>
</li>
<li><p>删除用户 :</p>
<ul>
<li>语法 : <code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
<li><p>修改用户密码 :</p>
<ul>
<li><code>UPDATE USER SET PASSWORD = PASSWORD(新密码) WHERE USER = &#39;用户名&#39;;</code></li>
<li><code>SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD = PASSWORD(新密码);</code></li>
</ul>
</li>
<li><p>查询用户 :</p>
<ol>
<li><p>切换到mysql数据库</p>
</li>
<li><p>查询 user 表</p>
</li>
</ol>
<ul>
<li>通配符 : % 表示可以在任意主机上使用用户登录数据库</li>
</ul>
</li>
</ol>
</li>
<li><p>授权</p>
<ol>
<li><p>查询权限 :</p>
<p><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
<li><p>授予权限</p>
<p><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
<p>ALL 代表所有权限或所有库</p>
</li>
<li><p>撤销权限</p>
<p><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
</ol>
</li>
</ol>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul>
<li><p>概念 :  对表中数据进行限定, 保证数据的准确性, 有效性和完整性.</p>
</li>
<li><p>分类 : </p>
<ol>
<li><p>主键约束 : primary key</p>
<ul>
<li><p>注意 :</p>
<ol>
<li>含义 : 非空且唯一.</li>
<li>一张表只能有一个主键</li>
<li>主键就是表中记录的唯一标识</li>
</ol>
</li>
<li><p>创建时添加约束</p>
<p><code>列名1 数据类型 PRIMARY KEY</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 PRIMARY KEY;</code></p>
</li>
<li><p>删除约束</p>
<p><code>ALTER TABLE 表名 DROP PRIMARY KEY;</code></p>
</li>
<li><p>自动增长</p>
<ul>
<li><p>概念 : 如果一列是数据类型的, 使用 auto_increment可以完成值的自dongle增长(从上一行的值增加)</p>
</li>
<li><p>创建时添加自动增长</p>
<p><code>列名1 数据类型 AUTO_INCREMENT</code></p>
</li>
<li><p>创建后添加自动增长</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 AUTO_INCREMENT;</code></p>
</li>
<li><p>删除自动增长</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型;</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>非空约束 : not null</p>
<ul>
<li><p>创建时添加约束</p>
<p><code>列名1 数据类型 NOT NULL</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 NOT NULL;</code></p>
</li>
<li><p>删除约束</p>
<p>  <code>ALTER TABLE 表名 MODIFY 列名 新数据类型;</code></p>
</li>
</ul>
</li>
<li><p>唯一约束 : unique</p>
<ul>
<li><p>创建时添加约束</p>
<p><code>列名1 数据类型 UNIQUE</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名 MODIFY 列名 新数据类型 UNIQUE;</code></p>
</li>
<li><p>删除约束</p>
<p><code>ALTER TABLE 表名 DROP INDEX 列名;</code></p>
</li>
</ul>
</li>
<li><p>外键约束 : foreign key</p>
<ul>
<li><p>创建时添加约束</p>
<p><code>constraint 外键名称 foreign key (外键列名称) reference 主表名称(主表列名称)</code></p>
</li>
<li><p>创建后添加约束</p>
<p><code>ALTER TABLE 表名称 ADD constraint 外键名称 foreign key (外键列名称) reference 主表名称(主表列名称);</code></p>
</li>
<li><p>删除约束</p>
<p><code>ALTER TABLE 表名称 DROP FOREIGN KEY 外键名称;</code></p>
</li>
<li><p>级联操作</p>
<ul>
<li>语法 : <code>constraint 外键名称 foreign key (外键列名称) reference 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE</code></li>
<li>分类 :<ol>
<li>级联更新 : ON UPDATE CASCADE</li>
<li>级联删除 : ON DELETE CASCADE`</li>
</ol>
</li>
<li>注意 : 要谨慎使用</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><ol>
<li><p>多表之间的关系</p>
<ol>
<li><p>分类</p>
<ol>
<li>一对一 : e.g : 人和身份证</li>
<li>一对多 (多对一) : e.g : 部门和员工</li>
<li>多对多 :  e.g : 学生和课程</li>
</ol>
</li>
<li><p>实现方式 :</p>
<ol>
<li><p>一对一 : </p>
<p>在任意一方添加<strong>唯一</strong>外键指向另一方的主键.</p>
</li>
<li><p>一对多(多对一) :</p>
<p>在多的一方建立外键指向一的一方.</p>
</li>
<li><p>多对多 :</p>
<p>借助第三张中间表, 中间表至少包含两个字段, 分别指向两张表的主键</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据库的设计范式 :</p>
<ul>
<li><p>概念 :设计关系<a class="link"   href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728" >数据库<i class="fas fa-external-link-alt"></i></a>时，遵从不同的规范<a class="link"   href="https://baike.baidu.com/item/%E8%A6%81%E6%B1%82/3598753" >要求<i class="fas fa-external-link-alt"></i></a>，设计出合理的<a class="link"   href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/8999831" >关系型数据库<i class="fas fa-external-link-alt"></i></a>，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>
<p><a class="link"   href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/1237340" >关系数据库<i class="fas fa-external-link-alt"></i></a>有六种范式：第一范式（1NF）、第二范式（2NF）、<a class="link"   href="https://baike.baidu.com/item/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F/3193798" >第三范式<i class="fas fa-external-link-alt"></i></a>（3NF）、巴斯-科德范式（BCNF）、<a class="link"   href="https://baike.baidu.com/item/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F/3193985" >第四范式<i class="fas fa-external-link-alt"></i></a>(4NF）和<a class="link"   href="https://baike.baidu.com/item/%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F/5025271" >第五范式<i class="fas fa-external-link-alt"></i></a>（5NF，又称完美范式）。</p>
</li>
<li><p>前置知识 :</p>
<ol>
<li>函数依赖 : A –&gt; B, 如果通过A属性(属性组)的值, 可以唯一确定唯一B属性的值, 则称B依赖于A</li>
<li>完全函数依赖 : A –&gt; B, 如果要唯一确定B属性的值, 要借助A属性组的<strong>所有值</strong>, 则称B依赖于A</li>
<li>部分函数依赖 : A –&gt; B, 如果要唯一确定B属性的值, <strong>只</strong>要借助A属性组的<strong>部分值</strong>, 则称B依赖于A</li>
<li>传递函数依赖 : A–&gt; B, B –&gt; C, 如果B依赖于A, C依赖于B, 则称C依赖于A.</li>
<li>码 : 如果在一张表中, 一个属性(属性组)被<strong>其他所有</strong>属性完全依赖, 则称这个属性(属性组)为该表的码</li>
</ol>
</li>
<li><p>分类 :</p>
<ol>
<li><p>第一范式 (1NF) : </p>
<p>数据库表的每一列都是不可分割的原子数据项</p>
</li>
<li><p>第二范式 (2NF) : </p>
<p>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上<strong>消除</strong>非主属性对主码的<strong>部分函数依赖</strong>.</p>
</li>
<li><p>第三范式 (3NF) : </p>
<p>在2NF基础上，任何非主<a class="link"   href="https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7" >属性<i class="fas fa-external-link-alt"></i></a>不依赖于其它非主属性（在2NF基础上<strong>消除传递依赖</strong>）</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="数据库的备份与还原"><a href="#数据库的备份与还原" class="headerlink" title="数据库的备份与还原"></a>数据库的备份与还原</h2><ol>
<li><p>命令行 :</p>
<ul>
<li>语法 :<ol>
<li>备份 : mysqldump -u用户名 -p密码 要备份的数据库名 &gt; 保存的路径</li>
<li>还原 :<ol>
<li>登录数据库</li>
<li>创建数据库</li>
<li>使用数据库</li>
<li>执行文件<code>source 文件路径;</code><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>查询语法 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	表名列表;</span><br></pre></td></tr></table></figure></li>
<li><p>笛卡尔积 : </p>
<p>笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尔积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员 </p>
</li>
<li><p>分类 :</p>
<ul>
<li><p>内连接查询</p>
<ol>
<li>隐式内连接 : 使用 where 条件 来清除无用的数据</li>
<li>显示内连接 : <ul>
<li>语法 : <code>select 字段列表 from 表名1 [inner] join 表名2 on 条件;</code></li>
<li>查询两表的交集部分</li>
</ul>
</li>
<li>明确要求 :<ol>
<li>要从那些表中查询数据</li>
<li>条件是什么</li>
<li>要查询哪些字段</li>
</ol>
</li>
</ol>
</li>
<li><p>外连接查询</p>
<ol>
<li>左外连接 : <ul>
<li>语法 : <code>select 字段列表 from 表名1 left [outer] join 表名2 on 条件;</code></li>
<li>查询的是左表的所有数据以及其交集部分</li>
</ul>
</li>
<li>右外连接<ul>
<li>语法 : <code>select 字段列表 from 表名1 right [outer] join 表名2 on 条件;</code></li>
<li>查询的是右表的所有数据以及其交集部分</li>
</ul>
</li>
</ol>
</li>
<li><p>子查询</p>
<ul>
<li><p>概念 : 在查询中嵌套查询, 则称嵌套查询为子查询.</p>
</li>
<li><p>子查询的不同种情况 :</p>
<ol>
<li><p>子查询的结果是单行单列的 :</p>
<p>子查询可以作为条件, 使用运算符(&gt;, &lt;, =…)进行判断</p>
</li>
<li><p>子查询的结果是单行多列的 :</p>
<p>子查询可以作为条件, 使用运算符 <em>in</em> 进行判断</p>
</li>
<li><p>子查询的结果是多行多列的 :</p>
<p>子查询可以作为一张虚拟表参与查询</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ol>
<li><p>事务的基本介绍</p>
<ol>
<li><p>概念 :</p>
<ul>
<li>如果一个包含多个步骤的业务操作, 被事务管理, 那么这些操作要么同时成功, 要么同时失败.</li>
</ul>
</li>
<li><p>操作 :</p>
<ol>
<li><p>开启事务 : <code>start transaction;</code></p>
</li>
<li><p>回滚 :<code>roll back;</code></p>
</li>
<li><p>提交 : <code>commit;</code></p>
</li>
<li><p>MySQL数据库中事务默认自动提交</p>
<ul>
<li>事务提交的两种方式<ol>
<li>自动提交 : 一条DML(增删改)语句会自动提交一次事务</li>
<li>手动提交 : 需要先开启事务再提交, Oracle数据库默认手动提交</li>
</ol>
</li>
<li>修改事务的默认提交方式 :<ul>
<li>查看事务的默认提交方式 : <code>SELECT @@autocommit;</code>– 0为手动, 1为自动</li>
<li>修改事务的默认提交方式 : <code>SET @@autocommit = 0;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>事务的四大特征 :</p>
<ol>
<li>原子性 : 是不可分割的最小操作单位, 要么同时成功, 要么同时失败</li>
<li>持久性 : 当事务提交或回滚后, 数据库会持久化的保留数据.</li>
<li>隔离性 : 多个事务之间相互独立</li>
<li>一致性 : 事务操作前后, 数据总量不变</li>
</ol>
</li>
<li><p>事务的隔离级别</p>
<ul>
<li><p>概念 : 如果多个事务同时操作同一批数据,, 则会引发一些问题, 需要设置不同的隔离级别来解决这些问题</p>
</li>
<li><p>存在问题种类 :</p>
<ol>
<li>脏读 : 一个事务读取到另一个事务没有提交的数据</li>
<li>不可重复读(虚读) : 在同一个事务中, 两次读取到的数据不一样 </li>
<li>幻读 : 一个事务操作(DML)数据表中所有数据, 另一个事务添加了一条数据, 则第一个事务查询不到自己的修改.</li>
</ol>
</li>
<li><p>隔离级别</p>
<ol>
<li>read uncommitted : 读未提交<ul>
<li>产生的问题 : 脏读, 虚读,幻读</li>
</ul>
</li>
<li>read commited : 读已提交(Oracle默认级别)<ul>
<li>产生的问题 : 虚读,幻读</li>
</ul>
</li>
<li>repeatable read : 可重复读(MySQL默认级别)<ul>
<li>产生的问题 :幻读</li>
</ul>
</li>
<li>serializable : 串行化<ul>
<li>可以解决所有问题</li>
</ul>
</li>
</ol>
<ul>
<li><p>注意 : 隔离级别安全性越高, 效率越低</p>
</li>
<li><p>数据库查询隔离级别</p>
<p><code>select @@tx_isolation;</code></p>
</li>
<li><p>数据库设置隔离级别</p>
<p><code>select global transaction isolation level 级别字符串;</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>JDBC学习</title>
    <url>/2021/11/01/JDBC%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ol>
<li><p>概念 : JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API<span id="more"></span>，可以为多种关系数据库提供统一访问，它由一组用<a class="link"   href="https://link.jianshu.com/?t=https://baike.baidu.com/item/Java%E8%AF%AD%E8%A8%80" >Java语言<i class="fas fa-external-link-alt"></i></a>编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。</p>
</li>
<li><p>快速入门:</p>
<ul>
<li><p>步骤 :</p>
<ol>
<li>导入驱动 jar 包</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql</li>
<li>获取执行 sql 语句的对象 Statement</li>
<li>执行sql, 接受返回结果</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
</li>
<li><p>代码实现 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		1. 导入驱动 jar 包</span></span><br><span class="line"><span class="comment">//		2. 注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//		3. 获取数据库连接对象 Connection</span></span><br><span class="line">		Connection condition = DriverManager.getConnection(</span><br><span class="line">				<span class="string">&quot;jdbc:mysql://localhost:3306/school&quot;</span>,</span><br><span class="line">				<span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//		4. 定义sql</span></span><br><span class="line">		String sql = <span class="string">&quot;update teacher set name = &#x27;chen&#x27; where id = 2&quot;</span>;</span><br><span class="line"><span class="comment">//		5. 获取执行 sql 语句的对象 Statement</span></span><br><span class="line">		Statement statement = condition.createStatement();</span><br><span class="line"><span class="comment">//		6. 执行sql, 接受返回结果</span></span><br><span class="line">		<span class="keyword">int</span> count = statement.executeUpdate(sql);</span><br><span class="line"><span class="comment">//		7. 处理结果</span></span><br><span class="line">		System.out.println(count);</span><br><span class="line"><span class="comment">//		8. 释放资源</span></span><br><span class="line">		statement.close();</span><br><span class="line">		condition.close();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>详解各个对象 :</p>
<ol>
<li><p>DriverManager : 驱动管理对象</p>
<ul>
<li><p>功能 :</p>
<ol>
<li><p>注册驱动</p>
<p><code>static void registerDriver(Driver driver)</code>// 注册驱动</p>
<p>写代码 : <code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code></p>
<p>源码 : 由静态代码块在加载类时执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        DriverManager.registerDriver(new Driver());</span><br><span class="line">    &#125; catch (SQLException var1) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>现在可省略</strong>(mysql5之后)</p>
</li>
<li><p>获取数据库连接</p>
<ul>
<li><p>方法 : <code>static Connection getConnection(String url, String user,  String password)</code></p>
</li>
<li><p>参数 :</p>
<ul>
<li><p>url : 指定连接路径</p>
<p>语法 : jdbc:mysql://ip地址或域名:端口号/数据库名</p>
<p>注意 : 如果连接的是本地的mysql服务器, 且端口默认为3306, 则可以省略两者    </p>
<pre><code>        jdbc:mysql:///数据库名
</code></pre>
</li>
<li><p>user : 用户名</p>
</li>
<li><p>password : 密码</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Connection : 数据库连接对象</p>
<ul>
<li>功能 :<ol>
<li>获取执行 sql 的对象<ul>
<li><code>Statement CreateStatement()</code></li>
<li><code>PrepareStatement prepareStatement(String sql)</code></li>
</ul>
</li>
<li>管理事务 :<ul>
<li>开启事务 : <code>void setAutoCommit(boolean autoCommit) </code>: 调用方法设置参数为false即开启事务</li>
<li>提交事务 : <code>void commit()</code></li>
<li>回滚事务 : <code>void rollback()</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Statement : 执行sql的对象</p>
<ul>
<li><p>执行sql :</p>
<ol>
<li><p><code>boolean execute(String sql)</code> : 可以执行任意的sql</p>
</li>
<li><p><code>int executeUpdate(String sql)</code> : 执行DML和DDL语句</p>
<p>返回值为改变的行数, 可以通过与 0 比较来判断语句执行是否成功</p>
</li>
<li><p><code>ResultSet executeQuery(String sql)</code> : 执行DQL语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Statement statement = <span class="keyword">null</span>;</span><br><span class="line">		Connection connection = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//			定义sql语句</span></span><br><span class="line">			String sql = <span class="string">&quot;insert into teacher values(5, &#x27;zou&#x27;, 21, 1000.50, &#x27;2001-03-05&#x27;)&quot;</span>;</span><br><span class="line"><span class="comment">//			获取Connection对象</span></span><br><span class="line">			connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///school&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//			获取sql语句的执行对象</span></span><br><span class="line">			statement = connection.createStatement();</span><br><span class="line"><span class="comment">//			执行sql</span></span><br><span class="line">			<span class="keyword">int</span> count = statement.executeUpdate(sql);</span><br><span class="line"><span class="comment">//			处理结果</span></span><br><span class="line">			System.out.println(count);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">			throwables.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//			关闭资源</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">					statement.close();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">					connection.close();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">				throwables.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>ResultSet : 结果集对象, 封装查询结果</p>
<p>方法 :</p>
<ul>
<li><p><code>boolean next()</code> : 游标向下移动一行</p>
</li>
<li><p><code>xxx getXxx(参数)</code> : 获取数据</p>
<ul>
<li><p>Xxx代表数据类型 如 : <code>int getInt()</code>, <code>String getString()</code></p>
</li>
<li><p>参数 : </p>
<ol>
<li>int : 传的是列的编号 (从 1 计数) 如 <code>getInt(1)</code></li>
<li>String : 传的是列的名称 如 <code>getInt(&quot;id&quot;)</code></li>
</ol>
</li>
<li><p>使用步骤 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    String name = resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> id = resultSet.getInt(<span class="string">&quot;id &quot;</span>);</span><br><span class="line">    System.out.println(id + <span class="string">&quot; &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>PreparedStatement : 执行sql的对象</p>
<ol>
<li>SQL注入问题 : 在拼接字符串时, 有一些sql的特殊关键字参与字符串的拼接, 会造成安全性问题</li>
<li>SQL注入问题 : 使用PreparedStatement对象解决</li>
<li>预编译的SQL : 使用 ? 来做占位符</li>
<li>步骤 :<ol>
<li>导入驱动</li>
<li>注册驱动</li>
<li>获取数据库连接对象</li>
<li>定义SQL<ul>
<li>注意 : sql 的参数要使用 ? 作为占位符. 如<code>select * from user = ? and password = ?;</code></li>
</ul>
</li>
<li>获取执行sql语句的对象 <code>PreparedStatement preparedStatement(String sql);</code> </li>
<li>给 ? 赋值 :<ul>
<li>方法: setXxx(参数1, 参数2 …)</li>
</ul>
</li>
<li>执行sql, 接受返回结果, 不需要传递sql语句</li>
<li>处理结果</li>
<li>关闭资源</li>
</ol>
</li>
<li>注意 :<ul>
<li><strong>要使用PreparedStatement而不是Statement</strong>原因:<ul>
<li>可以防止SQL注入</li>
<li>效率更高</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="抽取JDBC工具类"><a href="#抽取JDBC工具类" class="headerlink" title="抽取JDBC工具类"></a>抽取JDBC工具类</h2><ul>
<li><p>目的 : 简化书写</p>
</li>
<li><p>分析 :</p>
<ol>
<li><p>抽取注册驱动</p>
</li>
<li><p>抽取一个方法连接对象</p>
<ul>
<li><p>需求 : 不想传递参数</p>
</li>
<li><p>解决 : 使用配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/school</span><br><span class="line">user=root</span><br><span class="line">password=123456</span><br><span class="line">driver=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>抽取一个方法释放资源</p>
</li>
<li><p>代码实现 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">utils</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ClassLoader classLoader = utils.class.getClassLoader();</span><br><span class="line">			URL resource = classLoader.getResource(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">			String path = resource.getPath();</span><br><span class="line">			Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">			properties.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">			url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">			user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">			password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">			driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet resultSet, Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				resultSet.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(statement, connection);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				statement.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				connection.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h2><ol>
<li><p>事务 : 一个包含多个步骤的业务操作, 如果这个业务操作被事务管理, 那么这些操作要么同时成功, 要么同时失败.</p>
</li>
<li><p>操作 :</p>
<ol>
<li>开启事务</li>
<li>回滚 </li>
<li>提交</li>
</ol>
</li>
<li><p>使用Connection对象管理事务 :</p>
<ul>
<li><p>开启事务 : <code>void setAutoCommit(boolean autoCommit) </code>: 调用方法设置参数为false即开启事务</p>
<p>在执行sql之前开启事务</p>
</li>
<li><p>提交事务 : <code>void commit()</code></p>
<p>在所有sql都执行完后提交事务</p>
</li>
<li><p>回滚事务 : <code>void rollback()</code></p>
<p>在catch中回滚事务</p>
</li>
</ul>
</li>
</ol>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><ol>
<li><p>概念 : 存放数据库连接的容器.</p>
<p>当系统初始化好后, 容器被创建, 容器中会申请一些连接对象, 当用户来访问数据库时, 从容器中获取连接对象, 用户访问完之后, 会将连接对象归还给容器.</p>
</li>
<li><p>主流数据库连接池实现</p>
<ol>
<li>C3P0 : 数据连接池实现技术</li>
<li>Druid : 数据库连接池实现技术, 由阿里巴巴提供的</li>
</ol>
</li>
<li><p>实现 :</p>
<ul>
<li>标准接口 : java.sql.DataSource<ul>
<li>方法 :<ul>
<li>获取连接 : <code>getConnection()</code></li>
<li>归还连接: <code>Connection.close()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>C3P0 : 数据库连接池技术</p>
<ul>
<li><p>步骤 : </p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>定义配置文件 :</p>
<ul>
<li>名称 : c3p0.properties 或 c3p0-config.xml</li>
<li>路径 : 放在src目录下即可</li>
</ul>
</li>
<li><p>创建数据库连接池对象 ComboPooledDataSource;</p>
</li>
<li><p>获取连接 : getConnection </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.dataSource.c3p0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">//		1. 创建数据库连接池对象</span></span><br><span class="line">		DataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"><span class="comment">//		2. 获取连接对象</span></span><br><span class="line">		Connection connection = dataSource.getConnection();</span><br><span class="line"><span class="comment">//		3. 打印对象</span></span><br><span class="line">		System.out.println(connection);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>Druid : 数据库连接池实现技术, 由阿里巴巴提供</p>
<ul>
<li><p>步骤</p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>定义配置文件</p>
<ul>
<li>properties文件</li>
<li>名称位置任意</li>
</ul>
</li>
<li><p>加载配置文件</p>
</li>
<li><p>获取数据库连接池对象 : 通过对象工厂来获取 DruidDataSourceFactory</p>
</li>
<li><p>获取连接 : getConnection </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.dataSource.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		1. 导入jar包</span></span><br><span class="line"><span class="comment">//		2. 定义配置文件</span></span><br><span class="line"><span class="comment">//				- properties文件</span></span><br><span class="line"><span class="comment">//				- 名称位置任意</span></span><br><span class="line"><span class="comment">//		3. 加载配置文件</span></span><br><span class="line">		Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">		InputStream is = demo01.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">		properties.load(is);</span><br><span class="line"><span class="comment">//		4. 获取数据库连接池对象 : 通过对象工厂来获取 DruidDataSourceFactory</span></span><br><span class="line">		DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">		Connection connection = dataSource.getConnection();</span><br><span class="line">		System.out.println(connection);</span><br><span class="line"><span class="comment">//		4. 获取连接 : getConnection</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>定义工具类</p>
<ol>
<li>定义一个类 JDBCUtils</li>
<li>提供静态代码块加载配置文件, 初始化连接池对象</li>
<li>提供方法 :<ol>
<li>获取连接</li>
<li>释放资源</li>
<li>获取连接池</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.dataSource.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Druid的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">			InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">			properties.load(is);</span><br><span class="line">			dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet resultSet, Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				resultSet.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(statement, connection);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement statement, Connection connection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				statement.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				connection.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><ul>
<li><p>Spring框架对JDBC的简单封装. 依赖于数据源DataSource</p>
</li>
<li><p>步骤 :</p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>创建JDBCTemplate对象, 依赖于数据源DataSource</p>
<p><code>JdbcTemplate template = new JdbcTemplate(dataSource);</code></p>
</li>
<li><p>调用JdbcTemplate对象的方法来完成CRUD的操作</p>
<ul>
<li><p>update() : 执行DML语句</p>
</li>
<li><p>queryForMap() : 查询后将结果封装为map集合, </p>
<ul>
<li><p>将列名作为key, 将值作为value, 将这条记录封装为一个Map集合</p>
</li>
<li><p>注意 : 这个方法查询的结果集长度只能为1;</p>
</li>
</ul>
</li>
<li><p>queryForList() : 查询后将结果封装为list集合</p>
<ul>
<li>将每条记录封装为一条Map集合, 再装载到List集合中</li>
</ul>
</li>
<li><p>query() : 查询后将结果封装为JavaBean对象</p>
<ul>
<li>RowMapper参数<ul>
<li>一般使用BeanPropertyRowMapper实现类. 可以完成数据到JavaBean的自动封装</li>
<li><code>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>queryForObject() : 查询后将结果封装为对象</p>
<ul>
<li><p>参数中要传返回值的类对象 eg: Long.class</p>
</li>
<li><p>一般用于聚合函数的查询</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenysh.jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chenysh.dataSource.utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JdbcTemplate入门学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		1. 导入jar包</span></span><br><span class="line"><span class="comment">//		2. 创建JDBCTemplate对象, 依赖于数据源DataSource</span></span><br><span class="line">		JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line"><span class="comment">//		3. 调用JdbcTemplate对象的方法来完成CRUD的操作</span></span><br><span class="line">		String sql = <span class="string">&quot;update teacher set age = 20 where id = ?&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> count = template.update(sql, <span class="number">2</span>);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02</span> </span>&#123;</span><br><span class="line">	JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;update emp set bonus = 10000.0 where id = ?&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> count = jdbcTemplate.update(sql, <span class="number">1001</span>);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;insert into emp(id, ename, dept_id) values(?, ?, ?)&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> count = jdbcTemplate.update(sql, <span class="number">1015</span>, <span class="string">&quot;chenysh&quot;</span>, <span class="number">10</span>);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;delete from emp where id = ?&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> count = jdbcTemplate.update(sql, <span class="number">1015</span>);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select * from emp where id = ?&quot;</span>;</span><br><span class="line">		Map&lt;String, Object&gt; result = jdbcTemplate.queryForMap(sql, <span class="number">100</span>);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select * from emp&quot;</span>;</span><br><span class="line">		List&lt;Map&lt;String, Object&gt;&gt; result = jdbcTemplate.queryForList(sql);</span><br><span class="line">		<span class="keyword">for</span> (Map&lt;String, Object&gt; e : result) &#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select * from emp&quot;</span>;</span><br><span class="line">		List&lt;Emp&gt; result = jdbcTemplate.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));</span><br><span class="line">		<span class="keyword">for</span> (Emp e : result) &#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">&quot;select Count(id) from emp&quot;</span>;</span><br><span class="line">		Long result = jdbcTemplate.queryForObject(sql, Long.class);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>xml学习</title>
    <url>/2021/11/03/xml%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><ol>
<li><p>概念 : Extensible Markup Language 可扩展标记语言<span id="more"></span></p>
<ul>
<li><p>可拓展 : 标签都可以自定义</p>
</li>
<li><p>功能 :</p>
<ul>
<li><p>存储数据</p>
<ul>
<li><p>配置文件</p>
</li>
<li><p>在网路中传输</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>xml与html的区别</p>
<ul>
<li>xml标签都是自定义的, html标签都是预定义的.</li>
<li>xml语法严格, html语法松散</li>
<li>xml用来存储数据, html用来展示数据</li>
</ul>
</li>
</ul>
</li>
<li><p>语法 :</p>
<ul>
<li><p>基本语法 :</p>
<ol>
<li>xml的后缀名为.xml</li>
<li>xml第一行必须为文档声明</li>
<li>xml有且只有一个根标签</li>
<li>属性值必须由引号(单双都行)引起来</li>
<li>标签必须正确关闭</li>
<li>xml标签名称区分大小写</li>
</ol>
</li>
<li><p>快速入门 :</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span> = <span class="string">&#x27;1&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>chenysh<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span> = <span class="string">&#x27;2&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>lisi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>19<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>female<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>组成部分 :</p>
<ol>
<li>文档声明 :<ol>
<li>格式: <? xml 属性列表 ?></li>
<li>属性列表 :<ol>
<li>version : 版本号(必须的属性)</li>
<li>encoding : 编码方式 告知解析引擎当前文档使用的字符集.默认值ISO*-8859-1</li>
<li>standalong : 是否独立</li>
</ol>
</li>
</ol>
</li>
<li>指令(不需要了解)</li>
<li>标签 : 标签名称自定义</li>
</ol>
<ul>
<li>规则<ul>
<li>名称可以包含字母数字以及其他字符</li>
<li>名称不能以标点符号开始</li>
<li>名称不能以xml(大小写都不行)开始</li>
<li>名称中不能有空格</li>
</ul>
</li>
</ul>
<ol start="4">
<li>属性 :<ul>
<li>id属性唯一</li>
</ul>
</li>
<li>文本</li>
</ol>
<ul>
<li>CDATA区 : 在该区域中的数据会被原样展示</li>
<li>格式<![CDATA[ 数据 ]]></li>
</ul>
</li>
<li><p>约束</p>
<ul>
<li>规定框架的使用者(程序员) :<ol>
<li>能够在xml中引入约束文档</li>
<li>能够简单的读懂约束文档</li>
</ol>
</li>
<li>分类 :<ol>
<li>DTD : 一种简单的约束技术</li>
<li>Schema : 一种复杂的约束技术</li>
</ol>
</li>
<li>DTD :<ul>
<li>引入dtd文档到xml文档中<ul>
<li>内部DTD : 将约束规则定义在xml文档中(不常用)</li>
<li>外部DTD : 将约束规则定义在外部的DTD文件中<ul>
<li>本地 : <!DOCTYPE 根标签名 SYSYEM "DTD文件的位置"></li>
<li>网络 : <!DOCTYPE 根标签名 PUBLIC "DTD文件名"  "DTD文件的位置URL"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Schema : <ul>
<li>引入 :<ul>
<li>填写xml文档的根元素</li>
<li>引入xsi前缀 , xmlns:xsi=”<a class="link"   href="http://www.w3.org/2001/XMLSchema-instance&quot;" >http://www.w3.org/2001/XMLSchema-instance&quot;<i class="fas fa-external-link-alt"></i></a></li>
<li>引入命名空间和xsd文件. xsi:schemaLocation=”<a class="link"   href="http://www.itcast.cn/xml(%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4)" >http://www.itcast.cn/xml(命名空间)<i class="fas fa-external-link-alt"></i></a> student.xsd(xsd文件)”</li>
<li>为每一个xsd约束声明一个前缀, 作为标识 xmlns:前缀名(如果省略则无前缀) = “<a class="link"   href="http://www.itcast.cn/xml&quot;" >http://www.itcast.cn/xml&quot;<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="解析xml-操作xml文档-将文档中数据读取到内存中"><a href="#解析xml-操作xml文档-将文档中数据读取到内存中" class="headerlink" title="解析xml :操作xml文档, 将文档中数据读取到内存中"></a>解析xml :操作xml文档, 将文档中数据读取到内存中</h2><ul>
<li><p>操作xml文档</p>
<ol>
<li>解析(读取) : 将文档中的数据读取到内存中</li>
<li>写入 : 将内存中的数据保存到xml文件中, 持久化的存储(不常用)</li>
</ol>
</li>
<li><p>解析xml的方式</p>
<ol>
<li>DOM 将标记语言文档一次性加载进内存, 在内存中形成一颗DOM树<ul>
<li>优点 : 操作方便, 可以对文档进行CRUD的全部操作</li>
<li>缺点 : 占内存</li>
</ul>
</li>
<li>SAX 逐行读取, 基于事件驱动<ul>
<li>优点 : 不占内存</li>
<li>缺点 : 只能读取, 不能修改</li>
</ul>
</li>
</ol>
</li>
<li><p>xml常见的解析器</p>
<ol>
<li>JAXP : sun公司提供的解析器, 支持dom和sax(性能不行)</li>
<li>DOM4J : 一款非常优秀的解析器</li>
<li>Jsoup : 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</li>
<li>PULL:Android操作系统内置的解析器, 支持sax方式</li>
</ol>
</li>
<li><p>jsoup</p>
<ul>
<li>快速入门 :<ul>
<li>步骤 :<ol>
<li>导入jar包</li>
<li>获取Document对象</li>
<li>获取对应的标签Elemen对象</li>
<li>获取数据</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		1. 导入jar包</span></span><br><span class="line"><span class="comment">//		2. 获取Document对象</span></span><br><span class="line">		String path = demo01.class.getClassLoader().getResource(<span class="string">&quot;student.xml&quot;</span>).getPath();</span><br><span class="line">		Document document = Jsoup.parse(<span class="keyword">new</span> File(path), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//		3. 获取对应的标签Elemen对象</span></span><br><span class="line">		Elements elements = document.getElementsByTag(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		System.out.println(elements.size());</span><br><span class="line">		Element element = elements.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//		4. 获取数据</span></span><br><span class="line">		String name = element.text();</span><br><span class="line">		System.out.println(name);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象的使用</p>
<ol>
<li><p>Jsoup : 工具类, 可以解析html或xml文档, 返回Document对象</p>
<ul>
<li>parse方法 : 解析html或xml文档, 返回Document对象<ul>
<li>parse(File in, String charsetName) : 解析xml或html文件</li>
<li>parse(String html) : 解析xml或html字符串(不常用)</li>
<li>parse(URL url, int timeoutMillis) : 通过url来获取xml或html文件并解析</li>
</ul>
</li>
</ul>
</li>
<li><p>Document : 文档对象. 代表内存中DOM树</p>
<ul>
<li><p>获取Element对象</p>
<ul>
<li><p>getElementById(String id) : 根据id获取element对象</p>
</li>
<li><p>getElementsByTag(String tagName) : 根据标签名获取Element集合</p>
</li>
<li><p>getElementsByAttribute(String key) : 根据标签名获取Element集合</p>
</li>
<li><p>getElementsByAttributeValue(String key) : 根据属性名对应的属性值来获取Element集合</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Elements : 元素Element对象的集合, 可以当作ArrayList来使用</p>
</li>
<li><p>Element : 元素对象</p>
<ol>
<li><p>获取子元素对象</p>
<ul>
<li><p>getElementById(String id) : 根据id获取element对象</p>
</li>
<li><p>getElementsByTag(String tagName) : 根据标签名获取Element集合</p>
</li>
<li><p>getElementsByAttribute(String key) : 根据标签名获取Element集合</p>
</li>
<li><p>getElementsByAttributeValue(String key) : 根据属性名对应的属性值来获取Element集合</p>
</li>
</ul>
</li>
<li><p>获取属性值</p>
<ul>
<li>String attr(String key) : 根据属性名称获取属性值</li>
</ul>
</li>
<li><p>获取文本内容</p>
<ul>
<li>String text() : 获取所有子标签的文本内容</li>
<li>String html() : 获取标签体内的所有内容, 包括字标签</li>
</ul>
</li>
</ol>
</li>
<li><p>Node : 节点对象</p>
<ul>
<li>是Document和Element父类</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="快捷查询方式"><a href="#快捷查询方式" class="headerlink" title="快捷查询方式"></a>快捷查询方式</h2><ol>
<li>selector : 选择器<ul>
<li>使用的方法 : Elements select(String cssQuery)</li>
<li>语法参考Selector类中定义的语法</li>
</ul>
</li>
<li>Xpath : <strong>XPath</strong>即为<a class="link"   href="https://zh.wikipedia.org/wiki/XML" >XML<i class="fas fa-external-link-alt"></i></a>路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的<a class="link"   href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80" >计算机语言<i class="fas fa-external-link-alt"></i></a>。<ul>
<li>使用Jsoup的Xpath需要额外导入jar包</li>
<li>查询w3cschool参考手册来了解Xpath的语法进行查询</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Xpath学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo06</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, XpathSyntaxErrorException </span>&#123;</span><br><span class="line">		String path = demo01.class.getClassLoader().getResource(<span class="string">&quot;student.xml&quot;</span>).getPath();</span><br><span class="line">		Document document = Jsoup.parse(<span class="keyword">new</span> File(path), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">		JXDocument jxDocument = <span class="keyword">new</span> JXDocument(document);</span><br><span class="line">		List&lt;JXNode&gt; list = jxDocument.selN(<span class="string">&quot;//student&quot;</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		list = jxDocument.selN(<span class="string">&quot;//student/name&quot;</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		list = jxDocument.selN(<span class="string">&quot;//student/name[@size]&quot;</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">		list = jxDocument.selN(<span class="string">&quot;//student/name[@size = &#x27;3&#x27;]&quot;</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>tomcat和servlet学习</title>
    <url>/2021/11/04/tomcat%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="web相关知识"><a href="#web相关知识" class="headerlink" title="web相关知识"></a>web相关知识</h1><ol>
<li>软件架构 :<ol>
<li>C/S : 客户端/服务器端</li>
<li>B/S : 浏览器/服务器端</li>
</ol>
</li>
<li>资源分类<ol>
<li>静态资源 : 所有用户访问后, 得到的结果都是一样的, 称为静态资源, 静态资源可以直接被浏览器解析<ul>
<li>如:html, css, JavaScript</li>
</ul>
</li>
<li>动态资源 : 每个用户访问后, 得到的结果可能不一样, 称为动态资源, 动态资源被访问后, 需要先转换为静态资源, 再返回给浏览器<ul>
<li>如: servlet/jsp, php, asp….</li>
</ul>
</li>
</ol>
</li>
<li>网络通信三要素<ol>
<li>IP : 电子设备(计算机)在网络中的唯一标识</li>
<li>端口 : 应用程序在计算机中的唯一标识 0~65535</li>
<li>传输协议 : 规定了数据传输的规则<ol>
<li>基础协议:<ol>
<li>tcp : 安全协议, 三次握手, 四次挥手. 速度较慢</li>
<li>udp : 不安全协议. 速度快</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="服务器软件介绍"><a href="#服务器软件介绍" class="headerlink" title="服务器软件介绍"></a>服务器软件介绍</h1><ul>
<li><p>服务器 : 安装了服务器软件的计算机</p>
</li>
<li><p>服务器软件 : 接受用户的请求, 处理请求, 做出响应</p>
</li>
<li><p>Web服务器软件 : 接受用户的请求, 处理请求, 做出响应</p>
<ul>
<li>在Web服务器软件中, 可以部署web项目, 让用户通过浏览器来访问这些项目</li>
<li>本质是一个web容器</li>
</ul>
</li>
<li><p>常见的java相关的web服务器软件</p>
<ul>
<li>webLogic : oracle公司, 大型的JavaEE服务器, 支持所有的JavaEE规范, 收费</li>
<li>webSphere : IBM公司, 大型的JavaEE服务器, 支持所有的JavaEE规范, 收费</li>
<li>JBoss : JBoss公司, 大型的JavaEE服务器, 支持所有的JavaEE规范, 收费</li>
<li>Tomcat : Apache基金组织, 中小型的JavaEE服务器, 支持少量的JavaEE规范servlet/jsp, 开源免费</li>
</ul>
</li>
<li><p>JavaEE : Java语言在企业级开发中使用的技术规范的总和, 一共规定了13项大的规范</p>
</li>
</ul>
<h1 id="Tomcat-web服务器软件"><a href="#Tomcat-web服务器软件" class="headerlink" title="Tomcat : web服务器软件"></a>Tomcat : web服务器软件</h1><ol>
<li><p>下载 : <a class="link"   href="https://dlcdn.apache.org/tomcat/tomcat-8/v8.5.72/bin/apache-tomcat-8.5.72-windows-x64.zip" >https://dlcdn.apache.org/tomcat/tomcat-8/v8.5.72/bin/apache-tomcat-8.5.72-windows-x64.zip<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>安装: 目录别有中文</p>
</li>
<li><p>目录结构 :<img src="https://raw.githubusercontent.com/ischenysh/images/master/tomcat%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.27swev6009s0.png" alt="tomcat目录结构"></p>
</li>
<li><p>卸载 : …</p>
</li>
<li><p>启动 : </p>
<ul>
<li>bin/startup.bat</li>
<li>访问 : <a class="link"   href="http://ip地址:8080/" >http://IP地址:8080<i class="fas fa-external-link-alt"></i></a> </li>
<li>一般将tomcat的默认端口号修改为80, 80端口号是http协议的默认端口号<ul>
<li>好处 : 在访问时, 可省略端口号</li>
</ul>
</li>
</ul>
</li>
<li><p>关闭</p>
<ol>
<li>正常关闭<ul>
<li>bin/shutdown.bat</li>
<li>ctrl + c</li>
</ul>
</li>
<li>强制关闭<ul>
<li>直接关</li>
</ul>
</li>
</ol>
</li>
<li><p>配置</p>
<ul>
<li><p>部署项目的方式 :</p>
<ol>
<li><p>直接将项目放在webapps目录下即可</p>
<ul>
<li>/hello : 项目的访问路径    即虚拟目录</li>
<li>简化部署 : 将项目打成war包放入webapps目录下即可</li>
</ul>
</li>
<li><p>配置conf/server.xml文件</p>
<p>在<code>&lt;Host&gt;</code>标签体中配置</p>
<ul>
<li><code>&lt;Context docBase=&quot;项目存放的路径&quot; path=&quot;虚拟目录&quot; /&gt;</code></li>
</ul>
</li>
<li><p>在conf/Catalina\localhost创建xml文件(常用)</p>
<ul>
<li>在文件中写入<code>&lt;Context docBase=&quot;项目存放的路径&quot; /&gt;</code></li>
<li>虚拟目录就是xml文件的名称</li>
</ul>
</li>
</ol>
</li>
<li><p>静态项目和动态项目</p>
<ul>
<li>java动态项目的目录结构<ul>
<li>/项目根目录/WEB-INF目录/下有<ol>
<li>web.xml: web项目的核心配置文件</li>
<li>classes目录 : 放置字节码文件的目录</li>
<li>lib目录 : 放置依赖的jar包</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>将Tomcat集成到IDEA中, 并且创建JavaEE的项目, 部署项目.</p>
</li>
</ul>
</li>
</ol>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><ul>
<li><p>概念 : 运行在服务器端的小程序</p>
<ul>
<li>servlet是一个接口, 定义了Java类被浏览器访问到(tomcat识别)的规则</li>
</ul>
</li>
<li><p>快速入门 :</p>
<ol>
<li><p>创建JavaEE项目</p>
</li>
<li><p>定义一个类, 实现servlet接口</p>
</li>
<li><p>实现接口中抽象方法</p>
</li>
<li><p>配置Servlet</p>
<p>在web.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>任意取名<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>要调用的类的全类名<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>与上文名字相同<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/映射路径<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>执行原理 : </p>
<ol>
<li>当服务器接收到客户端浏览器的请求后, 会解析请求URL路径, 获取访问的Servlet的资源路径</li>
<li>查找web.xml文件, 是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容</li>
<li>如果有, 则会找对应的<code>&lt;servlet-class&gt;</code>全类名</li>
<li>tomcat将字节码文件加载进内存, 并且创建其对象</li>
<li>调用方法</li>
</ol>
</li>
<li><p>Servlet中的生命周期方法</p>
<ol>
<li>被创建 : 执行init方法, 只执行一次<ul>
<li>默认情况下Servlet对象会在第一次访问时被创建</li>
<li>可以配置Servlet对象被创建的时间<ul>
<li>在<code>&lt;servlet&gt;</code>标签下配置<ol>
<li>希望第一次访问时创建<ul>
<li>将<code>&lt;load-on-startup&gt;</code>的值设为负数</li>
</ul>
</li>
<li>希望在服务器启动时创建<ul>
<li>将<code>&lt;load-on-startup&gt;</code>的值设为负数</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>提供服务 : 执行service方法. 可以执行多次<ul>
<li>每调用一次Servlet, service方法就会被执行一次</li>
</ul>
</li>
<li>被销毁 : 执行destroy方法, 只执行一次<ul>
<li>Servlet对象被销毁时执行</li>
<li>只有服务器正常关闭时, 才会执行destroy方法</li>
<li>destroy方法在Servlet对象被销毁前执行, 一般用于释放资源</li>
</ul>
</li>
</ol>
</li>
<li><p>Servlet3.0</p>
<ul>
<li>好处<ol>
<li>支持注解配置, 可以不需要web.xml</li>
</ol>
</li>
<li>步骤<ol>
<li>创建JavaEE项目, 选择Servlet的版本在3.0以上</li>
<li>创建一个类实现Servlet方法</li>
<li>重写方法</li>
<li>在类上使用@WebServlet注解, 进行自动配置<ul>
<li><strong>@WebServlet(“资源路径”)</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>IDEA和tomcat的相关配置</p>
<ol>
<li><p>IDEA会为每一个tomcat部署的项目建立一份配置文件</p>
<ul>
<li>查看控制台的log : <code>Using CATALINA_BASE</code>: </li>
</ul>
</li>
<li><p>工作空间项目   和   tomcat部署的web项目</p>
<ul>
<li>tomcat访问的是 “tomcat部署的web项目”, 在webapp的目录下</li>
<li>WEB-INF目录下的资源不能被浏览器直接访问</li>
</ul>
</li>
</ol>
</li>
<li><p>Servlet项目结构</p>
<pre><code>Servlet                               ---接口
   |
</code></pre>
<p>  GenericServlet                 ———抽象类</p>
<pre><code>   |
</code></pre>
<p>  HttpServlet                          —-抽象类</p>
<ul>
<li><p>GenericServlet  : 将Servlet接口中的其他方法都做了默认的空实现, 只将service方法作为抽象,将来定义Servlet类时, 可以继承它, 只实现service方法即可</p>
</li>
<li><p>HttpServlet  : 对http协议的一种封装, 简化操作</p>
<ul>
<li>使用步骤<ol>
<li>定义类继承HttpServlet</li>
<li>重写doGet/doPost方法</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Servlet相关配置</p>
<ol>
<li>urlpartten : Service访问路径<ol>
<li>一个Servlet可以定义多个路径 : @webServlet({“/a”, “/b”})</li>
<li>路径定义规则(“ * “可作为通配符)<ol>
<li>/xxx : 路径</li>
<li>/xxx/yyy : 多层路径, 目录路径</li>
<li>*.do<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>概念 : Hyper Text Transfer Protocol 超文本传输协议</p>
<ul>
<li>传输协议 : 定义了客户端和服务器端发送通信时, 发送数据的格式</li>
<li>特点 : <ol>
<li>基于TCP/IP的高级协议</li>
<li>默认的端口号 : 80</li>
<li>基于请求/响应模型 : 一次请求对应一次响应</li>
<li>无状态的 : 每次请求之间相互独立, 不能交互数据</li>
</ol>
</li>
<li>历史版本<ul>
<li>1.0 : 每次请求都会建立新的连接</li>
<li>1.1 : 能复用连接</li>
</ul>
</li>
</ul>
</li>
<li><p>请求消息数据格式</p>
<ol>
<li><p>请求行</p>
<p>请求方式 请求url 请求协议/版本号</p>
<p>POST /login.html HTTP/1.1</p>
<ul>
<li>请求方式 : <ul>
<li>HTTP协议中有其中请求方式, 常用的有两种<ol>
<li>GET : <ul>
<li>请求参数在请求行中,在url后</li>
<li>请求的url有长度限制</li>
<li>不太安全</li>
</ul>
</li>
<li>POST<ul>
<li>请求参数在请求体中</li>
<li>请求的url长度没有限制</li>
<li>相对安全</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求头 : 客户端浏览器告诉服务器一些信息</p>
<p>请求头名称 : 请求头值</p>
<ul>
<li>常见的请求头 : <ol>
<li>User-Agent : 浏览器告知服务器, 用户使用的浏览器版本信息<ul>
<li>可以在服务器端获取该头信息, 解决浏览器的兼容问题</li>
</ul>
</li>
<li>referer : <a class="link"   href="http://localhost/Tomcat/login.html" >http://localhost/Tomcat/login.html<i class="fas fa-external-link-alt"></i></a><ul>
<li>告诉服务器, 当前请求的来源<ul>
<li>作用:<ol>
<li>防盗链</li>
<li>统计工作</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>请求空行</p>
<ul>
<li>分隔请求头和请求体</li>
</ul>
</li>
<li><p>请求体(正文)</p>
<ul>
<li>封装POST请求消息的请求体的</li>
</ul>
</li>
<li><p>字符串格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /login.html HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36</span><br><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: JSESSIONID=77DF4662FE754A439CD0FB56C1BCAFF9; Idea-f4d8557b=20551331-9bc8-4e86-ab3d-0f04c9c2045d; Idea-f4d8557c=10d75bc0-2de0-4ee0-852c-d072dc3c44ca; Webstorm-4e75f43=061788ec-d849-4ad7-acc2-d8b44fefe312</span><br><span class="line"></span><br><span class="line">username = zhangsan</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>响应消息：服务器端发送给客户端的数据</p>
<ul>
<li>数据格式：<ol>
<li>响应行<ol>
<li>组成：协议/版本 响应状态码 状态码描述</li>
<li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。<ol>
<li>状态码都是3位数字 </li>
<li>分类：<ol>
<li>1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</li>
<li>2xx：成功。代表：200</li>
<li>3xx：重定向。代表：302(重定向)，304(访问缓存)</li>
<li>4xx：客户端错误。<ul>
<li>代表：<ul>
<li>404（请求路径没有对应的资源） </li>
<li>405：请求方式没有对应的doXxx方法</li>
</ul>
</li>
</ul>
</li>
<li>5xx：服务器端错误。代表：500(服务器内部出现异常)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>响应头：<ol>
<li>格式：头名称： 值</li>
<li>常见的响应头：<ol>
<li>Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式</li>
<li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据<ul>
<li>值：<ul>
<li>in-line:默认值,在当前页面内打开</li>
<li>attachment;filename=xxx：以附件形式打开响应体。文件下载</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>响应空行</li>
<li>响应体:传输的数据</li>
</ol>
</li>
<li>响应字符串格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Content-Length: 101</span><br><span class="line">Date: Wed, 06 Jun 2018 07:08:42 GMT</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  hello , response</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2></li>
</ul>
</li>
</ul>
<ol>
<li><p>request对象和response对象的原理</p>
<ol>
<li>request和response对象是由服务器创建的。我们来使用它们</li>
<li>request对象是来获取请求消息，response对象是来设置响应消息</li>
</ol>
</li>
<li><p>request对象继承体系结构：<br> ServletRequest        –    接口</p>
<pre><code> |    继承
</code></pre>
<p> HttpServletRequest    – 接口</p>
<pre><code> |    实现
</code></pre>
<p> org.apache.catalina.connector.RequestFacade 类(tomcat)</p>
</li>
<li><p>request功能：</p>
<ol>
<li><p>获取请求消息数据</p>
<ol>
<li><p>获取请求行数据</p>
<ul>
<li><p>GET /day14/demo1?name=zhangsan HTTP/1.1</p>
</li>
<li><p>方法：</p>
<ol>
<li><p>获取请求方式 ：GET</p>
<ul>
<li>String getMethod()  </li>
</ul>
</li>
<li><p><strong>获取虚拟目录</strong>：/day14</p>
<ul>
<li>String getContextPath()</li>
</ul>
</li>
<li><p>获取Servlet路径: /demo1</p>
<ul>
<li>String getServletPath()</li>
</ul>
</li>
<li><p>获取get方式请求参数：name=zhangsan</p>
<ul>
<li>String getQueryString()</li>
</ul>
</li>
<li><p><strong>获取请求URI</strong>：/day14/demo1</p>
<ul>
<li><p>String getRequestURI():        /day14/demo1</p>
</li>
<li><p>StringBuffer getRequestURL()  :<a class="link"   href="http://localhost/day14/demo1" >http://localhost/day14/demo1<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>URL:统一资源定位符 ： <a class="link"   href="http://localhost/day14/demo1" >http://localhost/day14/demo1<i class="fas fa-external-link-alt"></i></a>    中华人民共和国</p>
</li>
<li><p>URI：统一资源标识符 : /day14/demo1                    共和国</p>
</li>
</ul>
</li>
<li><p>获取协议及版本：HTTP/1.1</p>
<ul>
<li>String getProtocol()</li>
</ul>
</li>
<li><p>获取客户机的IP地址：</p>
<ul>
<li>String getRemoteAddr()</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>获取请求头数据</p>
<ul>
<li>方法：<ul>
<li><strong>String getHeader(String name)</strong>:通过请求头的名称获取请求头的值</li>
<li><code>Enumeration&lt;String&gt; getHeaderNames()</code>:获取所有的请求头名称</li>
</ul>
</li>
</ul>
</li>
<li><p>获取请求体数据:</p>
<ul>
<li><p>请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</p>
</li>
<li><p>步骤：</p>
<ol>
<li><p>获取流对象</p>
<ul>
<li> BufferedReader getReader()：获取字符输入流，只能操作字符数据</li>
<li>ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据<ul>
<li>在文件上传知识点后讲解</li>
</ul>
</li>
</ul>
</li>
<li><p>再从流对象中拿数据</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>其他功能：</p>
<ol>
<li><p>获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数</p>
<ol>
<li>String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123</li>
<li>String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game</li>
<li><code>Enumeration&lt;String&gt; getParameterNames()</code>:获取所有请求的参数名称</li>
<li><code>Map&lt;String,String[]&gt; getParameterMap()</code>:获取所有参数的map集合</li>
</ol>
<ul>
<li>中文乱码问题：<ul>
<li>get方式：tomcat 8 已经将get方式乱码问题解决了</li>
<li>post方式：会乱码<ul>
<li>解决：在获取参数前，设置request的编码<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求转发：一种在服务器内部的资源跳转方式</p>
<ol>
<li><p>步骤：</p>
<ol>
<li>通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)</li>
<li>使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) </li>
</ol>
</li>
<li><p>特点：</p>
<ol>
<li>浏览器地址栏路径不发生变化</li>
<li>只能转发到当前服务器内部资源中。</li>
<li>转发是一次请求</li>
</ol>
</li>
</ol>
</li>
<li><p>共享数据：</p>
<ul>
<li>域对象：一个有作用范围的对象，可以在范围内共享数据</li>
<li>request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</li>
<li>方法：<ol>
<li>void setAttribute(String name,Object obj):存储数据</li>
<li>Object getAttitude(String name):通过键获取值</li>
<li>void removeAttribute(String name):通过键移除键值对</li>
</ol>
</li>
</ul>
</li>
<li><p>获取ServletContext：</p>
<ul>
<li>ServletContext getServletContext()</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="BeanUtils工具类，简化数据封装"><a href="#BeanUtils工具类，简化数据封装" class="headerlink" title="BeanUtils工具类，简化数据封装"></a>BeanUtils工具类，简化数据封装</h2><ul>
<li>用于封装JavaBean的</li>
</ul>
<ol>
<li>JavaBean：标准的Java类<ol>
<li>要求：<ol>
<li>类必须被public修饰</li>
<li>必须提供空参的构造器</li>
<li>成员变量必须使用private修饰</li>
<li>提供公共setter和getter方法</li>
</ol>
</li>
<li>功能：封装数据</li>
</ol>
</li>
<li>概念：<br> 成员变量：<br> 属性：setter和getter方法截取后的产物<pre><code> 例如：getUsername() --&gt; Username--&gt; username
</code></pre>
</li>
<li>方法：<ol>
<li>setProperty()</li>
<li>getProperty()</li>
<li>populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</li>
</ol>
</li>
</ol>
<h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><pre><code>* 功能：设置响应消息
    1. 设置响应行
        1. 格式：HTTP/1.1 200 ok
        2. 设置状态码：setStatus(int sc) 
    2. 设置响应头：setHeader(String name, String value) 
        
    3. 设置响应体：
        * 使用步骤：
            1. 获取输出流
                * 字符输出流：PrintWriter getWriter()

                * 字节输出流：ServletOutputStream getOutputStream()

            2. 使用输出流，将数据输出到客户端浏览器


* 案例：
    1. 完成重定向
        * 重定向：资源跳转的方式
        * 代码实现：
            //1. 设置状态码为302
            response.setStatus(302);
            //2.设置响应头location
            response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);


            //简单的重定向方法
            response.sendRedirect(&quot;/day15/responseDemo2&quot;);

        * 重定向的特点:redirect
            1. 地址栏发生变化
            2. 重定向可以访问其他站点(服务器)的资源
            3. 重定向是两次请求。不能使用request对象来共享数据
        * 转发的特点：forward
            1. 转发地址栏路径不变
            2. 转发只能访问当前服务器下的资源
            3. 转发是一次请求，可以使用request对象来共享数据
        
        * forward 和  redirect 区别
            
        * 路径写法：
            1. 路径分类
                1. 相对路径：通过相对路径不可以确定唯一资源
                    * 如：./index.html
                    * 不以/开头，以.开头路径

                    * 规则：找到当前资源和目标资源之间的相对位置关系
                        * ./：当前目录
                        * ../:后退一级目录
                2. 绝对路径：通过绝对路径可以确定唯一资源
                    * 如：http://localhost/day15/responseDemo2        /day15/responseDemo2
                    * 以/开头的路径

                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出
                        * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)
                            * 建议虚拟目录动态获取：request.getContextPath()
                            * &lt;a&gt; , &lt;form&gt; 重定向...
                        * 给服务器使用：不需要加虚拟目录
                            * 转发路径
</code></pre>
<p>​<br>​                        </p>
<pre><code>    2. 服务器输出字符数据到浏览器
        * 步骤：
            1. 获取字符输出流
            2. 输出数据

        * 注意：
            * 乱码问题：
                1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1
                2. 设置该流的默认编码
                3. 告诉浏览器响应体使用的编码

                //简单的形式，设置编码，是在获取流之前设置
                response.setContentType(&quot;text/html;charset=utf-8&quot;);
    3. 服务器输出字节数据到浏览器
        * 步骤：
            1. 获取字节输出流
            2. 输出数据

    4. 验证码
        1. 本质：图片
        2. 目的：防止恶意表单注册
</code></pre>
<h2 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h2><pre><code>1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信
2. 获取：
    1. 通过request对象获取
        request.getServletContext();
    2. 通过HttpServlet获取
        this.getServletContext();
3. 功能：
    1. 获取MIME类型：
        * MIME类型:在互联网通信过程中定义的一种文件数据类型
            * 格式： 大类型/小类型   text/html        image/jpeg

        * 获取：String getMimeType(String file)  
    2. 域对象：共享数据
        1. setAttribute(String name,Object value)
        2. getAttribute(String name)
        3. removeAttribute(String name)

        * ServletContext对象范围：所有用户所有请求的数据
    3. 获取文件的真实(服务器)路径
        1. 方法：String getRealPath(String path)  
             String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问
             System.out.println(b);
    
            String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问
            System.out.println(c);
    
            String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问
            System.out.println(a);
</code></pre>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>* 文件下载需求：
    1. 页面显示超链接
    2. 点击超链接后弹出下载提示框
    3. 完成图片文件下载


* 分析：
    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
    2. 任何资源都必须弹出下载提示框
    3. 使用响应头设置资源的打开方式：
        * content-disposition:attachment;filename=xxx


* 步骤：
    1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename
    2. 定义Servlet
        1. 获取文件名称
        2. 使用字节输入流加载文件进内存
        3. 指定response的响应头： content-disposition:attachment;filename=xxx
        4. 将数据写出到response输出流


* 问题：
    * 中文文件问题
        * 解决思路：
            1. 获取客户端使用的浏览器版本信息
            2. 根据不同的版本信息，设置filename的编码方式不同
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>会话技术与JSP学习</title>
    <url>/2021/11/07/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%E4%B8%8EJSP%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h1><ol>
<li>会话 : 一次会话中包含多次请求和响应<ul>
<li>一次会话 : 浏览器在第一次给服务器资源发送请求, 会话建立, 直到有一方断开为止</li>
</ul>
</li>
<li>功能 : 在一次会话的范围内多次请求间, 共享数据</li>
<li>方式 : <ol>
<li>客户端会话技术 : Cookie</li>
<li>服务端会话技术 : Session</li>
</ol>
</li>
</ol>
<h2 id="客户端会话技术-Cookie"><a href="#客户端会话技术-Cookie" class="headerlink" title="客户端会话技术 : Cookie"></a>客户端会话技术 : Cookie</h2><ol>
<li><p>概念 : 客户端会话技术, 将数据保存在客户端</p>
</li>
<li><p>快速入门 : </p>
<ul>
<li><p>使用步骤 : </p>
<ol>
<li><p>创建Cookie对象, 绑定数据 </p>
<p><code>new Cookie(String name, String value)</code></p>
</li>
<li><p>发送Cookie对象</p>
<p><code>response.addCookie(Cookie cookie)</code></p>
</li>
<li><p>获取Cookie对象, 拿到数据</p>
<p><code>Cookie[] request.getCookies()</code></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>实现原理</p>
<ul>
<li><p>基于响应头set-cookie和请求头cookie实现</p>
<p><img src="https://raw.githubusercontent.com/ischenysh/images/master/cookie1.1y0w3g0h1k2o.png" alt="cookie1"></p>
</li>
</ul>
</li>
<li><p>cookie的细节</p>
<ol>
<li>一次可以发送多个cookie, 创建多个cookie即可</li>
<li>cookie的保存时间中<ol>
<li>默认情况下, 当浏览器关闭时, cookie被销毁</li>
<li>持久化保存 : <ul>
<li><code>setMaxAge(int seconds)</code><ol>
<li>正数 : 将cookie数据写到硬盘的文件中. 持久化存储. seconds代表存活的秒数</li>
<li>负数 : 默认情况</li>
<li>0 : 删除cookie信息</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li>在tomcat 8之前, cookie不支持存储中文, 需要转码(一般使用URL编码%E3), 在tomcat 8之后支持存储中文数据当不支持特殊字符需要编码与解码<ol>
<li>编码 : <code>String URLEncode.encode(String s, String enc)</code></li>
<li>解码 : <code>String URLDecode.decode(String s, String enc)</code></li>
</ol>
</li>
<li>在一个tomcat服务器下, 多个项目之间的cookie共享问题<ul>
<li>默认情况下不能共享</li>
<li><code>setPath(String path)</code> : 设置cookie的获取范围, 默认情况下为当前的虚拟目录</li>
<li>如果要共享, 则可以将path设置为 “/“ </li>
</ul>
</li>
<li>不同的tomcat服务器间cookie共享数据<ul>
<li><code>setDomain(String path)</code> : 如果设置一级域名相同, 那么多个服务器之间cookie可以共享<ul>
<li><code>setDomain(&quot;.baidu.com&quot;)</code>. 那么tieba.baidu.com和news.baidu.com中cookie可以共享</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Cookie的特点和作用</p>
<ol>
<li>cookie存储在客户端浏览器</li>
<li>浏览器对于单个cookie的大小有限制(4kb) 以及对同一个域名下的总cookie数量也有限制(20个)</li>
</ol>
<ul>
<li>作用 : <ol>
<li>cookie一般用于存储少量的不太敏感的数据</li>
<li>在不登录的情况下对客户端身份的识别</li>
</ol>
</li>
</ul>
</li>
<li><p>案例 : 记住上一次访问时间</p>
<ol>
<li>需求<ol>
<li>访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。</li>
<li>如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="JSP-入门学习"><a href="#JSP-入门学习" class="headerlink" title="JSP : 入门学习"></a>JSP : 入门学习</h2><ol>
<li>概念 : <ul>
<li>Java Server Pages : java服务器端页面<ul>
<li>可以理解为 : 一个特殊的页面, 其中既可以指定定义html标签, 又可以定义java代码</li>
<li>可以简化书写</li>
</ul>
</li>
</ul>
</li>
<li>原理<ul>
<li>JSP本质上就是一个Servlet</li>
</ul>
</li>
<li>JSP的脚本 : JSP定义java代码的方式<ol>
<li>&lt;% 代码 %&gt; : 定义的java代码, 在service方法中, 能写什么, 该脚本就可以写什么</li>
<li>&lt;%! 代码 %&gt; : 定义的java代码, 在JSP转换后的java类的成员位置, </li>
<li>&lt;%= 代码 %&gt; : 定义的java代码, 会输出到页面上, 输出语句中可以定义什么, 该脚本就可以定义什么</li>
</ol>
</li>
<li>JSP的内置对象 : <ul>
<li>在JSP页面中不需要获取和创建, 可以直接使用的对象</li>
<li>JSP一共有九个内置对象<ul>
<li>request</li>
<li>response</li>
<li>out : 可以将数据直接输出到页面上. 和response.getWriter()类似<ul>
<li>但服务器总会优先response.getWriter()对象输出, 所以尽量使用out对象进行输出</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>案例 : 记住上一次访问时间<ol>
<li>需求<ol>
<li>访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。</li>
<li>如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session :"></a>Session :</h2><ol>
<li><p>概念 : 服务器端会话技术, 再一次会话中的多次请求间共享数据, 将数据保存在服务器端的对象中, HttpSession</p>
</li>
<li><p>快速入门 : </p>
<ol>
<li><p>获取HttpSession对象 : </p>
<p><code>request.getSession()</code></p>
</li>
<li><p>使用HttpSession对象 : </p>
<ol>
<li><code>void setAttribute(String name,Object obj)</code>:存储数据</li>
<li><code>Object getAttitude(String name)</code>:通过键获取值</li>
<li><code>void removeAttribute(String name)</code>:通过键移除键值对</li>
</ol>
</li>
<li><p>原理</p>
<ul>
<li>Session的实现是依赖于Cookie的.</li>
</ul>
</li>
<li><p>细节 :  </p>
<ol>
<li><p>当客户端关闭后, 服务器不关闭, 两次得到的session是否相同</p>
<ul>
<li><p>默认情况下不同</p>
</li>
<li><p>如果需要相同, 则可以创建Cookie对象, 键为JSESSIONID, 设置最大存活时间, 让cookie持久化保存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> cookie(<span class="string">&quot;JSESSIONID&quot;</span>. session.getId());</span><br><span class="line">cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>客户端不关闭, 服务器关闭后,两次得到的session是否相同</p>
<ul>
<li>不是同一个, 但要确保数据不丢失<ul>
<li>session的钝化 : <ul>
<li>在服务器正常关闭之前, 将session对象序列化到硬盘上</li>
</ul>
</li>
<li>session的活化 : <ul>
<li>在服务器启动后, 将session文件转化为内存中的session对象即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>session的销毁时间</p>
<ol>
<li><p>服务器关闭</p>
</li>
<li><p>session对象调用invalidate()</p>
</li>
<li><p>session默认失效时间 30分钟</p>
<p>选择配置修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>session的特点</p>
<ol>
<li>session用于存储一次会话的多次请求数据, 存在服务器端</li>
<li>session可以存储任意数据类型, 任意大小数据</li>
</ol>
<ul>
<li>session与cookie的区别<ol>
<li>session存储在服务器端, cookie存储在客户端</li>
<li>session没有数据大小限制, cookie有</li>
<li>session数据安全, cookie相对不安全</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="案例-验证码"><a href="#案例-验证码" class="headerlink" title="案例 : 验证码"></a>案例 : 验证码</h2><p>案例需求：    </p>
<ol>
<li>访问带有验证码的登录页面login.jsp</li>
<li> 用户输入用户名，密码以及验证码。</li>
</ol>
<ul>
<li>如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误</li>
<li>如果验证码输入有误，跳转登录页面，提示：验证码错误</li>
<li>如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JSP学习</title>
    <url>/2021/11/08/JSP%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><pre><code>1. 指令
    * 作用 : 用于配置JSP页面, 导入资源文件
    * 格式 : 
        &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2... %&gt;
    * 分类 : 
        1. page    : 配置JSP页面
            * contentType : 等同于reponse.setContentType()
                1. 设置响应体的mime类型以及字符集
                2. 设置当前JSP页面的编码(只适用于高级的开发工具)
            * import         : 导包
            * errorPage     :当前页面发生异常后会自动跳转到的页面
            * isErrorPage     : 标识当前页面是否为错误页面(默认为false)
        2. include : 让页面包含指定的页面. 即导入页面的资源文件
            * &lt;%@include file=&quot;top.jsp&quot;%&gt;
        3. taglib  : 导入资源
            * &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
                * prefix : 自定义前缀
2. 注解
    1. html注释 :
        * &lt;!-- --&gt;     : 只能注释html代码片段
    2. JSP注释 : 推荐使用
        * &lt;%-- --%&gt; : 可以注释所有内容

3. 内置对象
    * 在JSP页面中不需要创建, 可以直接使用
    * 一共有九个 : 
            变量名                真实类型                        作用
        * pageContext            PageContext                    当前页面共享数据 还可以获得其他八个内部对象
        * request                HttpServletRequest            一次请求访问的多个资源间
        * session                HttpSession                    一个会话的多次请求间
        * application            ServletContext                所有用户间共享数据
        * response                HttpServletResponse            响应对象
        * page                    Object                        当前页面(Serclet)的对象 this
        * out                    JspWriter                    输出对象, 将数据输出到页面
        * config                ServletConfig                Servlet的配置对象
        * exception                Throwable                    异常对象
</code></pre>
<h2 id="MVC开发模式"><a href="#MVC开发模式" class="headerlink" title="MVC开发模式"></a>MVC开发模式</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/image.1tbmqz2yj7k0.png" alt="image"></p>
<pre><code>1. MVC : 
    1. M : Model, 模型. JavaBean
        * 完成具体的业务操作, 如 : 查询数据库, 封装对象
    2. V : View, 视图, JSP
        * 展示数据
    3. C : Controller : 控制器, Servlet
        * 获取用户输入
        * 调用模型
        * 将数据交给视图进行展示
    
    * 优缺点 : 
        1. 优点 : 
            1. 耦合度低, 方便维护, 可以利于分工协作
            2. 重用性高
        2. 缺点 : 
            1. 使得项目结构变得复杂, 对开发人员要求变高
</code></pre>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><pre><code>1. 概念 : Expression Language 表达式语言
2. 作用 : 替换和简化jsp页面中java代码的编写
3. 语法 : $&#123;表达式&#125;
4. 注意 : 
    * jsp默认支持el表达式, 如果要忽略el表达式
        1. 设置jsp的page指令中 : isELIgnored=&quot;true&quot; 忽略当前页面的所有el表达式
        2. \$&#123;表达式&#125; : 忽略当前这个el表达式

5. 使用 : 
    1. 运算 : 
        * 运算符 : 
            1. 算数运算符
            2. 比较运算符
            3. 逻辑运算符
            4. 空运算符 : empty
                * 功能 : 用于判断字符串, 集合, 数组对象是否为null或长度为0

    2. 获取值
        1. el表达式只能从域对象获取值
        2. 语法 :
            1. $&#123;域名称.键名&#125; : 从指定域中获取指定键的值
                * 域名称 : 
                    1. pageScope            ---&gt;        pageContext
                    2. requestScope            ---&gt;        request
                    3. sessionScope            ---&gt;        session
                    4. applicationScope        ---&gt;        application(ServletContext)

            2. $&#123;键名&#125; : 表示依次从最小的域开始查询是否有该键对应的值, 直到找到位置
            3. 获取对象, List集合, Map集合的值
                1. 对象 : $&#123;域名称.键名,属性名&#125;
                    * 本质会去调用对象的getter方法

                2. List集合 : $&#123;域名称.键名[索引]&#125;
                3. Map集合 : $&#123;域名称.键名[&quot;key名称&quot;]&#125;

    3. 隐式对象 : 
        * el表达式中有11个隐式对象
        * pageContext : 
            * 获取jsp其他的八个内置对象
                * $&#123;pageContext.request.contextPath&#125; : 动态获取虚拟目录
</code></pre>
<h2 id="JSPL标签"><a href="#JSPL标签" class="headerlink" title="JSPL标签"></a>JSPL标签</h2><pre><code>1. 概念 : JavaServer Page Tag Library JSP标准标签库
    * 是由Apache组织提供的开源的免费的jsp标签

2. 作用 : 用于简化和替换jsp页面上的java代码


3. 使用步骤 : 
    1. 导入jstl相关的jar包
    2. 导入标签库 &lt;%@ taglib %&gt;
    3. 使用标签

4. 常用的JSTL标签
    1. if : 相当与java代码中的if语句
        1. 属性 : 
            * test为必须属性, 接收boolean表达式
                * 如果表达式结果为true, 则显示if标签体的内容, 反之则不显示
                * 一般情况下与el表达式一起使用

        2. 注意 :
            * if标签没有else, 需要再定义一个c:if标签

    2. choose : 相当于java代码中的switch语句
        1. 使用choose标签声明                    相当于switch声明
        2. 使用when标签做判断                    相当于case
        3. 使用otherwise标签做其他情况的说明    相当于default


    3. foreach : 相当于java代码的for语句
        1. 完成重复性的操作
            * 属性 :
                * begin : 开始值
                * end     : 结束值
                * var     : 临时变量
                * steps : 步长
                * varStatus : 循环状态对象
                    * index : 容器中元素的索引, 从0开始
                    * count : 循环次数, 从1开始

        2. 遍历容器 : 
            * 属性 : 
                * items : 容器对象
                * var     : 容器中元素的临时变量
                * varStatus : 循环状态对象
                    * index : 容器中元素的索引, 从0开始
                    * count : 循环次数, 从1开始
</code></pre>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/image.4w8xrr0s34a0.png" alt="image"><br>    1. 界面层(表示层) : 用户看的页面, 用户可以通过界面上的组件与服务器进行交互<br>    2. 业务逻辑层 : 处理业务逻辑<br>    3. 数据访问层 : 操作数据存储文件</p>
<h2 id="案例-用户信息列表展示"><a href="#案例-用户信息列表展示" class="headerlink" title="案例 : 用户信息列表展示"></a>案例 : 用户信息列表展示</h2><pre><code>1. 需求 : 用户信息的CRUD
2. 设计 : 
    1. 技术选型 : servlet+JSP+MySQL+JDBCTemplet+Duird+BeanUtils+tomcat 
    2. 数据库的设计
        create table user(
          id int primary key auto_increment,
          name varchar(30) not null,
          gender varchar(5),
          age int,
          address varchar(50),
          qq varchar(20),
          email varchar(20)
        );


3. 开发 :
    1. 环境搭建 :
        1. 创建数据库环境
        2. 城创建项目, 导入需要的jar包

    2. 编码

4. 测试
5. 部署运维
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Filter学习</title>
    <url>/2021/11/10/Filter%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Fileter-过滤器"><a href="#Fileter-过滤器" class="headerlink" title="Fileter : 过滤器"></a>Fileter : 过滤器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 概念</span><br><span class="line">	* 当访问服务器的资源时, 过滤器可以将请求拦截下来, 完成一些特殊的功能.</span><br><span class="line">	* 过滤器的作用 : </span><br><span class="line">		* 一般用于完成通用的操作. 如: 登陆验证, 统一编码处理, 敏感字符过滤...</span><br><span class="line">2. 快速入门 : 	</span><br><span class="line">	1. 步骤 : </span><br><span class="line">		1. 定义一个类, 实现Filter接口</span><br><span class="line">		2. 复写方法</span><br><span class="line">		3. 配置拦截路径</span><br><span class="line">			1. web.xml</span><br><span class="line">			2. 注解</span><br><span class="line"></span><br><span class="line">	2. 代码 : </span><br><span class="line">		@WebFilter(&quot;/index.jsp&quot;)// 访问index.jsp之前, 会执行该过滤器</span><br><span class="line">		public class FilterDemo01 implements Filter &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">			@Override</span><br><span class="line">			public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">				System.out.println(&quot;我被执行了!&quot;);</span><br><span class="line">				// 放行</span><br><span class="line">				filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">			@Override</span><br><span class="line">			public void destroy() &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">3. 过滤器细节 :</span><br><span class="line">	1. web.xml的配置	</span><br><span class="line">		    &lt;filter&gt;</span><br><span class="line">	        &lt;filter-name&gt;demo01&lt;/filter-name&gt;</span><br><span class="line">	        &lt;filter-class&gt;com.chenysh.web.filter.FilterDemo01&lt;/filter-class&gt;</span><br><span class="line">	    &lt;/filter&gt;</span><br><span class="line">	    &lt;filter-mapping&gt;</span><br><span class="line">	        &lt;filter-name&gt;demo01&lt;/filter-name&gt;</span><br><span class="line">	        &lt;!--拦截路径--&gt;</span><br><span class="line">	        &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt;</span><br><span class="line">	    &lt;/filter-mapping&gt;</span><br><span class="line">	2. 过滤器的执行流程</span><br><span class="line">		1. 执行过滤器</span><br><span class="line">		2. 执行放行后的资源</span><br><span class="line">		3. 继续执行下面的代码</span><br><span class="line">	3. 过滤器的生命周期方法</span><br><span class="line">		1. init:在服务器启动后, 会创建Filter对象, 然后调用init方法, 只执行一次, 用于加载资源</span><br><span class="line">		2. doFilter:每次请求被拦截后, 都会执行</span><br><span class="line">		3. destroy:在服务器正常关闭之前执行, 用于释放资源</span><br><span class="line">	4. 过滤器配置详解</span><br><span class="line">		* 拦截路径配置 :</span><br><span class="line">			1. 具体资源路径: /index.jsp  只有访问index.jsp资源时, 过滤器才执行</span><br><span class="line">			2. 目录拦截: /user/*         访问/user目录下的所有资源, 过滤器都会执行</span><br><span class="line">			3. 后缀名拦截: *.jsp			访问后缀名为jsp的资源, 过滤器都会执行</span><br><span class="line">			4. 拦截所有资源: /* 			访问所有的资源, 过滤器都会执行</span><br><span class="line">		* 拦截方式配置 : </span><br><span class="line">			* 注解配置 :</span><br><span class="line">				* 设置dispatcherTypes属性</span><br><span class="line">					1. REQUEST : 默认值. 浏览器直接请求资源</span><br><span class="line">					2. FORWARD : 转发访问资源</span><br><span class="line">					3. INCLUDE : 包含访问资源</span><br><span class="line">					4. ERROR   : 错误跳转资源</span><br><span class="line">					5. ASYNC   : 异步访问资源</span><br><span class="line">				* web.xml配置</span><br><span class="line">					* 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可</span><br><span class="line"></span><br><span class="line">	5. 过滤器链(配置多个过滤器)	</span><br><span class="line">		* 执行顺序 : 如果有两个过滤器 : 过滤器1与过滤器2</span><br><span class="line">			1. 过滤器1</span><br><span class="line">			2. 过滤器2</span><br><span class="line">			3. 资源执行</span><br><span class="line">			4. 过滤器2</span><br><span class="line">			5. 过滤器1</span><br><span class="line">		</span><br><span class="line">		* 过滤器执行先后问题 : </span><br><span class="line">			1. 注解配置: 按照**类名**的字符串比较规则, 小的先执行</span><br><span class="line">				* FilterDemo01比FilterDemo02先执行</span><br><span class="line">			2. web.xml配置 : &lt;filter-mapping&gt;的定义顺序决定, 谁在上面谁先执行</span><br></pre></td></tr></table></figure>


<h1 id="增强对象的功能"><a href="#增强对象的功能" class="headerlink" title="增强对象的功能"></a>增强对象的功能</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 设计模式:一些通用的解决固定问题的方式</span><br><span class="line">	1.	装饰模式</span><br><span class="line">	2.	代理模式</span><br><span class="line">		* 概念 : </span><br><span class="line">			1. 真实对象 : 被代理的对象</span><br><span class="line">			2. 代理对象</span><br><span class="line">			3. 代理模式 : 代理对象代理真实对象, 达到增强真实对象功能的目的</span><br><span class="line">		* 实现方式 :</span><br><span class="line">			1. 静态代理 : 有一个类文件描述代理模式</span><br><span class="line">			2. 动态代理 : 在内存中形成代理类</span><br><span class="line">			</span><br><span class="line">				* 实现步骤 : </span><br><span class="line">					1. 代理对象和真实对象实现同样的接口</span><br><span class="line">					2. 代理对象 = Proxy.newProxyInstance();</span><br><span class="line">					3. 使用代理对象调用方法</span><br><span class="line">					4. 增强方法</span><br><span class="line">				* 增强方式</span><br><span class="line">					1. 增强参数列表</span><br><span class="line">					2. 增强返回值类型</span><br><span class="line">					3. 增强方法体执行逻辑</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 示例代码 :</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		1. 创建真实对象</span></span><br><span class="line">	Lenovo lenovo = <span class="keyword">new</span> Lenovo();</span><br><span class="line"><span class="comment">//		2. 动态代理增强lenovo对象</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	三个参数 : </span></span><br><span class="line"><span class="comment">		1. 类加载器 : 真实对象.getClass().getClassLoader()</span></span><br><span class="line"><span class="comment">		2. 接口数组 : 真实对象.getClass().getInterfaces()</span></span><br><span class="line"><span class="comment">		3. 处理器  :  new InvocationHandler()</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SaleComputer proxy_lenovo = (SaleComputer) Proxy.newProxyInstance(lenovo.getClass().getClassLoader(), lenovo.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 代理逻辑编写的方法: 道代理对象调用的所有方法都会触发此方法执行</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> method 代理对象调用的方法被封装成的方法对象</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> args 调用方法时的传参</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//				判断此方法是否为要增强的方法</span></span><br><span class="line">			<span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;sale&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//				    1. 增强参数</span></span><br><span class="line">				<span class="keyword">double</span> money = (<span class="keyword">double</span>) args[<span class="number">0</span>];</span><br><span class="line">				money *= <span class="number">1.25</span>;</span><br><span class="line"><span class="comment">//					2. 增强返回值</span></span><br><span class="line">				String value = (String) method.invoke(lenovo, money) + <span class="string">&quot; 鼠标&quot;</span>;</span><br><span class="line"><span class="comment">//					3. 增强方法体执行逻辑</span></span><br><span class="line">				System.out.println(<span class="string">&quot;热情服务&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> value;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//			    真实对象调用method方法</span></span><br><span class="line">				Object o = method.invoke(lenovo, args);</span><br><span class="line"><span class="comment">//				method的返回值</span></span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	System.out.println(proxy_lenovo.sale(<span class="number">8000</span>));</span><br><span class="line">	proxy_lenovo.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Listener：监听器"><a href="#Listener：监听器" class="headerlink" title="Listener：监听器"></a>Listener：监听器</h1><pre><code>* 概念：web的三大组件之一。
    * 事件监听机制
        * 事件    ：一件事情
        * 事件源 ：事件发生的地方
        * 监听器 ：一个对象
        * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码


* ServletContextListener:监听ServletContext对象的创建和销毁
    * 方法：
        * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法
        * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法
    * 步骤：
        1. 定义一个类，实现ServletContextListener接口
        2. 复写方法
        3. 配置
            1. web.xml
                    &lt;listener&gt;
                      &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;
                    &lt;/listener&gt;

                    * 指定初始化参数&lt;context-param&gt;
            2. 注解：
                * @WebListener
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>redis学习</title>
    <url>/2021/11/11/redis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><pre><code>1. 概念 : redis是一款高性能的NOSQL系列的非关系型数据库

2. 下载安装

    * redis.windows.conf : 配置文件
        * redis-cli.exe : redis的客户端
        * redis-server.exe : redis的服务器端

3. 命令操作
    1. redis的数据结构 : 
         * redis存储的是 : key/value格式的数据. 其中key都是字符串, value有5种不同的数据结构
             * value的数据结构
                 1. 字符串类型  String
                 2. 哈希类型  hash  :   map格式
                 3. 列表类型 list   : linkedlist格式
                 4. 集合类型 set    : hashset格式
                 5. 有序集合类型        : sortedset 
     2. 字符串类型 String
         1. 存储 : `set key value`
         2. 获取 : `get key`
         3. 删除 : `del key`
     
     3. 哈希类型  hash  :   map格式
        1. 存储 : `hset key filed value`
        2. 获取 : 
               1. 获取指定的filed对应的value : `hget key filed `
               2. 获取所有的filed和value : `hgetall key`
               3. 删除 : `hdel key filed`
     
     4. 列表类型 list : linkedlist格式
        1. 添加 : 
            1. `lpush key value`: 将元素加入到列表左侧
            2. `rpush key value`: 将元素加入到列表右侧 
        2. 获取 : `lrange key start end` : 范围获取(start从0开始代表左边第一个, end从-1开始表示右边第一个)
        3. 删除 : 
            1. `lpop key`: 将最左边元素删除并返回
            2. `rpop key`: 将最右边元素删除并返回   
         

      5. 集合类型 set : hashset格式
          1. 存储 : sadd key value
          2. 获取 : smembers key : 获取set集合中的所有元素
          3. 删除 : srem key value : 删除set集合中的某个元素

    6. 有序集合类型 : sortedset (按照score升序)
        1. 存储 : zadd key score value
          2. 获取 : zrange key start end
          3. 删除 : srem key value 

    7. 通用命令
        1. key * : 查询所有的键名
        2. type key : 获取键对应的value的类型
        3. del key : 删除指定的key value
4. 持久化
    1. redis是一个内存数据库, 当服务器重启后, 数据将会丢失, 我们可以将redis内存中的数据持久化保存到硬盘的文件中
    2. redis的持久化机制 :
        1.  RDB : 默认方式, 不需要配置, 默认就使用这种机制
            * 在一定的间隔时间中, 检测key的变化情况, 然后持久化数据
            1. 编辑redis.windows.conf文件
                #   In the example below the behaviour will be to save:
                #   after 900 sec (15 min) if at least 1 key changed
                save 900 1
                #   after 300 sec (5 min) if at least 10 keys changed
                save 300 10
                #   after 60 sec if at least 10000 keys changed
                save 60  10000
            2. 重启redis服务器, 并指定配置文件名称
                redis-server.exe redis.Windows.conf

        2. AOF : 日志记录的方式, 可以记录每一条命令的操作, 可以每一次命令操作后, 持久化数据
            1. 编辑redis.windows.conf文件
                appendonly no 关闭 yes 开启

                # appendfsync always     每一次操作都进行一次持久化
                appendfsync everysec     每秒钟进行一次持久化
                # appendfsync no        不进行持久化

5. Java客户端 Jedis
    * Jedis: 一款Java操作redis数据库的工具
    * 使用步骤 : 
        1.    导入jar包
        2.    使用
            //    1. 获取连接
            Jedis jedis = new Jedis(&quot;localhost&quot;, 6379);
            //    2. 操作
            jedis.set(&quot;name&quot;, &quot;chenysh&quot;);
            //    3. 关闭
            jedis.close();
    * jedis操作各种redis中的数据结构
        1. 字符串类型  String
            * set
            * get
            //    1. 获取连接
            Jedis jedis = new Jedis(&quot;localhost&quot;, 6379);
            //    2. 操作
            jedis.set(&quot;name&quot;, &quot;chenysh&quot;);
            String name = jedis.get(&quot;name&quot;);
            System.out.println(name);
            jedis.setex(&quot;checkCode&quot;, 20, &quot;320595&quot;);// 存储右时限的数据
            String checkCode = jedis.get(&quot;checkCode&quot;);
            System.out.println(checkCode);
            //    3. 关闭
            jedis.close();
         2. 哈希类型  hash : map格式
             * hset
             * hget
             * hgetAll
            //    1. 获取连接
            Jedis jedis = new Jedis();// 如果使用空参构造, 则默认为&quot;localhost&quot; 6379
            //    2. 操作
            jedis.hset(&quot;user&quot;, &quot;name&quot;, &quot;zhangsan&quot;);
            jedis.hset(&quot;user&quot;, &quot;age&quot;, &quot;21&quot;);
            jedis.hset(&quot;user&quot;, &quot;gender&quot;, &quot;male&quot;);
    
            String username = jedis.hget(&quot;user&quot;, &quot;name&quot;);
            System.out.println(username);
    
            Map&lt;String, String&gt; users = jedis.hgetAll(&quot;user&quot;);
            Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = users.entrySet();
            for (Map.Entry&lt;String, String&gt; entry : entries) &#123;
                System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue());
            &#125;
            //        3. 关闭
            jedis.close();
        3. 列表类型 list : linkedlist格式
            * lpush/rpush
            * lpop/rpop
            * lrange
            //    1. 获取连接
            Jedis jedis = new Jedis();// 如果使用空参构造, 则默认为&quot;localhost&quot; 6379
            //    2. 操作
            jedis.lpush(&quot;list&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
            jedis.rpush(&quot;list&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    
            List&lt;String&gt; list = jedis.lrange(&quot;list&quot;, 0, -1);
            System.out.println(list);
    
            System.out.println(jedis.lpop(&quot;list&quot;));
            System.out.println(jedis.rpop(&quot;list&quot;));
    
            list = jedis.lrange(&quot;list&quot;, 0, -1);
            System.out.println(list);
            //    3. 关闭
            jedis.close();
        4. 集合类型 set : hashset格式
            * sadd
            * smembers
            //        1. 获取连接
            Jedis jedis = new Jedis();// 如果使用空参构造, 则默认为&quot;localhost&quot; 6379
            //        2. 操作
            jedis.sadd(&quot;set&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
            jedis.sadd(&quot;set&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    
            Set&lt;String&gt; set = jedis.smembers(&quot;set&quot;);
            System.out.println(set);
            //        3. 关闭
            jedis.close();
        5. 有序集合类型 : sortedset 
            * zadd
            * zrange
            //    1. 获取连接
            Jedis jedis = new Jedis();// 如果使用空参构造, 则默认为&quot;localhost&quot; 6379
            //    2. 操作
            jedis.zadd(&quot;sortedset&quot;, 10, &quot;a&quot;);
            jedis.zadd(&quot;sortedset&quot;, 80, &quot;b&quot;);
            jedis.zadd(&quot;sortedset&quot;, 70, &quot;c&quot;);
    
            Set&lt;String&gt; sortedset = jedis.zrange(&quot;sortedset&quot;, 0, -1);
            System.out.println(sortedset);
            //    3. 关闭
            jedis.close();
    * jedis连接池JedisPool
        * 使用 : 
            //    1. 创建配置对象
            JedisPoolConfig config = new JedisPoolConfig();
            config.setMaxTotal(50);// 最大连接数
            config.setMaxIdle(10);// 最大空闲数
            //    2. 创建连接池对象
            JedisPool jedisPool = new JedisPool(config, &quot;localhost&quot;, 6379);
            //  3. 从连接池获取连接
            Jedis jedis = jedisPool.getResource();// 如果使用空参构造, 则默认为&quot;localhost&quot; 6379
            //    4. 操作
            jedis.zadd(&quot;sortedset&quot;, 10, &quot;a&quot;);
            jedis.zadd(&quot;sortedset&quot;, 80, &quot;b&quot;);
            jedis.zadd(&quot;sortedset&quot;, 70, &quot;c&quot;);
    
            Set&lt;String&gt; sortedset = jedis.zrange(&quot;sortedset&quot;, 0, -1);
            System.out.println(sortedset);
            //    5. 关闭, 返还给连接池
            jedis.close();
        * JedisPool工具类
            public class JedisPoolUtils &#123;
                private static JedisPool pool;
            
                public static Jedis getJedis() &#123;
                    return pool.getResource();
                &#125;
            
                public static JedisPool getJedisPool() &#123;
                    return pool;
                &#125;
            
                static &#123;
                    try &#123;
                        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);
                        Properties properties = new Properties();
                        properties.load(is);
                        JedisPoolConfig config = new JedisPoolConfig();
                        config.setMaxTotal(Integer.parseInt(properties.getProperty(&quot;redis.pool.maxTotal&quot;)));
                        config.setMaxIdle(Integer.parseInt(properties.getProperty(&quot;redis.pool.maxIdle&quot;)));
                        pool = new JedisPool(config, properties.getProperty(&quot;redis.ip&quot;), Integer.parseInt(properties.getProperty(&quot;redis.port&quot;)));
                        is.close();
                    &#125; catch (IOException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
    * 注意 : 使用redis缓存一些不经常变化的数据
        * 数据库的数据一旦发生改变, 则需要更新缓存
            * 数据库的表执行增删改的相关操作时, 需要将数据库的数据再次缓存到redis中
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>HTML&amp;CSS&amp;JavaScript学习</title>
    <url>/2021/11/12/HTML&amp;CSS&amp;JavaScript%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h1><pre><code>* Java Web : 
    * Java Web，是用Java技术来解决相关web互联网领域的技术栈。
* 软件架构 :
    1. C/S : client/Server 客户端/服务器端
        * 在客户本地有一个客户端程序, 在远程有一个服务器端程序
        * 如 : qq
        * 优点 : 
            1. 用户体验好
        * 缺点 : 
            1. 开发, 安装, 部署, 维护麻烦
    2. B/S : Browse/Server 浏览器/服务器端
        * 只需要一个浏览器, 客户通过不同的网站(URL), 客户访问不同的服务器端程序
        * 优点 : 
            1. 开发, 安装, 部署, 维护简单
        * 缺点 : 
            1. 如果应用较大, 用户体验不好
            2. 对硬件要求高

* B/S架构详解
    * 资源分类 : 
        1. 静态资源 : 
            * 使用静态网页开发技术发布的资源
            * 特点 : 
                * 所有用户访问, 得到的结果一样
                * 如 : 文本, 图片, 视频, html, css, javascript
                * 如果用户请求的是静态资源, 服务器将会直接将静态资源发送给浏览器, 浏览器使用自带的解析引擎解析并展示
        2. 动态资源 : 
            * 使用动态网页开发技术发布的资源
            * 特点 : 
                * 所有用户访问, 得到的结果可能不同
                * 如 : jsp, servlet, php
                * 如果用户请求的是动态资源, 服务器将会直接将动态资源转换成静态资源发送给浏览器
    * 静态资源 : 
        * HTML : 用于搭建基础网页, 展示页面的内容
        * CSS : 用于美化页面, 布局页面
        * JavaScript : 控制页面的元素, 让页面有一些动态的效果
</code></pre>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><pre><code>1. 概念 : 最基础的网页开发语言
    * Hyper Text Markup Language 超文本标记语言
        * 超文本 (Hyper Text) : 
            * 超文本是用超链接的方法, 将各种不同空间的文字信息, 组织在一起的网状文本
        * 标记语言 (Markup Language) : 
            * 由标签构成的语言. &lt;标签名&gt; 如HTML XML
            * 标记语言不是编程语言

2. 快速入门
    * 语法
        1. html文档后缀名 .html / .htm
        2. 标签分为 : 
            1. 围堵标签 : 有开始和结束标签       &lt;html&gt;&lt;/html&gt;
            2. 自闭和标签 : 开始和结束标签在一起  &lt;br/&gt;
        3. 标签可以嵌套 : &lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;
        4. 在开始标签中可以定义属性, 属性由键值对组成, 值需要用引号(单双都行)引起来;
        5. html的标签不区分大小写, 但推荐使用小写
 
3. 标签学习 : 
    1. 文件标签 : 构成html最基本的标签
        * html : html文档的根标签
        * head : 头标签, 用于指定html文档的一些属性, 引入外部的资源
        * title : 标题标签
        * body : 体标签
        * &lt;!DOCTYPE html&gt; : 定义文档类型。
    2. 文本标签 : 
        * &lt;h1&gt; to &lt;h6&gt;    定义 HTML 标题。
        * &lt;p&gt;    定义段落。
        * &lt;br&gt;    定义简单的换行。
        * &lt;hr&gt;    定义水平线。
        * &lt;!--...--&gt;    定义注释。
        * &lt;b&gt;    定义粗体文本。
        * &lt;i&gt;    定义斜体文本。

    3. 图片标签 : 
        * &lt;img&gt;    定义图像。&lt;img src=&quot;./img/珈乐.jpg&quot;  alt=&quot;珈乐&quot; /&gt;

    4. 列表标签 : 
        * 有序列表 : 
            * ol
            * li
        * 无序列表 : 
            * ul
            * li

    5. 链接标签 : 
        * &lt;a&gt;    定义超链接。&lt;a href=&quot;图片标签.html&quot;&gt;珈乐可爱捏&lt;/a&gt;

    6. 样式和语义标签 : 样式: 联合CSS 语义 : 让程序容易阅读
        * &lt;div&gt;        定义文档中的节。会换行
        * &lt;span&gt;    定义文档中的节。不会换行
        * &lt;header&gt;    定义 section 或 page 的页眉。
        * &lt;footer&gt;    定义 section 或 page 的页脚。

    7. 表格标签 : 
        * &lt;table&gt;    定义表格
            * cellpadding    规定单元边沿与其内容之间的空白。
            * cellspacing   规定单元格之间的空白。
        * &lt;caption&gt;    定义表格标题。
        * &lt;th&gt;    定义表格中的表头单元格。
        * &lt;tr&gt;    定义表格中的行。
        * &lt;td&gt;    定义表格中的单元。
            * rowspan    number    规定单元格可横跨的行数。
            * colspan    number    规定单元格可横跨的列数。
        * &lt;thead&gt;    定义表格中的表头内容。
        * &lt;tbody&gt;    定义表格中的主体内容。
        * &lt;tfoot&gt;    定义表格中的表注内容（脚注）。

    8. 表单标签
        * 表单 : 
            * 概念 : 表单用于向服务器传输数据。
            * 表单能够包含 input 元素，比如文本字段、复选框、单选框、提交按钮等等。
            * &lt;form&gt; 
                * &lt;form&gt;标签用于为用户输入创建 HTML 表单。可以定义一个范围, 范围代表采集用户输入的范围
                * 属性 : 
                    * action    URL    规定当提交表单时向何处发送表单数据。
                    * method    规定用于发送 form-data 的 HTTP 方法。
                        * get
                            1. 请求参数会在地址栏中显示, 会封装到请求行中
                            2. 请求参数大小有限制
                            3. 不太安全
                        * post
                            1. 请求参数不会在地址栏中显示, 会封装到请求体中
                            2. 请求参数大小没有限制
                            3. 相对安全


            * 表单项中的数据要想被提交, 必须指定其name属性
        * 表单项标签
            * &lt;input&gt; : &lt;input&gt; 标签用于搜集用户信息。根据不同的 type 属性值，输入字段拥有很多种形式。
                * type属性 : 
                    * text : 文本输入框, 默认值
                        * placeholder : 指定输入框的提示信息, 但输入框内容发生变化时, 将自动清空

                    * password : 密码输入框


                    * radio : 单选框 
                        * 要实现多个单选框只能选择一个, 则其name属性必须一致
                        * 一般要提供value属性, 来指定选中后提交的内容
                        * checked属性, 可以指定默认选中


                    * checkbox : 复选框
                        * 一般要提供value属性, 来指定选中后提交的内容
                        * checked属性, 可以指定默认选中

                    * file : 文件选择框
                    * hidden : 隐藏域, 用于提交一些信息
                    * 按钮 : 
                        * submit : 提交按钮, 可以提交表单
                        * button : 普通按钮
                        * image : 图片提交按钮, 通过src属性指定文件路径

                * &lt;label&gt; : 指定输入项的文字描述信息, 当其for属性与input的id属性对应时, 点击label区域将自动定位到输入框 
            * &lt;select&gt; : 下拉列表
                * 子元素 : &lt;option&gt;, 指定列表项

            * textarea : 文本域
                * cols : 指定列数
                * rows : 默认行数
4. 案例 : 注册页面 
    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;注册页面&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;1&quot; align=&quot;center&quot;&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;label for=&quot;Email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;Email&quot; name=&quot;Email&quot; id=&quot;Email&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;性别&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt;男
                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt;女
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;label for=&quot;checkCode&quot;&gt;验证码&lt;/label&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;checkCode&quot; id=&quot;checkCode&quot;&gt;
                &lt;img src=&quot;珈乐.jpg&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<h1 id="CSS-页面美化和布局控制"><a href="#CSS-页面美化和布局控制" class="headerlink" title="CSS : 页面美化和布局控制"></a>CSS : 页面美化和布局控制</h1><pre><code>1. 概念 : Cascading Style Sheets : 层叠样式表
    * 层叠 : 多个样式可以作用在同一个html的元素上, 同时生效

2. 好处 : 
    1. 功能强大
    2. 将内容展示和样式控制分离
        * 降低耦合度, 解耦
        * 让分工协作更加容易
        * 提高开发效率

3. CSS的使用 : CSS和html的结合方式
    1. 内联样式
        * 在标签内使用style属性指定css代码
        * 如 : &lt;div style=&quot;color: aqua&quot;&gt;Hello, CSS!&lt;/div&gt;
    2. 内部样式
        * 在head标签内. 定义style标签. style标签的标签体内容就是css代码
        * 如 : 
            &lt;style&gt;
                div &#123;
                    color: green;
                &#125;
            &lt;/style&gt;
    3. 外部样式
        1. 定义css资源文件
        2. 在head标签内, 定义link标签, 引入外部的资源文件
        * 如 : 
            * a.css文件 : 
                div &#123;
                    color: blue;
                &#125;

            &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/a.css&quot;&gt;
    * 注意 : 
        * 1, 2, 3种方式, css作用范围越来越大
        * 1方式不作用, 后期常用2, 3
        * 3格式可以写为 : 
            &lt;style&gt;
                @import &quot;./css/a.css&quot;;
            &lt;/style&gt;
4. CSS语法 : 
    * 格式 : 
        选择器 &#123;
            属性名1:属性值1;
            属性名2:属性值2;
            ...
        &#125;
    * 选择器 : 筛选具有相似特征的元素
    * 注意 : 
        * 每一对属性需要用&quot;;&quot;隔开, 最后一个可以不加

5. 选择器
    * 分类 :
        1. 基础选择器
            1. id选择器
                * 语法 : #id属性值&#123;&#125;
            2. 元素选择器
                * 语法 : 标签名称&#123;&#125;
                * 优先级低于类选择器
            3. 类选择器
                * .class属性值&#123;&#125;
                * 优先级低于id选择器

        2. 扩展选择器
            1. 选择所有元素
                * 语法 : *&#123;&#125;
            2. 并集选择器  : 
                * 语法 : 选择器1, 选择器2 &#123;&#125;
            3. 子选择器 : 筛选选择器1元素下的选择器2元素
                * 语法 : 选择器1 选择器2 &#123;&#125;
            4. 父选择器 : 筛选选择器1元素下的选择器2元素
                * 语法 : 选择器1&gt;选择器2 &#123;&#125;
            5. 属性选择器 : 选择属性名称, 属性名=属性值的元素
                * 语法 : 标签名称[属性名=&quot;属性值&quot;] &#123;&#125;
            6. 伪类选择器 : 选择一些元素具有的状态 
                * 语法 : 标签名称:状态 &#123;&#125;
                * a:link    &#123;color:blue;&#125;
                * a:visited &#123;color:blue;&#125;
                * a:hover   &#123;color:red;&#125;
                * a:active  &#123;color:yellow;&#125;
6. 属性
    1. 字体, 文本
        * font-size : 字体大小
        * color : 文本颜色
        * text-align : 对齐方式
        * line-height : 行高

    2. 背景
        * background

    3. 边框 : 
        * border : 设置边框, 复合属性

    4. 尺寸
        * width
        * height

    5. 盒子模型 : 控制布局
        * margin : 外边框
        * padding : 内边距
            * 默认情况下, 内边距会影响整个盒子的大小
            * box-sizing : border-box; 设置盒子的属性, 让width和height就是最终盒子的大小

        * float : 浮动
            * left
            * right
</code></pre>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><pre><code>* 概念 : 一门客户端脚本语言
    * 运行在客户端浏览器中, 每一个浏览器都有Javascript的解析引擎
    * 脚本语言 : 不需要编译, 直接就可以被浏览器解析运行

* 功能 : 
    * 可以增强用户和html1页面的交互过程, 可以来控制html元素, 让页面有一些动态的效果, 增强用户的体验

* JavaScript = ECMAScript + JavaScript自己特有的东西(BOM + DOM)
* ECMAScript : 客户端脚本语言的标准
    1. 基本语法
        1. 与html结合方式
            1. 内部JS
                * 定义&lt;script&gt;, 标签体内容就是js代码
                 &lt;script&gt;
                       alert(&quot;Hello, JavaScript!&quot;);
                 &lt;/script&gt;
            2. 外部JS
                * 定义&lt;script&gt;, 通过src属性引入外部的js文件
                    &lt;script src=&quot;./js/a.js&quot;&gt;&lt;/script&gt;
            * 注意 : 
                1. &lt;script&gt;可以定义在任意位置, 但位置会影响执行顺序
                2. &lt;script&gt;可以定义多个
        2. 注释
            1. 单行注释 : // 注释内容
            2. 多行注释 : /*注释内容*/
        3. 数据类型
            1. 原始数据类型(基本数据类型):
                1. number : 数字. 整数/小数/NaN(Not a number)
                2. string : 字符串. &quot;abc&quot; &#39;abc&#39; &#39;a&#39;
                3. boolean : true和false
                4. null : 对象为空的占位符
                5. undefined : 一个对象未初始化, 则默认为undefined
            2. 引用数据类型
        4. 变量
            * 变量 : 一块存储数据的内存空间
            * Java语言是强类型语言, 而Javascript是弱类型语言
                * 强类型 : 在开辟变量存储空间时, 定义了空间将来存储的数据的数据类型, 只能存储固定类型的数据
                * 弱类型 : 在开辟变量存储空间时, 不定义了空间将来存储的数据的数据类型, 可以存储任意类型的数据
            * 语法 : 
                * var 变量名 = 初始化值;// 常量
                * let 变量名 = 初始化值;// 局部变量
        5. 运算符
            1. 一元运算符
                * +(-) : 正负号
                * 注意 : 在JS中, 如果运算数不是运算符所要求的类型, 那么JS引擎会自动的将运算数进行类型转换
                    * 其他类型转number:
                        * string转number: 字面值转换, 如果字面不是数字, 则为NaN
                        * boolean转number : true : 1, false : 0;
            2. 算数运算符
            3. 赋值运算符
            4. 比较运算符
                * == : 先进行类型强转再比较
                * ===(全等于), 类型不同直接false
            5. 逻辑运算符
                * 其他类型转boolean :
                    1. number : 0为false, 其余都是true
                    2. string : 空字符串(&quot;&quot;)为false, 其余为true
                    3. null, undefined : false
                    4. 对象 : true
            6. 三元运算符
        6. 流程控制语句
            1. if-else
            2. switch
                * 在JS中, switch可以接受所有原始数据类型
            3. while
            4. do-while
            5. for
    2. 基本对象
        1. function : 函数(方法)对象
            1. 创建 : 
                1. var fun = new Function(形参列表, 方法体);// 不常用
                2. function 方法名称 (形参列表) &#123;方法体&#125;
                3. var 方法名称 = function (形参列表) &#123;方法体&#125;
            2. 属性 : 
                * length : 代表形参个数
            3. 特点 : 
                1. 方法定义时, 形参的类型和返回值类型不需要写
                2. 方法是一个对象, 如果方法名相同, 会覆盖
                3. 在JS中, 没有函数重载, 只与方法名称有关
                4. 在方法声明中有一个隐藏的内置对象(数组), arguments, 封装所有的实际参数
            4. 调用 : 
                * 方法名称(实际参数列表);
        2. Array : 数组对象
            1. 创建
                1. var arr = new Array(元素列表);
                2. var arr = new Array(默认长度);
                3. var arr = [元素列表];
            2. 方法
                * join(分隔符)    将数组的所有元素按照指定的分隔符连接成一个字符串。
                * push()    将新元素添加到数组的末尾，并返回新的长度。
            3. 属性
                   * length : 数组的长度
            4. 特点 : 
                1. 在JS中, 数组元素的类型可变
                2. 在JS中, 数组长度可变
        3. Boolean
        4. Classe
        5. Date
            1. 创建 : 
                * var date = new Date();
            2. 方法 : 
                * toLocalString() : 返回当前date对象对应的时间的本地字符串格式
                * getTime(), 时间戳, 返回从1970.1.1零点到现在的毫秒数
        6. Math
            1. 创建 : 
                * 特点 : 不需要创建直接使用 Math.方法名()
            2. 方法  :
                1. random(): 返回[0, 1)的随机数
                2. ceil(x) : 向上取整
                3. floor(x) : 向下取整
                4. round(x) : 四舍五入为一个整数
        7. Number
        8. RegExp : 正则表达式对象
            1. 正则表达式 : 定义字符串的组成规则
                1. 单个字符 : []
                    如 : [a] [a-z] [a-zA-Z0-9_]
                    * 特殊符号代表特殊含义的单个字符
                        * \d : 单个数字字符 [0-9]
                        * \w : 单个单词字符 [a-zA-Z0-9_]
                2. 量词符号 : 
                    * ? : 表示出现0次或1次
                    * * : 表示出现0次或多次
                    * + : 表示出现1次或多次
                    * &#123;m, n&#125; : m &lt;= 出现次数 &lt;= n  // m, n可缺省
                3. 开始结束符号
                    1. ^ : 开始
                    2. $ : 结束
            2. 正则对象 : 
                1. 创建 : 
                    1. var reg = new RegExp(&quot;正则表达式&quot;);(要使用转义字符\\来代替\)
                    2. var reg = /正则表达式/;
                2. 方法 :
                    1. test(参数) : 验证指定的字符串是否符合正则定义的规范
        9. Global
            1. 特点 : 全局对象, 这个Global中封装的方法不需要对象就可以直接调用.  方法名();
            2. 方法 : 
                * encodeURI() : url编码
                * decodeURI() : url解码
                * encodeURIComponent() : url编码
                * decodeURIComponent() : url解码
                * parseInt() : 将字符串转为数字
                    * 逐一判断每个字符是否是数字, 直到不是数字为止
                * isNaN() : 判断一个值是否是NaN(NaN不能使用==, 因为结果都为false)
                * eval() : 将字符串当成代码执行
        10. 自定义对象
            1. 创建
                1. var 对象名称 = &#123;
                                属性名称1:属性值1,
                                属性名称2:属性值2,
                                ...
                                函数名称:function(形参列表)&#123;&#125;
                            &#125;
</code></pre>
<p>​<br>    * DOM : Document Object Model<br>        * 概念 : Document Object Model 文档对象模型<br>            * 将标记语言文档的各个组成部分, 封装为对象, 可以使用这些对象, 对标记语言进行CRUD的动态操作<br>        * W3C DOM 标准被分成三个不同的部分 :<br>            * 核心DOM - 针对任何结构化文档的标准模型<br>                * Document : 文档对象<br>                * Element : 元素对象<br>                * Attribute : 属性对象<br>                * Text : 文本对象<br>                * COmment : 注释对象<br>                * Node : 节点对象, 是以上五个对象的父对象<br>            * XML DOM : 针对XML文档的标准模型<br>            * HTML DOM : 针对HTML文档的标准模型</p>
<pre><code>    * 核心DOM - 针对任何结构化文档的标准模型
        * Document : 文档对象
            1. 创建(获取) : 在HTML DOM模型中使用Window对象获取
                1. window.document
                2. document
            2. 方法 :     
                1. 获取Element对象 : 
                    * getElementById()    返回对拥有指定 id 的第一个对象的引用。
                    * getElementsByName()    返回带有指定名称的对象集合。
                    * getElementsByTagName()    返回带有指定标签名的对象集合。
                    * getElementsByClassName()    返回带有指定标签名的对象集合。
                2. 创建其他DOM对象:
                    * creatAttribute()
                    * creatComment()
                    * creatElement()
                    * creatTextNode()
            3. 属性
        * Element : 元素对象
            1. 创建(获取) : 使用Document对象获取
            2. 方法 : 
                * removeAttribute() : 删除属性
                * setAttribute() : 设置属性
        * Node : 节点对象, 是以上五个对象的父对象
            1. 特点 : 所有的DOM对象都可以认为是一个节点
            2. 方法 : 
                * CRUD DOM树
                    * appendChild()        向节点的子节点列表的结尾添加新的子节点。
                    * removeChild()        删除（并返回）当前节点的指定子节点。
                    * replaceChild()    用新节点替换一个子节点。

            3. 属性
                * parentNode    返回节点的父节点。
        * 案例 : 动态表格
            &lt;!DOCTYPE html&gt;
            &lt;html lang=&quot;en&quot;&gt;
            &lt;head&gt;
                &lt;meta charset=&quot;UTF-8&quot;&gt;
                &lt;title&gt;动态表格&lt;/title&gt;
            
                &lt;style&gt;
                    table &#123;
                        border: 1px solid;
                        margin: auto;
                        width: 500px;
                    &#125;
            
                    td, th &#123;
                        text-align: center;
                        border: 1px solid;
                    &#125;
            
                    div &#123;
                        text-align: center;
                        margin: 50px;
                    &#125;
                &lt;/style&gt;
            
            &lt;/head&gt;
            &lt;body&gt;
            
            &lt;div&gt;
                &lt;input type=&quot;text&quot; id=&quot;id&quot; placeholder=&quot;请输入编号&quot;&gt;
                &lt;input type=&quot;text&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;
                &lt;input type=&quot;text&quot; id=&quot;gender&quot; placeholder=&quot;请输入性别&quot;&gt;
                &lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;btn_add&quot;&gt;
            &lt;/div&gt;
</code></pre>
<p>​<br>​                <table><br>​                    <caption>学生信息表</caption><br>​                    <tr><br>​                        <th>编号</th><br>​                        <th>姓名</th><br>​                        <th>性别</th><br>​                        <th>操作</th><br>​                    </tr><br>​                </table><br>​                <script><br>​                    let btn_add = document.getElementById("btn_add");<br>​                    btn_add.onclick = function () {<br>​                        let id = document.getElementById("id").value;<br>​                        let name = document.getElementById("name").value;<br>​                        let gender = document.getElementById("gender").value;<br>​                        let table = document.getElementsByTagName("table")[0];<br>​                        table.innerHTML += "    <tr>\n" +<br>​                            "        <td>" + id + "</td>\n" +<br>​                            "        <td>" + name + "</td>\n" +<br>​                            "        <td>" + gender + "</td>\n" +<br>​                            "        <td><a href='javascript:void(0)' onclick='del(this)'>删除</a></td>\n" +<br>​                            "    </tr>"<br>​                    }<br>​<br>                    function del(obj) {<br>                        let td = obj.parentNode.parentNode;<br>                        let table = td.parentNode;<br>                        table.removeChild(td);<br>                    }<br>                </script><br>                </body><br>                </html></p>
<pre><code>    * HTML DOM : 针对HTML文档的标准模型
        1. 标签体的设置和获取 : innerHTML
        2. 使用html元素对象的属性
        3. 控制元素样式
            1. 使用元素的style属性来设置
                如 : 
                    div1.style.border = &quot;1px solid red&quot;;
            2. 提前定义好类选择器的样式, 通过元素的className属性来设置其属性值

* BOM : Browser Object Moadel
    1. 概念 : Browser Object Moadel 浏览器对象模型
        * 将浏览器的各个组成部分封装成对象
    2. 组成
        * Window : 窗口对象
        * Navigator : 浏览器对象
        * Screen : 显示器屏幕对象
        * History : 历史记录对象
        * Location : 地址栏对象

    3. Window : 窗口对象
        1. 创建
        2. 方法
            1. 与弹出窗口有关的方法
                * alert()    显示带有一段消息和一个确认按钮的警告框。
                * confirm()    显示带有一段消息以及确认按钮和取消按钮的对话框。
                    * 如果点击确定则返回true, 反之返回false
                * prompt()    显示可提示用户输入的对话框。
                    * 返回值为用户输入的内容
            2. 与打开关闭有关的方法
                * open()    打开一个新的浏览器窗口或查找一个已命名的窗口。
                    * 返回一个新的Window对象
                * close()    关闭浏览器窗口。
                    * 谁调用关谁
            3. 与定时器有关的方法
                * setTimeout()    在指定的毫秒数后调用函数或计算表达式。
                    * 参数 : 
                        1. JS代码或者方法对象
                        2. 毫秒值
                    * 返回值 : 唯一标识, 用于取消计时
                * clearInterval()    取消由 setInterval() 设置的 timeout。

                * setInterval()    按照指定的周期（以毫秒计）来调用函数或计算表达式。
                * clearTimeout()    取消由 setTimeout() 方法设置的 timeout。

        3. 属性
            1. 获取其他BOM对象
                * Navigator : 浏览器对象
                * Screen : 显示器屏幕对象
                * History : 历史记录对象
                * Location : 地址栏对象
            2. 获取DOM对象
                * document
        4. 特点
            * Window对象不需要创建可以直接使用, window.方法名();
            * window也可以省略 : 方法名();
        5. 案例 : 轮播图 
            &lt;body&gt;
            &lt;img src=&quot;img/珈乐1.jpg&quot; id=&quot;slideshow&quot;&gt;
            &lt;script&gt;
            
                let flag = true;
            
                function fun() &#123;
                    let slideshow = document.getElementById(&quot;slideshow&quot;);
                    if (flag) &#123;
                        slideshow.src = &quot;./img/珈乐2.jpg&quot;;
                    &#125; else &#123;
                        slideshow.src = &quot;./img/珈乐1.jpg&quot;;
                    &#125;
                    flag = !flag;
                &#125;
            
                setInterval(fun, 3000);
            &lt;/script&gt;
            &lt;/body&gt;
4. Localtion : 地址栏对象
    1. 创建(获取):
        * window.location
        * localtion
    2. 方法 : 
        * reload() 重新加载当前文档, 刷新
    3. 属性 : 
        * href 设置或访问完整的URL

    4. 案例 : 自动跳转首页
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;自动跳转&lt;/title&gt;
            &lt;style&gt;
                p &#123;
                    text-align: center;
                &#125;
        
                span &#123;
                    color: red;
                &#125;
            &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;p&gt;
            &lt;span id=&quot;time&quot;&gt;5&lt;/span&gt;秒后, 自动跳转首页
        &lt;/p&gt;
        &lt;script&gt;
            let time = document.getElementById(&quot;time&quot;);
            setInterval(fun, 1000);
            let count = 5;
        
            function fun() &#123;
                count--;
                time.innerText = count + &quot;&quot;;
                if (count == 0) &#123;
                    location.href = &quot;./轮播图.html&quot;
                &#125;
            &#125;
        &lt;/script&gt;
5. History : 历史记录对象
    1. 创建
        * window.history
        * history
    2. 方法 : 
        * back()    加载 history 列表中的前一个 URL。
        * forward()    加载 history 列表中的下一个 URL。
        * go()        加载 history 列表中的某个具体页面。
            * 参数 : 
                * 正数 : 前进几个历史记录
                * 负数 : 后退几个历史记录
    3. 属性 : 
        * length    返回浏览器历史列表(当前窗口)中的 URL 数量。
</code></pre>
<h2 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h2><pre><code>* 概念 : 某些组件被执行了某些操作后, 触发某些代码的执行
    * 事件 : 某些操作, 如 单击. 双击
    * 事件源  : 组件. 如 : 按钮, 文本输入框
    * 监听器 : 代码
    * 注册监听 : 将事件, 事件源, 监听器结合在一起, 当事件源发生了某个事件, 则触发执行某个监听器代码
    * 绑定事件方法
        1. 直接在html标签上, 指定事件的属性(操作), 属性值就是JS代码
            1. 事件 : onclick -------- 单击事件
        2. 通过JS获取元素对象, 指定事件属性, 设置一个函数
    * 事件监听 : JavaScript可以在事件被侦测到时执行代码 
    * 常见事件 : 
        * onclick
        * onblur : 失去焦点
        * onfocus : 获得焦点
        * onload : 一张页面或一幅图像加载完成
        * onsubmit : return false; 不提交 return true; 提交
        * onkeydown

    * 案例 : 电灯开关
        &lt;body&gt;
        &lt;img src=&quot;./img/off.gif&quot; id=&quot;light&quot;&gt;
        &lt;script&gt;
            let light = document.getElementById(&quot;light&quot;);
            let flag = false;
            light.onclick = function () &#123;
                if (flag) &#123;
                    light.src = &quot;./img/on.gif&quot;;
                &#125; else &#123;
                    light.src = &quot;./img/off.gif&quot;;
                &#125;
                flag = !flag;
            &#125;
        &lt;/script&gt;
        &lt;/body&gt;
    * 案例 : 表格全选
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;表格全选&lt;/title&gt;
            &lt;style&gt;
                table &#123;
                    border: 1px solid;
                    width: 500px;
                    margin-left: 30%;
                &#125;
        
                td, th &#123;
                    text-align: center;
                    border: 1px solid;
                &#125;
        
                div &#123;
                    margin-top: 10px;
                    margin-left: 30%;
                &#125;
        
                .over &#123;
                    background-color: bisque;
                &#125;
        
                .out &#123;
                    background-color: white;
                &#125;
            &lt;/style&gt;
        
            &lt;script&gt;
                window.onload = function () &#123;
                    let checkboxs = document.getElementsByClassName(&quot;checkbox&quot;);
                    let trs = document.getElementsByTagName(&quot;tr&quot;);
                    document.getElementById(&quot;selectAll&quot;).onclick = function () &#123;
                        for (let i = 0; i &lt; checkboxs.length; i++) &#123;
                            checkboxs[i].checked = true;
                        &#125;
                    &#125;
                    document.getElementById(&quot;unSelectAll&quot;).onclick = function () &#123;
                        for (let i = 0; i &lt; checkboxs.length; i++) &#123;
                            checkboxs[i].checked = false;
                        &#125;
                    &#125;
                    document.getElementById(&quot;selectRev&quot;).onclick = function () &#123;
                        for (let i = 0; i &lt; checkboxs.length; i++) &#123;
                            checkboxs[i].checked = !checkboxs[i].checked;
                        &#125;
                    &#125;
                    for (let i = 0; i &lt; trs.length; i++) &#123;
                        trs[i].onmouseover = function () &#123;
                            this.className = &quot;over&quot;;
                        &#125;
                        trs[i].onmouseout = function () &#123;
                            this.className = &quot;out&quot;;
                        &#125;
                    &#125;
                &#125;
            &lt;/script&gt;
        
        &lt;/head&gt;
        &lt;body&gt;
        
        &lt;table&gt;
            &lt;caption&gt;学生信息表&lt;/caption&gt;
            &lt;tr&gt;
                &lt;th&gt;&lt;input type=&quot;checkbox&quot; class=&quot;checkbox&quot;&gt;&lt;/th&gt;
                &lt;th&gt;编号&lt;/th&gt;
                &lt;th&gt;姓名&lt;/th&gt;
                &lt;th&gt;性别&lt;/th&gt;
                &lt;th&gt;操作&lt;/th&gt;
            &lt;/tr&gt;
        
            &lt;tr&gt;
                &lt;td&gt;&lt;input type=&quot;checkbox&quot; class=&quot;checkbox&quot;&gt;&lt;/td&gt;
                &lt;td&gt;1&lt;/td&gt;
                &lt;td&gt;令狐冲&lt;/td&gt;
                &lt;td&gt;男&lt;/td&gt;
                &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
            &lt;/tr&gt;
        
            &lt;tr&gt;
                &lt;td&gt;&lt;input type=&quot;checkbox&quot; class=&quot;checkbox&quot;&gt;&lt;/td&gt;
                &lt;td&gt;2&lt;/td&gt;
                &lt;td&gt;任我行&lt;/td&gt;
                &lt;td&gt;男&lt;/td&gt;
                &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
            &lt;/tr&gt;
        
            &lt;tr&gt;
                &lt;td&gt;&lt;input type=&quot;checkbox&quot; class=&quot;checkbox&quot;&gt;&lt;/td&gt;
                &lt;td&gt;3&lt;/td&gt;
                &lt;td&gt;岳不群&lt;/td&gt;
                &lt;td&gt;?&lt;/td&gt;
                &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
            &lt;/tr&gt;
        
        &lt;/table&gt;
        &lt;div&gt;
            &lt;input type=&quot;button&quot; id=&quot;selectAll&quot; value=&quot;全选&quot;&gt;
            &lt;input type=&quot;button&quot; id=&quot;unSelectAll&quot; value=&quot;全不选&quot;&gt;
            &lt;input type=&quot;button&quot; id=&quot;selectRev&quot; value=&quot;反选&quot;&gt;
        &lt;/div&gt;
        &lt;/body&gt;
        &lt;/html&gt;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Bootstrap</title>
    <url>/2021/11/14/Bootstrap/</url>
    <content><![CDATA[<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><pre><code>1. 概念 : 一个前端开发的框架
    * 框架 : 一个半成品网站, 开发人员可以在框架的基础上, 再进行开发, 简化编码
    * 好处 :
        1. 定义了很多的CSS样式的JS插件, 我们开发人员直接可以使用这些样式和插件得到丰富的页面效果
        2. 响应式布局.
            * 同一套页面可以兼容不同分辨率的设备.

2. 快速入门
    &lt;!doctype html&gt;
    &lt;html lang=&quot;zh-CN&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
        &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;
        &lt;title&gt;Bootstrap 101 Template&lt;/title&gt;
    
        &lt;!-- Bootstrap --&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/bootstrap.min.css&quot;
              integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&gt;
    
        &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;
        &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;
        &lt;!--[if lt IE 9]&gt;--&gt;
        &lt;!--    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt;--&gt;
        &lt;!--    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js&quot;&gt;&lt;/script&gt;--&gt;
        &lt;![endif]--&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;h1&gt;你好，世界！&lt;/h1&gt;
    
    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;
    &lt;script src=&quot;./js/jquery-3.2.1.min.js&quot;
            integrity=&quot;sha384-nvAa0+6Qg9clwYCGGPpDQLVpLNn0fRaROjHqs13t4Ggj3Ez50XnGQqc/r8MhnRDZ&quot;
            crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
    &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;
    &lt;script src=&quot;./js/bootstrap.min.js&quot;
            integrity=&quot;sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd&quot;
            crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><pre><code>* 同一套页面可以兼容不同分辨率的设备.
* 实现 : 依赖于栅格系统
* 步骤 : 
    1. 定义容器. 相当于table
        * 容器分类 : 
            1. container : 两边有留白
            2. container-fluid : 100%宽度
    2. 定义行. 相当于之前的tr 样式 : row
    3. 定义元素. 指定该元素在不同的设备上, 所占的各自数目, 样式 : col-设备代号-格子数目
        * 设备代号
            1. xs : 超小屏幕 手机 (&lt;768px)    : col-xs-12
            2. 小屏幕 平板 (≥768px)    
            3. 中等屏幕 桌面显示器 (≥992px)    
            4. 大屏幕 大桌面显示器 (≥1200px)

    * 注意事项:
        1. 一行中如果格子数目超过12, 则超出部分自动换行
        2. 栅格类属性可以向上兼容
        3. 如果真实设备宽度小于设置栅格类属性的设备代码的最小值, 则会一个元素占满一行
</code></pre>
<h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><pre><code>* 全局CSS样式 : 查文档
    * 按钮
    * 
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>MyBatis学习</title>
    <url>/2021/11/15/MyBatis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li></li>
<li>持久层<ul>
<li>负责将数据保存到数据库的那一层代码</li>
<li>JavaEE三层架构 : 表现层, 业务层, 持久层</li>
</ul>
</li>
<li>框架 : <ul>
<li>框架就是一个半成品软件. 是一套可重用的, 通用的, 代码基础代码模型</li>
<li>在框架的基础上构建软件编写更加高效, 规范, 通用, 可扩展</li>
</ul>
</li>
</ul>
<h2 id="Mybatis快速入门"><a href="#Mybatis快速入门" class="headerlink" title="Mybatis快速入门"></a>Mybatis快速入门</h2><ul>
<li>查询user表中所有数据<ol>
<li>创建 user 表</li>
<li>创建模块, 导入坐标</li>
<li>编写 MyBatis 核心配置文件 —&gt;替换连接信息</li>
<li>编写 SQL 映射文件    —–&gt;统一管理sql语句, 解决硬编码问题</li>
<li>编码 : <ol>
<li>定义POJO类</li>
<li>加载核心配置文件, 获取 SqlSessionFactory 对象</li>
<li>获取 SqlSession 对象, 执行 SQL 语句</li>
<li>释放资源</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="Mapper代理开发"><a href="#Mapper代理开发" class="headerlink" title="Mapper代理开发"></a>Mapper代理开发</h2><ul>
<li>使用Mapper代理方式完成入门案例<ol>
<li>定义与SQL映射文件同名的Mapper接口, 并将接口与SQL映射文件放在同一目录下</li>
<li>设置SQL映射文件的namespace属性为Mapper接口全限定名</li>
<li>在Mapper接口中定义方法, 方法名为SQL映射文件中sql语句的id, 并保持参数类型与返回值类型一致</li>
<li>编码<ol>
<li>通过SqlSession的getMapper方法获取Mapper接口的代理对象</li>
<li>调用对应方法完成sql的执行</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="Mapper核心配置文件"><a href="#Mapper核心配置文件" class="headerlink" title="Mapper核心配置文件"></a>Mapper核心配置文件</h2><p><img src="https://raw.githubusercontent.com/ischenysh/images/master/image.6n03go6q1ng0.png" alt="image"></p>
<ul>
<li><p>要严格按照顺序配置</p>
</li>
<li><p>类型别名 :</p>
<ul>
<li>```xml  <typeAliases>
      <package name="com.chenysh.pojo"/>
  </typeAliases>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;package name=&quot;com.chenysh.pojo&quot;/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置数据库的连接环境信息, 可以配置多个environment 通过default属性切换不同的environment--&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;!--数据库连接信息--&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///db1?useSSL=false&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line"></span><br><span class="line">        &lt;environment id=&quot;test&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;!--数据库连接信息--&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///db1?useSSL=false&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--加载sql映射文件--&gt;</span><br><span class="line">        &lt;!--&lt;mapper resource=&quot;com/chenysh/Mapper/UserMapper.xml&quot;/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--Mapper代理方式 : 包扫描--&gt;</span><br><span class="line">        &lt;package name=&quot;com.chenysh.mapper&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="配置文件完成CRUD"><a href="#配置文件完成CRUD" class="headerlink" title="配置文件完成CRUD"></a>配置文件完成CRUD</h2><ul>
<li>数据库表 tb_brand</li>
<li>实体类Brand</li>
<li>测试用例</li>
</ul>
<ul>
<li><p>CRUD的步骤 : </p>
<ol>
<li><p>编写接口方法</p>
</li>
<li><p>编写sql</p>
</li>
<li><p>执行方法</p>
</li>
</ol>
</li>
<li><p>数据库表的字段名称 和 实体类的属性名称 不一样, 则不能自动封装数据</p>
<ul>
<li>解决方法 :<ol>
<li>起别名</li>
<li>sql片段</li>
<li>resultMap :<ol>
<li>定义resultMap标签</li>
<li>在<select>标签中, 使用resultMap属性 替换 resultType属性</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.chenysh.mapper.BrandMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       数据库表的字段名称 和 实体类的属性名称 不一样, 则不能自动封装数据</span></span><br><span class="line"><span class="comment">            解决方法 :</span></span><br><span class="line"><span class="comment">                1. 起别名</span></span><br><span class="line"><span class="comment">                2. sql片段</span></span><br><span class="line"><span class="comment">                3. resultMap :</span></span><br><span class="line"><span class="comment">                    1. 定义resultMap标签</span></span><br><span class="line"><span class="comment">                    2. 在&lt;select&gt;标签中, 使用resultMap属性 替换 resultType属性</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        id : 唯一标识</span></span><br><span class="line"><span class="comment">        type : 映射的类型, 支持别名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            id : 完成主键映射</span></span><br><span class="line"><span class="comment">            result : 完成一般字段映射</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;brand_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;brandName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;company_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;companyName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from tb_brand;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数占位符</p>
<ul>
<li>#{} : 会将其替换 为 ? , 可以防止sql注入</li>
<li>&amp;{} : 拼sql, 会发生sql注入<ul>
<li>使用时机 :<ul>
<li>参数传递时 : #{} </li>
<li>表名或列名不固定时 : &amp;{}(很少用到)</li>
</ul>
</li>
</ul>
</li>
<li>参数类型 : parameterType(可省略</li>
<li>sql语句特殊字符处理<ul>
<li>转义字符 : &lt;</li>
<li>CDATA区 : <![CDATA[ < ]]> (打CD自动提示)</li>
</ul>
</li>
</ul>
</li>
<li><p>参数接收</p>
<ol>
<li>散装参数 : 需要使用@(Param)(“SQL中参数占位符的名称”)</li>
<li>实体类封装参数 : <ul>
<li>需要保证SQL中的参数名与实体类的参数名对应上</li>
</ul>
</li>
<li>map集合<ul>
<li>需要保证SQL中的参数名与map的键值对应上</li>
</ul>
</li>
</ol>
</li>
<li><p>动态SQL : SQL语句会随着用户的输入或外部条件的变化而变化, </p>
<ul>
<li>MyBatis 对动态SQL的支持<ul>
<li>if</li>
<li>choose(when, otherwise)</li>
<li>trim(where, set)</li>
<li>foreach</li>
</ul>
</li>
<li>if : 用于判断参数是否有值, 使用test属性进行条件判断<ul>
<li>存在的问题 : 第一个条件不需要逻辑运算符<ul>
<li>解决方法 : <ul>
<li>使用恒等式让所有条件格式都一样</li>
<li><code>&lt;where&gt;</code>标签替换where关键字</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>增删改需要<ul>
<li><code>sqlSession.commit()</code>来提交事务,</li>
<li><code>SqlSession sqlSession = sqlSessionFactory.openSession(true);</code>来开启动态提交</li>
</ul>
</li>
</ul>
<ul>
<li>当传入数组时, <ul>
<li>使用@(Param)(“SQL中参数占位符的名称”)</li>
<li>使用array</li>
</ul>
</li>
<li>foreach属性<ul>
<li>collection : 容器</li>
<li>item : 迭代元素</li>
<li>open : 开始符号</li>
<li>close : 结束符号</li>
<li>separator : 分隔符</li>
</ul>
</li>
</ul>
<p>批量删除示例代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    delete</span><br><span class="line">    from tb_brand</span><br><span class="line">    where id in</span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		collection : 容器</span></span><br><span class="line"><span class="comment">		item : 迭代元素</span></span><br><span class="line"><span class="comment">		open : 开始符号</span></span><br><span class="line"><span class="comment">		close : 结束符号</span></span><br><span class="line"><span class="comment">		separator : 分隔符</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span>;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>MyBatis参数传递(建议都使用@Param注解来修改Map集合中的默认键名)</p>
<ul>
<li><p>单个参数</p>
<ol>
<li><p>POJO类型 : 直接使用, 实体类属性名 和 参数占位符名称一致</p>
</li>
<li><p>Map集合 : 直接使用, 键名 和 参数占位符名称一致</p>
</li>
<li><p>Collection : 封装成Map集合</p>
<p> <code>map.put(&quot;collection&quot;, collection集合)</code></p>
<p> <code>map.put(&quot;arg0&quot;, collection集合)</code></p>
</li>
<li><p>List : 封装成Map集合</p>
<p> <code>map.put(&quot;collection&quot;, list集合)</code></p>
<p> <code>map.put(&quot;list&quot;, list集合)</code></p>
<p> <code>map.put(&quot;arg0&quot;, list集合)</code></p>
</li>
<li><p>Array : 封装成Map集合</p>
<p> <code>map.put(&quot;array&quot;, array数组)</code></p>
<p> <code>map.put(&quot;arg0&quot;, array数组)</code></p>
</li>
<li><p>其他类型 : 直接使用</p>
</li>
</ol>
</li>
<li><p>多个参数 : 封装成Map集合</p>
<p>  <code>map.put(&quot;arg0&quot;, 参数值1)</code></p>
<p>  <code>map.put(&quot;param1&quot;, 参数值1)</code></p>
<p>  <code>map.put(&quot;arg1&quot;, 参数值2)</code></p>
<p>  <code>map.put(&quot;param2&quot;, 参数值2)</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><p>适用于简单的情况</p>
<p>在方法上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from tb_brand where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">Brand <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Vue入门</title>
    <url>/2021/11/16/Vue%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>Vue是一套前端代码, 免除原生JavaScript中的DOM操作, 简化书写</li>
<li>基于MVVM(Model-View-ViewModel)思想, 实现数据的双向绑定, 将编程关注点放在数据上</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol>
<li><p>新建HTML页面, 引入Vue.js文件</p>
</li>
<li><p>在JS代码区域, 创建Vue核心对象, 进行数据绑定</p>
</li>
<li><p>编写视图</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插值表达式--&gt;</span></span><br><span class="line">    &#123;&#123;username&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">username</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Vue常用指令"><a href="#Vue常用指令" class="headerlink" title="Vue常用指令"></a>Vue常用指令</h2><table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v-bind</td>
<td align="center">为HTML标签绑定属性值, 如设置href, CSS样式等</td>
</tr>
<tr>
<td align="center">v-model</td>
<td align="center">在表单元素上创建双向数据绑定</td>
</tr>
<tr>
<td align="center">v-on</td>
<td align="center">为HTML标签绑定事件</td>
</tr>
<tr>
<td align="center">v-if</td>
<td align="center">条件性的渲染某元素, 判定为true时渲染</td>
</tr>
<tr>
<td align="center">v-else</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">v-else-if</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">v-show</td>
<td align="center">根据条件展示某元素, 区别在于切换的是display属性的值</td>
</tr>
<tr>
<td align="center">v-for</td>
<td align="center">列表渲染, 遍历容器的元素或者对象的属性</td>
</tr>
</tbody></table>
<ul>
<li>简写 : </li>
</ul>
<table>
<thead>
<tr>
<th align="center">全程</th>
<th align="center">缩写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v-bind:href</td>
<td align="center">:href</td>
</tr>
<tr>
<td align="center">v-on:onclick</td>
<td align="center">@click</td>
</tr>
</tbody></table>
<h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><p>mounted : 挂载完成, Vue初始化成功, HTML页面渲染成功</p>
<ul>
<li><p>实例</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">n</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>AJAX和JSON</title>
    <url>/2021/11/16/AJAX%E5%92%8CJSON/</url>
    <content><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>概念 : AJAX(Asynchronous JavaScript And XML) : 异步的的 JaxaScript 和 XML</li>
<li>作用 : <ol>
<li>与服务器进行数据交换 : 通过AJAX可以给服务器发送请求, 并获取服务器响应数据<ul>
<li>使用了AJAX和服务器通信, 就可以使用HTML + AJAX 来替换 JSP 页面</li>
<li>异步的交互 : 可以在不重新加载整个页面的情况下, 与服务器交换数据并更新部分网页的技术, 如 ; 搜索联想, 用户名是否可用校验…</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="AJAX快速入门"><a href="#AJAX快速入门" class="headerlink" title="AJAX快速入门"></a>AJAX快速入门</h2><ol>
<li>编写AjaxServlet, 并使用response输出字符串</li>
<li>创建XMLHttpresponse对象 : 用于和服务器交换数据</li>
<li>向服务器发送请求</li>
<li>获取服务器响应数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建将核心对象</span></span><br><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (window.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span><br><span class="line">    xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// IE6, IE5 浏览器执行代码</span></span><br><span class="line">    xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 发送请求</span></span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost/AJAX_demo/servletAjax&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line"><span class="comment">// 3. 获取响应</span></span><br><span class="line">xmlhttp.onreadystatechange = function () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.readyState == <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul>
<li>AJAX验证用户名是否存在<ol>
<li>给用户名输入框绑定光标失去焦点事件</li>
<li>发送ajax请求, 携带username参数</li>
<li>服务器端接受用户请求</li>
<li>调用service查询User</li>
<li>返回标记</li>
<li>浏览器端处理响应</li>
</ol>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>注册页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">用户名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;tip&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;color: red&quot;</span>&gt;</span>用户已存在<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;username&quot;</span>).onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> username = <span class="built_in">this</span>.value;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 1. 创建将核心对象</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> xmlhttp;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest</span></span><br><span class="line"><span class="javascript">            ) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span></span><br><span class="line"><span class="javascript">                xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// IE6, IE5 浏览器执行代码</span></span></span><br><span class="line"><span class="javascript">                xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 2. 发送请求</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            xmlhttp.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost/AJAX_demo/servletUsernameExist?username=&quot;</span> + username, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            xmlhttp.send();</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 3. 获取响应</span></span></span><br><span class="line"><span class="javascript">            xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (<span class="built_in">this</span>.readyState == <span class="number">4</span> &amp;&amp; <span class="built_in">this</span>.status == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (<span class="built_in">this</span>.responseText == <span class="string">&quot;true&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.getElementById(<span class="string">&quot;tip&quot;</span>).style.display = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.getElementById(<span class="string">&quot;tip&quot;</span>).style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Axios-快速入门"><a href="#Axios-快速入门" class="headerlink" title="Axios 快速入门"></a>Axios 快速入门</h2><ol>
<li><p>引入axios的js文件</p>
</li>
<li><p>使用axios发送请求, 并获取响应结果</p>
<ul>
<li><p>get</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: &quot;get&quot;,</span><br><span class="line">    url: &quot;http://localhost/AJAX_demo/servletAxios?username=zhangsan&quot;</span><br><span class="line">&#125;).then(function (response) &#123;</span><br><span class="line">    alert(response.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>post</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: &quot;post&quot;,</span><br><span class="line">    url: &quot;http://localhost/AJAX_demo/servletAxios&quot;,</span><br><span class="line">    data: &quot;username=zhangsan&quot;</span><br><span class="line">&#125;).then(function (response) &#123;</span><br><span class="line">    alert(response.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>请求方式别名</p>
<ul>
<li><p>get : <code>get(&quot;url&quot;)</code></p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">axios.get(&quot;http://localhost/AJAX_demo/servletAxios?username=zhangsan&quot;).then(function (resp) &#123;</span><br><span class="line">    alert(resp.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>post : <code>post(&quot;url&quot;, 请求参数)</code></p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">axios.post(&quot;http://localhost/AJAX_demo/servletAxios&quot;, &quot;username=zhangsan&quot;).then(function (resp) &#123;</span><br><span class="line">    alert(resp.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>概念 : JavaScript Object Notation. JavaScript 对象表示法</li>
<li>由于其语法简单, 层次鲜明, 现多用于作为<strong>数据载体</strong>, 在网络中进行数据传输</li>
</ul>
<h2 id="JSON语法"><a href="#JSON语法" class="headerlink" title="JSON语法"></a>JSON语法</h2><ul>
<li>定义</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>: [<span class="string">&quot;北京, 上海, 南京&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>获取 </p>
<p>  json.属性名</p>
<p>  <code>json.name</code></p>
</li>
</ul>
<h2 id="Java对象与JSON数据转换"><a href="#Java对象与JSON数据转换" class="headerlink" title="Java对象与JSON数据转换"></a>Java对象与JSON数据转换</h2><ul>
<li>Fastjson : 阿里巴巴提供的JSON库, 可实现Java对象与JSON数据的转换</li>
</ul>
<ol>
<li><p>导入坐标</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.78<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>java对象转JSON</p>
<p> <code>String jsonstr = JSON.toJSONString(obj);</code></p>
</li>
<li><p>JSON字符串转java对象</p>
<p> <code>User user = JSON.parseObject(jsonstr, User.class);</code></p>
</li>
</ol>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2>]]></content>
  </entry>
</search>
